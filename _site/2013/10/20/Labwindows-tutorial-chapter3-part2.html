<!doctype html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]-->
<!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]-->
<!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en"><!--<![endif]-->
<head>
<meta charset="utf-8">
<title>Labwindows.Tutorial.Chapter 3.Part2 &#8211; Lyfing.Loo's Blog</title>
<meta name="description" content="Yet another guy dreams for landing on the moon someday">
<meta name="keywords" content="Tech, C, Labwindows Tutorial">



<!-- Open Graph -->
<meta property="og:locale" content="en_US">
<meta property="og:type" content="article">
<meta property="og:title" content="Labwindows.Tutorial.Chapter 3.Part2">
<meta property="og:description" content="Yet another guy dreams for landing on the moon someday">
<meta property="og:url" content="http://localhost:4000/2013/10/20/Labwindows-tutorial-chapter3-part2.html">
<meta property="og:site_name" content="Lyfing.Loo's Blog">





<link rel="canonical" href="http://localhost:4000/2013/10/20/Labwindows-tutorial-chapter3-part2.html">
<link href="http://localhost:4000/feed.xml" type="application/atom+xml" rel="alternate" title="Lyfing.Loo's Blog Feed">


<!-- http://t.co/dKP3o1e -->
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- For all browsers -->
<link rel="stylesheet" href="http://localhost:4000/assets/css/main.min.css">

<meta http-equiv="cleartype" content="on">

<!-- Load Modernizr -->
<script src="http://localhost:4000/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script>

<!-- Icons -->
<!-- 16x16 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.ico">
<!-- 32x32 -->
<link rel="shortcut icon" href="http://localhost:4000/favicon.png">
<!-- 57x57 (precomposed) for iPhone 3GS, pre-2011 iPod Touch and older Android devices -->
<link rel="apple-touch-icon-precomposed" href="http://localhost:4000/images/apple-touch-icon-precomposed.png">
<!-- 72x72 (precomposed) for 1st generation iPad, iPad 2 and iPad mini -->
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://localhost:4000/images/apple-touch-icon-72x72-precomposed.png">
<!-- 114x114 (precomposed) for iPhone 4, 4S, 5 and post-2011 iPod Touch -->
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://localhost:4000/images/apple-touch-icon-114x114-precomposed.png">
<!-- 144x144 (precomposed) for iPad 3rd and 4th generation -->
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://localhost:4000/images/apple-touch-icon-144x144-precomposed.png">




<style type="text/css">body {background-image:url(http://localhost:4000/images/ps_neutral.png);}</style>


</head>

<body id="post"  itemscope itemtype="http://schema.org/WebPage">

<!--[if lt IE 9]><div class="upgrade"><strong><a href="http://whatbrowser.org/">Your browser is quite old!</strong> Why not upgrade to a different browser to better enjoy this site?</a></div><![endif]-->
<nav id="dl-menu" class="dl-menuwrapper" role="navigation" itemscope itemtype="http://schema.org/SiteNavigationElement">
	<button class="dl-trigger">Open Menu</button>
	<ul class="dl-menu">
		<li><a href="http://localhost:4000">Home</a></li>
		<li>
			<a href="#">About</a>
			<ul class="dl-submenu">
				<li>
					<img src="http://localhost:4000/images/avatar.jpg" alt="Lyfing.Loo photo" class="author-photo">
					<h4>Lyfing.Loo</h4>
					<p>Hangzhou, China</p>
				</li>
				<li><a href="http://localhost:4000/about/">Learn More</a></li>
				<li>
					<a href="mailto:hellolyfing@gmail.com"><i class="icon-envelope"></i> Email</a>
				</li>
				
				
				
				
				
				
				
				
				
			</ul><!-- /.dl-submenu -->
		</li>
		<li>
			<a href="#">Posts</a>
			<ul class="dl-submenu">
				<li><a href="http://localhost:4000/archive/">All Posts</a></li>
				<li><a href="http://localhost:4000/tags/">All Tags</a></li>
			</ul>
		</li>
		
	</ul><!-- /.dl-menu -->
</nav><!-- /.dl-menuwrapper -->




<div id="main" role="main" itemprop="mainContentOfPage" itemscope itemtype="http://schema.org/Blog">
  <article class="hentry" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
    <header class="header-title">
      <div class="header-title-wrap">
        
          <h1 class="entry-title" itemprop="name"><a href="http://localhost:4000/2013/10/20/Labwindows-tutorial-chapter3-part2.html" rel="bookmark" title="Labwindows.Tutorial.Chapter 3.Part2" itemprop="url">Labwindows.Tutorial.Chapter 3.Part2</a></h1>
        
        <h2>October 20, 2013</h2>
      </div><!-- /.header-title-wrap -->
    </header>
    <div class="entry-content" itemprop="description">
      <h5 id="the-1st-part">上接<a href="http://lanfengming.com/blog/Labwindows-tutorial-chapter3-part1.html/">第一节</a>的内容，我们继续本章内容的下半部分。</h5>

<h3 id="createguimine-">5. 编写 <code>createGUI_Mine()</code> 函数的具体实现</h3>

<p><code>createGUI_Mine()</code>要完成的工作有：</p>

<ul>
  <li>创建一个主面板(即主窗口)</li>
  <li>在主面板右侧创建一个Graph控件，用以显示Sine波形</li>
  <li>
    <p>在主面板上创建两个按钮，并分别为他们编写回调函数以实现：</p>

    <ul>
      <li>“Show”按钮：点击后Graph控件上显示出Sine波形，点击后按钮名称变为”Clear”；再次点击该按钮，Graph控件上的Sine波形被清空，按钮名称变回”Show”</li>
      <li>“Quit”按钮：点击后退出程序</li>
    </ul>
  </li>
</ul>

<!--more-->

<h4 id="section">5.1 创建主面板</h4>
<p>LabWindows/CVI提供了一系列可创建各种可视化界面的函数和API，创建面板(Panel)的函数当然也包含其中，但它具体是什么，又应该怎么用呢？我们试着从帮助文档中找寻答案。<br />
打开帮助文档(在LabWindows/CVI的任意界面<strong>按F1快捷键</strong>，或者从菜单栏 <strong>Help</strong> &gt;&gt; <strong>Contents F1</strong>打开)，在<strong>索引</strong>标签栏下的搜索框中输入<em>Panel</em>，在列出的一堆搜索结果中寻找 <code>panels (User Interface Editor)</code> 项，再接着找它的子项 <code>programming with</code>，双击打开它(<strong>如下图所示</strong>)：  </p>

<p><img src="http://ww2.sinaimg.cn/large/6480dca9jw1e9w7ha8bigj20ke0gk458.jpg" alt="F1-Content-Programming-with-Panels.png" />  </p>

<div id="how-to-find-useage"></div>
<p><em>PS：想要查找<strong>某个控件object的使用说明</strong>，可以试着在帮助文档 &gt;&gt; <strong>索引</strong>标签下的搜索框输入它的名称，在搜索结果中找到它的使用介绍项 <code>object_name (User Interface)</code>及其子项，以查找相关帮助资料；想要查找<strong>某个具体函数的使用说明</strong>，方法同上，一般搜索结果第一项便是</em>  </p>

<p>在<strong>Programming with Panels</strong>的帮助文档页面，我们看它的第二段话 </p>

<blockquote>
  <p>NewPanel creates a new panel during program execution. NewPanel returns a handle that you use in subsequent User Interface Library functions to reference the panel. Use the first parameter of NewPanel to specify whether the panel is created as a top-level window or as a child of another (parent) window. You also specify the name, position, and size of the panel through parameters to NewPanel. Creating a new panel using NewPanel does not automatically display the panel. </p>
</blockquote>

<p>这次请自行读完上面的关于 <code>NewPanel()</code> 函数的使用介绍，下面我们将直接使用它。如何使用？请在<strong>索引</strong>标签栏下的搜索框中输入 <code>NewPanel</code> 打开这个函数的帮助文档。<br />
 简单介绍一下，<code>NewPanel()</code> 函数可以创建一个主面板(<em>top-lever panel</em>)，或一个子面板(<em>child panel</em>)，这取决于你给它传入的参数。在这里我们要创建一个<em>主面板</em>，它的各项参数如下：  </p>

<ul>
  <li>面板名称(panelTitle[])：用代码创建的图形界面</li>
  <li>面板的位置及大小(单位:像素)：距屏幕顶部<strong>60</strong>，距屏幕左边<strong>300</strong>，高度<strong>300</strong>,宽度<strong>600</strong></li>
</ul>

<p>现在，我们可以创建一个主面板了：</p>

<pre><code># 为了使创建的主面板居中显示，距屏幕顶部和左边的距离都被换成了系统内部的整型变量VAL_AUTO_CENTER
NewPanel(0, "用代码创建的图形界面", VAL_AUTO_CENTER, VAL_AUTO_CENTER, 300, 600)
</code></pre>

<p>好了，现在我们整个的代码看起来应该是这个样子：</p>

<pre><code>#include 
#include      
#include 

static int panelHandle;

int createGUI_Mine(void);

int main (int argc, char *argv[]){
    if (InitCVIRTE (0, argv, 0) == 0)
        return -1;  /* out of memory */
    if ((panelHandle = createGUI_Mine()) &amp;lt; 0)
        return -1;
    DisplayPanel (panelHandle);
    RunUserInterface();
    DiscardPanel (panelHandle);
    return 0;
}

int createGUI_Mine(){
    int pHandle = NewPanel(0, "用代码创建的图形界面", VAL_AUTO_CENTER, VAL_AUTO_CENTER, 600, 800);
    return pHandle;
}
</code></pre>

<div id="how-to-debug"></div>
<p><strong>OK，到了这一步，先让我们试运行一下上面的程序吧</strong>。运行程序(Debug xxx.exe)的方法有三种：  </p>

<p>1) 菜单栏 <strong>Run</strong> &gt;&gt; <strong>Debug src.exe</strong>
 2) 按快捷键组合 <strong>Shift</strong> + <strong>F5</strong>
 3) 鼠标点击如下按钮</p>

<p><img src="http://ww3.sinaimg.cn/large/6480dca9jw1e9w7i9m65sj20hb037mxp.jpg" alt="Button-Debug-Project.png" /></p>

<p>这时会弹出一个错误框，如下图所示：</p>

<p><img src="http://ww1.sinaimg.cn/large/6480dca9jw1e9w7irfl81j20fh0eemz2.jpg" alt="Error-Content-Missing.prototype.(Require.function....png" /></p>

<p>这是因为在LabWindows/CVI中，所有自定义的函数都是需要预定义，也就是得在 <code>main()</code> 函数之前声明原型(prototype)的。<br />
这好办，只需要把这两个<strong>自定义函数的<em>原型声明</em>添加到 <code>main()</code> 函数之前</strong>就可以了。<strong>但问题是，如何声明原型？</strong>这里最简单的方法是，随便到帮助文档中找一个工程样例(sample)，看看里面的自定义函数的原型声明的句式便可。</p>

<p><em>PS：工程样例（sample）是LabWindows/CVI提供的用来演示如何使用某个控件或函数的可直接编译、运行的程序。<strong>工程样例（sample）是快速入门LabWindows/CVI的编程格式及方法的大好捷径，一有机会就打开查看，有百利而无一害。</strong>如何打开一个工程样例？以 <code>NewPanel()</code> 函数为例，当你在帮助文档中查找到 <code>NewPanel()</code> 函数的文档介绍页后，跳到这个页面的最底部，一般会附上若干工程样例，只需用鼠标单击”Open example”前的图标（如下图所示）便可打开这个叫做”userint\buildui.cws”的工程样例。</em> </p>

<p><img src="http://ww1.sinaimg.cn/large/6480dca9jw1e9w7j7i5p8j20jk0au0uh.jpg" alt="NI_Help_How-To-Use-Project-Example.png" />  </p>

<p>在打开的”buildui.cws”工程样例中，我们点击<strong>buildui.c</strong>文件，找到</p>

<pre><code>/*------------------------------------------------*/
/* Internal function prototypes                   */
/*------------------------------------------------*/ 
</code></pre>

<p>区域，根据这个区域下方的自定义函数的原型声明的方法，我们可以看出，对自定义函数的原型声明其实很简单，只需要把这个函数在左大括号——<strong>{</strong>——之前的内容复制到这里，并在结尾添加行结束标志分号——<strong>；</strong>——即可。不过需要注意的一点是，无参数的函数，在原型声明时需要它在接收参数的括号<strong>()</strong>中加入 <code>void</code> 关键字。具体到本例中，对自定义函数的原型声明句子如下所示：</p>

<pre><code>int createGUI_Mine(void);
</code></pre>

<p>好了，把如上内容添加到main()函数的前面，然后再次试运行这个程序，这时会弹出我们刚刚用代码创建的那个图形界面，它目前还只是一个只有标题栏的空白面板(Panel)。效果图如下：</p>

<p><img src="http://ww1.sinaimg.cn/large/6480dca9jw1e9w7jq97gjj20h409e3yo.jpg" alt="Demo-用代码创建的图形界面.png" />  </p>

<div id="how-to-exit-debug-forcely"></div>
<p>由于还没设置退出选项，所以这个程序无法正常退出。我们可以到启动它的LabWindows/CVI中关闭它：跳转到LabWindows/CVI界面，点击菜单栏 <strong>Running</strong> &gt;&gt; <strong>Terminate Execution</strong>即可（或点击工具栏的<strong>stop</strong>按钮）。</p>

<h4 id="graphsine">5.2 在主面板右侧创建一个Graph控件，用以显示Sine波形</h4>
<p>在创建Graph控件前，请先想一下这两个问题：  </p>

<p>a. Graph控件是依附于哪个实体之上的，它的载体是什么？<br />
 b. Graph控件的创建工作应该被放在哪个部分？<strong>main()</strong>函数中、<strong>createGUI_Mine()</strong>函数中，或者其他地方？</p>

<p>是不是这样的:</p>

<ul>
  <li>问题a：像其他的应用软件一样，控制类、显示类的控件都应该至少依附于一个面板(窗口)之上，也就是说这些控件得有个<strong>载体</strong>。在本章中，Graph控件及其他两个按钮控件(有待创建)都是依附于我们上一步创建的主面板(主界面基本元素)之上的。  </li>
  <li>问题b：光从名字我们便可以看出，<code>createGUI_Mine()</code> 函数就是用来完成创建图形界面元素的工作的，所以Graph控件的创建应该被安排到这里。  </li>
</ul>

<p><em>PS：在这里讲<strong>载体</strong>的概念，是为了之后创建Graph控件时更易理解传入<code>pHandle</code>的原因，就是因为所有的控件都需要一个载体(如面板)</em>  </p>

<p>接下来的问题，Graph控件应该如何创建呢？不知道你发现没，这个问题跟我们上一小节的关于”如何创建一个面板(panel)”的问题非常相似，所以，请你首先试着自己花时间去帮助文档中查找答案(到帮助文档中查找答案的习惯对日后的独立开发有极大帮助，请务必亲试)。  </p>

<p>在帮助文档页，<strong>索引</strong>标签栏下的搜索框中输入<em>Graph</em>，如上一小节查找创建Panel时一样，在搜索结果中我们会找到如下部分的内容：</p>

<pre><code>graph controls (user interface)
   attribute
   events
   fuctions
   operating
   programming with  
</code></pre>

<p>我们尝试从<em>programming with</em>这个页面查找新建graph控件的方法，结果没什么收获。但你看到了，graph control(Graph控件)有一个<em>functions</em>页面，这里面列出了跟本控件有关的所有函数，我们点进去看看。<br />
我们要找到的是创建控件的函数，所以函数名应该会带有<em>New</em>字样，对函数列表逐一查找，便会发现 <code>NewCtrl()</code> 这个函数。对了！就是用它来创建Graph控件的。打开这个函数的帮助页(如何<a href="#how-to-find-useage">打开?</a>)，你会发现，这个函数不光能用来创建Graph控件，它还可以创建LabWindows/CVI提供的其他所有控件(<a href="http://zone.ni.com/reference/en-XX/help/370051V-01/cvi/uiref/cvioperating_controls/">点此查看</a>控件支持列表)。  </p>

<p>关于<code>NewCtrl()</code>函数的用法请自信查看帮助文档。我们这里要创建一个Graph控件，进入 <code>NewCtrl()</code> 函数帮助页，把第二行的函数结构复制下来：  </p>

<pre><code>int NewCtrl (int panelHandle, int controlStyle, char controlLabel[], int controlTop, int controlLeft);
</code></pre>

<p>把它插入到 <code>createGUI_Mine()</code> 函数的第二行：</p>

<pre><code>int createGUI_Mine(){
    int pHandle = NewPanel(0, "用代码创建的图形界面", VAL_AUTO_CENTER, VAL_AUTO_CENTER, 600, 800);
    int NewCtrl (int panelHandle, int controlStyle, char controlLabel[], int controlTop, int controlLeft);        
    return pHandle;
}
</code></pre>

<ul>
  <li><code>NewCtrl()</code>创建好Graph控件后，会返回这个Graph控件的资源句柄(handle)，我们创建一个int型变量<code>graphHdl</code>来接收返回值；</li>
  <li>参数方面，int型的<em>panelHandle</em>就用上一步生成的面板资源句柄(pHandle)赋值，即用上一步创建的面板做它的”载体”；</li>
  <li>int型的<em>controlStyle</em>：欲创建的控件类型，通过查函数的使用帮助可知，要想创建Graph控件，此处应填 <em>CTRL_GRAPH</em>；</li>
  <li>char型的<em>controlLabel[]</em>：Graph的标签，相当于控件标题，此处使用”Created-Graph”；</li>
  <li>int型的<em>controlTop</em>及<em>controlLeft</em>：该控件相对于它的<strong>载体</strong>的位置，<em>top</em>给个<em>30</em>，<em>left</em>给个<em>250</em></li>
</ul>

<p><em>PS：在编程领域，当需要确定一个矩形框的位置时，我们一般只需要指定它左上角那个点相对于它载体的位置即可，然后再分别给这个矩形框赋予长度和高度值。由于左上角位置已确定，长度、高度也已确定，这个矩形框的大小，及它相对于自身载体的位置便唯一确定了。这就好比在一面墙上画一个矩形，先确定它离墙的顶端和左端的距离（即它左上角点的位置），再已知长度、高度的话，从该点出发依次画出长和高，这个矩形在墙上的最终形状及位置便可以确定下来了。</em></p>

<p>于是<code>createGUI_Mine()</code>函数修改为：</p>

<pre><code>int createGUI_Mine(){
    int pHandle = NewPanel(0, "用代码创建的图形界面", VAL_AUTO_CENTER, VAL_AUTO_CENTER, 600, 800);
    int graphHdl = NewCtrl(pHandle, CTRL_GRAPH, "Created-Graph", 30, 250);     
    return pHandle;
}
</code></pre>

<p>试运行一下程序(<a href="#how-to-debug">how?</a>)，我们可以看到之前空空如也的面板上已经多出来一个graph了：</p>

<p><img src="http://ww4.sinaimg.cn/large/6480dca9jw1e9w7k54b76j20h009ct9e.jpg" alt="Demo-添加了graph控件后的图形界面.png" /></p>

<h4 id="showquit">5.3 在主面板上创建两个按钮：<em>show</em>、<em>quit</em>并分别为他们编写回调函数以发挥各自功能</h4>

<h5 id="section-1">5.3.1. 创建按钮</h5>

<p>请读者想一想，应该用什么函数来创建这两个按钮呢？我给你个提示：按钮属于控件范畴~  </p>

<p>没错，就是使用<code>NewCtrl()</code>函数来创建以上两个按钮！创建工作将被而且应该被安排到<code>createGUI_Mine()</code>函数中，我们把它安排到Graph控件的创建之后。  </p>

<p><strong>show</strong>按钮的图形参数，即填入<code>NewCtrl()</code>函数的参数列表：</p>

<ul>
  <li><em>panelHandle</em> = <em>pHandle</em>，即把本函数第一句创建好的面板作为按钮的”载体”；</li>
  <li><em>controlStyle</em> = <em>CTRL_SQUARE_COMMAND_BUTTON</em>，即方形命令按钮，这个值通过查函数的使用方法可得；</li>
  <li><em>controlLabel[]</em> = <em>“show”</em>，即按钮上显示的文字；</li>
  <li><em>controlTop</em> = <em>80</em> ， <em>controlLeft</em> = <em>50</em>，即按钮相对于自己”载体”的上端和左端的位置</li>
</ul>

<p><strong>quit</strong>按钮的图形参数：</p>

<ul>
  <li><em>panelHandle</em> = <em>pHandle</em>，即把本函数第一句创建好的面板作为按钮的”载体”；</li>
  <li><em>controlStyle</em> = <em>CTRL_SQUARE_COMMAND_BUTTON</em>，即方形命令按钮，这个值通过查函数的使用方法可得；</li>
  <li><em>controlLabel[]</em> = <em>“quit”</em>，即按钮上显示的文字；</li>
  <li><em>controlTop</em> = <em>140</em> ， <em>controlLeft</em> = <em>50</em>，即按钮相对于自己”载体”的上端和左端的位置</li>
</ul>

<p>我们分别用整形变量 <em>showBtn</em>及<em>quitBtn</em>来接收创建按钮后返回的资源句柄，于是<code>createGUI_Mine()</code>函数更新为：</p>

<pre><code>int createGUI_Mine(){
    int pHandle = NewPanel(0, "用代码创建的图形界面", VAL_AUTO_CENTER, VAL_AUTO_CENTER, 300, 600);
    int graphHdl = NewCtrl(pHandle, CTRL_GRAPH, "Created-Graph", 30, 250);
    int showBtn = NewCtrl(pHandle, CTRL_SQUARE_COMMAND_BUTTON, "Show", 80, 50);
    int quitBtn = NewCtrl(pHandle, CTRL_SQUARE_COMMAND_BUTTON, "Quit", 140, 50);
    return pHandle;
}
</code></pre>

<p>试运行一下程序，添加了两个按钮的界面如下图所示：</p>

<p><img src="http://ww3.sinaimg.cn/large/6480dca9jw1e9w7kikah0j20h009ejs5.jpg" alt="Demo-添加了show-quit-按钮后的图形界面.png" /></p>

<p>到目前为止，我们已经完成了所有界面元素的创建工作。</p>

<h5 id="section-2">5.3.2 为两个按钮编写回调函数</h5>

<p><em>PS：请读者首先到 帮助文档 &gt;&gt; 索引 标签栏 下的搜索框中输入<code>callback functions</code>然后回车以打开关于回调函数的使用说明页面，请大致浏览一下该页面内容。我在这里简单说一下，回调函数(callback functions)是你绑定到某个特定用户界面元素(比如面板、按钮、Graph控件)上，用以响应发生在该元素上的所有用户事件的函数。例如，你可以给</em>按钮A<em>绑定一个回调函数，并在该回调函数中编写所有可能发生的事件的应对策略，如</em>按下按钮时做动作1<em>、</em>按钮抬起时做动作2<em>、</em>单击按钮时做动作3<em>、</em>双击按钮时…<em>一旦任意一个事件在该元素上发生，LabWindows/CVI便开始调用(执行)这个回调函数，预先设定好的动作便会被触发。</em></p>

<p>如何编写回调函数？在上面提到的那个帮助文档页(即<em>Using Callback Functions to Respond to User Interface Events</em>页面)，我们可以看到三个回调函数的使用样例代码，他们分别是<em>面板</em>、<em>控件</em>以及<em>菜单栏</em>这三种用户界面元素的回调函数使用样例。请读者想一下，上述三种样例，哪一个可以为我们所用？  </p>

<p>当然还是<em>控件</em>的那个样例(<em>ControlResponse</em>)。我们把下面的样例完整地拷贝到我们的<em>src.c</em>主程序中，将其放到<code>createGUI_Mine()</code>函数的下面：</p>

<pre><code>int CVICALLBACK ControlResponse (int handle, int control, int event, void *callbackdata, int eventdata1, int eventdata2){
    ...
}
</code></pre>

<p>现在要做的对这个样例进行DIY改造。</p>

<ol>
  <li>将函数名<code>ControlResponse</code>改为更具体的<code>ButtonsResponse</code>（此改动可有可无）；</li>
  <li>去除一些无关内容</li>
</ol>

<p>精简后，两个按钮的回调函数变为：</p>

<pre><code>int CVICALLBACK ButtonsResponse(int handle, int control, int event, 
            void *callbackdata, int eventdata1, int eventdata2){
    if (control == showBtn) { //如果事件发生在show按钮上
        switch (event) {
            case EVENT_RIGHT_CLICK :
                //右击按钮时作出的响应
                break;
            case EVENT_COMMIT :
                //单击按钮时作出的响应
                break;
        }
    }
    
    if (control == quitBtn) { //如果事件发生在quit按钮上
        switch (event) {
            case EVENT_COMMIT :
                //单击按钮时作出的响应
                break;
        }
    }
    return(0);
}
</code></pre>

<p>当有<a href="http://zone.ni.com/reference/en-XX/help/370051V-01/cvi/uiref/cvievents_overview/">用户事件</a>发生在按钮上，LabWindows/CVI便会调用上面的回调函数，并在调用时将该控件的载体(<em>handle</em>)、控件资源句柄(即资源id-<em>control</em>)、发生的事件id(<em>event</em>)等信息作为参数传入该回调函数。</p>

<p>我们看到上面的回调函数用到了变量<em>showBtn</em>和<em>quitBtn</em>，不过这两个变量是在<code>createGUI_Mine()</code>函数中创建的（局部变量）。为了能全局引用这两个变量，我们需要在<em>函数原型声明</em>部分的上方声明这两个全局变量。鉴于Graph控件也需要全局引用，所以我们在<em>函数原型声明</em>部分的上方添加这样的声明：</p>

<pre><code>...
/* 全局变量声明 */
static int panelHandle;
int graphHdl, showBtn, quitBtn; 

/* 函数原型声明 */
int createGUI_Mine(void);

/* main()函数 */
...
</code></pre>

<p>然后在创建Graph控件以及两个Button按钮的地方(即<code>createGUI_Mine()</code>函数内)，去掉变量名<em>graphHdl</em>、<em>showBtn</em>和<em>quitBtn</em>前面的<em>int</em>即可。</p>

<p>我们来编写<strong>当事件发生在</strong><em>showBtn</em><strong>按钮上时的事件响应</strong>：  </p>

<pre><code>if (control == showBtn) { //如果事件发生在show按钮上
    switch (event) {
        case EVENT_COMMIT :
            //准备一个temp数组，用来存放按钮上要显示的"show"或"stop"字符串
            char temp[8]="" ; GetCtrlAttribute(panelHandle, showBtn, ATTR_LABEL_TEXT, temp);
            //清空graph上的内容，准备画图
            DeleteGraphPlot(panelHandle, graphHdl, -1, VAL_IMMEDIATE_DRAW);
            if (strcmp(temp, "Show") == 0 ){ //如果按钮显示的是"Show"的话
                //准备波形数组
                double waveData[100], amp, phase, cycles;
                int n;
                n = 100;
                amp = 90.0;
                phase = 0.0;
                cycles = 1.5;
                SinePattern(n, amp, phase, cycles, waveData);
                //将波形数组填充到graph图表上
                PlotY(panelHandle, graphHdl, waveData, n, VAL_DOUBLE, VAL_THIN_LINE, 
                      VAL_EMPTY_SQUARE, VAL_SOLID, VAL_CONNECTED_POINTS , VAL_YELLOW);
                SetCtrlAttribute(panelHandle, showBtn, ATTR_LABEL_TEXT, "Clear");
            }
            else{ //如果按钮显示的是"Clear"的话
                SetCtrlAttribute(panelHandle, showBtn, ATTR_LABEL_TEXT, "Show");
            }
            break; 
    }
}
</code></pre>

<p>接着编写<strong>当事件发生在</strong><em>quitBtn</em><strong>按钮上时的事件响应</strong>：</p>

<pre><code>if (control == quitBtn) { //如果事件发生在quit按钮上
    switch (event) {
        case EVENT_COMMIT :
            //单击按钮时作出的响应
            QuitUserInterface(0);
            break;
    }
}
</code></pre>

<p>由于我们的回调函数<code>ButtonsResponse()</code>也是自定义函数，所以需要添加<strong>函数原型声明</strong>，读者还记得<strong>在哪里</strong>以及<strong>如何添加</strong>函数原型声明吗？</p>

<pre><code>...
/* 函数原型声明 */
int createGUI_Mine(void);
int CVICALLBACK ButtonsResponse(int, int, int, void, int, int);
...
</code></pre>

<h5 id="section-3">5.3.3 最后一步，为按钮指派(安装)回调函数。</h5>

<p>也许读者会有疑问：我们不是已经写好回调函数了吗？怎么还要指派(安装)回调函数？事实是：我们虽然已经写好了回调函数，但这个函数和具体控件之间仍是没有任何联系的。指派(安装)回调函数便是为两者建立关联的过程。</p>

<p>为某个控件指派(安装)回调函数用的是<code>InstallCtrlCallback()</code>这个函数，它的函数结构为：</p>

<pre><code>InstallCtrlCallback (int panelHandle, int controlID, CtrlCallbackPtr eventFunction, void *callbackData);
</code></pre>

<p>在使用时，你需要传入控件所属载体的资源句柄(<em>panelHandle</em>)、控件本身的资源句柄(<em>controlID</em>)、控件欲绑定的回调函数(<em>eventFunction</em>)以及在调用该回调函数时欲传给该函数的数据( <em>*callbackData</em>)。特别注意的是，回调函数<em>eventFunction</em>的类型是<em>CtrlcallbackPtr</em>的，这一类型的函数，都必须遵循以下的函数声明结构：</p>

<pre><code>int CVICALLBACK CallbackFunctionName (int panelHandle, int controlID, int event, void *callbackData, int eventData1, int eventData2);
</code></pre>

<p>这也就是为什么我们的<code>ButtonsResponse()</code>函数的前面会有一个全大写的<code>CVICALLBACK</code>标志了。</p>

<p>为<strong>show</strong>、<strong>quit</strong>按钮指派(安装)回调函数将在<code>createGUI_Mine()</code>函数中完成：</p>

<pre><code>InstallCtrlCallback(pHandle, showBtn, ButtonsResponse, 0);
InstallCtrlCallback(pHandle, quitBtn, ButtonsResponse, 0);
</code></pre>

<p>至此，所有工作已经完成，快快试运行一下你的程序吧！</p>

<hr />
<p>程序源码<a href="https://github.com/HelloLyfing/LabWindows-CVI-Tutorial-For-Newbie-By.Lyfing">托管在Github</a>上，请自行前往查看。</p>


      <footer class="entry-meta">
        <span class="entry-tags"><a href="http://localhost:4000/tags/index.html#Tech" title="Pages tagged Tech" rel="tag" class="tag">Tech</a><a href="http://localhost:4000/tags/index.html#C" title="Pages tagged C" rel="tag" class="tag">C</a><a href="http://localhost:4000/tags/index.html#Labwindows Tutorial" title="Pages tagged Labwindows Tutorial" rel="tag" class="tag">Labwindows Tutorial</a></span>
        <span><a href="http://localhost:4000/2013/10/20/Labwindows-tutorial-chapter3-part2.html" rel="bookmark" title="Labwindows.Tutorial.Chapter 3.Part2" itemprop="url">Labwindows.Tutorial.Chapter 3.Part2</a> was published on <span class="entry-date date published updated"><time datetime="2013-10-20T00:00:00+08:00" itemprop="datePublished">October 20, 2013</time></span></span>
        
        <span class="author vcard" itemprop="author" itemscope itemtype="http://schema.org/Person"><span itemprop="name" class="fn"><a href="http://localhost:4000/about" title="About Lyfing.Loo" itemprop="url">Lyfing.Loo</a></span></span>
        
      </footer>
    </div><!-- /.entry-content -->
    <section id="disqus_thread"></section><!-- /#disqus_thread -->
    
    <div class="read-more">
      
        <div class="read-more-header">
          <a href="http://localhost:4000/2013/10/10/Labwindows-tutorial-chapter3-part1.html" class="read-more-btn">Read More</a>
        </div><!-- /.read-more-header -->
        <div class="read-more-content">
          <h3><a href="http://localhost:4000/2014/06/28/upload-browser-cached-image-by-using-xhr.html" title="通过XHR上传浏览器缓存的图片资源">通过XHR上传浏览器缓存的图片资源</a></h3>
          <p>通过发起XHR请求的方式获取浏览器缓存的图片资源 <a href="http://localhost:4000/2014/06/28/upload-browser-cached-image-by-using-xhr.html">Continue reading</a></p>
        </div><!-- /.read-more-content -->
      
      <div class="read-more-list">
        
          <div class="list-item">
            <h4><a href="http://localhost:4000/2014/01/12/Python-a-web-spider-for-fetching-qiubai-articles.html" title="Python爬虫 实现从糗百上多线程抓取内容">Python爬虫 实现从糗百上多线程抓取内容</a></h4>
            <span>Published on January 12, 2014</span>
          </div><!-- /.list-item -->
        
          <div class="list-item">
            <h4><a href="http://localhost:4000/2014/01/09/study-on-python-unicode-encoding-stuff.html" title="关于Python的编码、乱码以及Unicode的一些研究">关于Python的编码、乱码以及Unicode的一些研究</a></h4>
            <span>Published on January 09, 2014</span>
          </div><!-- /.list-item -->
        
      </div><!-- /.read-more-list -->
      
    </div><!-- /.read-more -->
  </article>
</div><!-- /#main -->

<div class="footer-wrapper">
  <footer role="contentinfo">
    <span>&copy; 2014 Lyfing.Loo. Powered by <a href="http://jekyllrb.com">Jekyll</a> hosted on Github Pages using the <a href="https://github.com/mmistakes/hpstr-jekyll-theme">HPSTR Theme</a>.</span>

  </footer>
</div><!-- /.footer-wrapper -->

<script src="http://localhost:4000/assets/js/vendor/jquery-1.9.1.min.js"></script>
<script src="http://localhost:4000/assets/js/scripts.min.js"></script>

<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'lyfing521'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
	        

</body>
</html>
