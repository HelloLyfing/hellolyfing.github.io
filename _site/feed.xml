<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-08-30T14:01:37+08:00</updated><id>http://localhost:4000/</id><title type="html">蓝枫铭的技术博客</title><subtitle>深入学习，天天向上</subtitle><entry><title type="html">微信客服项目简单介绍</title><link href="http://localhost:4000/2018/08/13/%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%9C%8D%E9%A1%B9%E7%9B%AE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html" rel="alternate" type="text/html" title="微信客服项目简单介绍" /><published>2018-08-13T00:00:00+08:00</published><updated>2018-08-13T00:00:00+08:00</updated><id>http://localhost:4000/2018/08/13/%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%9C%8D%E9%A1%B9%E7%9B%AE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="http://localhost:4000/2018/08/13/%E5%BE%AE%E4%BF%A1%E5%AE%A2%E6%9C%8D%E9%A1%B9%E7%9B%AE%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.html">&lt;p&gt;最近与同事协作完成微信客服项目的设计和开发工作。系统要完成的功能也很简单：打通微信与客服IM系统，让用户（像跟普通好友聊天一样）在自己微信上就可以实现与客服系统的直接对话。&lt;/p&gt;

&lt;p&gt;对微信生态中好友、消息和群的第三方管理系统也有很多，不过为了稳定性和功能快速定制化，我们依然决定自研这套系统。现简单介绍一下这个系统。&lt;/p&gt;

&lt;h3 id=&quot;系统功能介绍图&quot;&gt;系统功能介绍图&lt;/h3&gt;

&lt;p&gt;目前该系统在登录的时候仍然需要用手机扫码登录，不过一经登录基本不会掉线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08/weixin-kefu-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;开发难点--技术点&quot;&gt;开发难点 / 技术点&lt;/h2&gt;

&lt;p&gt;在系统开发过程中遇到的一些难点和有意义的知识点，记录并分享下。&lt;/p&gt;

&lt;h3 id=&quot;项目从单机到集群可横向扩容的改造&quot;&gt;项目从单机到集群：可横向扩容的改造&lt;/h3&gt;

&lt;p&gt;微信消息轮询获取，目前只能支持单机模式。在较恶劣的情况下（单机偶现不可用、代码发布重启应用时）会出现微信登录状态丢失、微信服务不可用的情况。针对此问题，我们重构了消息轮询逻辑，将微信登录状态、微信接收的消息等内容持久化至Redis中，通过分布式轮询的方式保证微信客服的高可用，详见下方说明：&lt;/p&gt;

&lt;p&gt;借助微信API实现的业务逻辑：&lt;/p&gt;

&lt;p&gt;客服每登录一个微信号，都需要创建三个线程。其中线程A很快退出，线程B和线程C则持久运行。&lt;/p&gt;

&lt;p&gt;线程B和线程C对绑定了微信Session信息的HttpClient重度依赖，微信消息队列也使用的应用共享内存，这导致：
1）应用无法做分布式和可高可用；
2）线程资源无法共享(缺少线程池的概念)&lt;/p&gt;

&lt;p&gt;针对这种情况，微信客服项目准备做如下重构：
1）微信Session信息和微信消息，分别接入分布式存储和队列（实验性阶段，暂时用Redis实现）
2）创建线程池，分别执行线程B和线程C的原有业务内容&lt;/p&gt;

&lt;p&gt;重构前流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08/weixin-kefu-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;重构后流程图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08/weixin-kefu-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;并发模式下如何利用mysql特性避免同一记录被重复插入&quot;&gt;并发模式下，如何利用Mysql特性避免同一记录被重复插入&lt;/h3&gt;
&lt;p&gt;用户通过微信发送的消息到达我方的IM服务器后，需要自动为该用户分配一个会员UID，如果已有则会直接使用该UID。存储UID的表结构如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/2018-08/weixin-kefu-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们会根据表中的备注名生成会员邮箱，所以每次注册会员获取会员的UID时，会员服务化会保证返回的UID总是同一个，我们在获取到该UID后，会尝试将信息插入上图的wx_bb_uid_map表中。&lt;/p&gt;

&lt;p&gt;但问题是，我们处理消息的方式是并发的，上面的步骤有可能被并发执行，但是我们的system_uid又没有设置唯一索引，所以在高并发下场景下我们发现有多条记录保存的是一模一样的值。&lt;/p&gt;

&lt;p&gt;遇到这种问题，在插入前使用分布式锁也是可以的，不过能不能利用Mysql的特性去实现“已存在的记录不再插入”的目的呢？答案是：可以的。由于system_uid未使用唯一索引，所以无法利用：INSERT ON DUPLICATE KEY UPDATE 或者 INSERT IGNORE，但是利用INSERT INTO SELECT句式可以达到：如果system_uid已存在，则不插入记录的目的。&lt;/p&gt;

&lt;p&gt;从SQL语句中可以看出，这是直接SELECT的值（而不是某表的字段）作为INSERT的入参，而且SELECT内容在WHERE判断记录已存在的情况下将会为空，即插入操作由于未发现值而被跳过。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSERT INTO `wx_bb_uid_map` ( wxuin, nick_name, remark_name, system_uid, gmt_create, gmt_modified ) 
SELECT
    123,
    &quot;wx小号&quot;,
    &quot;姓名&quot;,
    1024,
    1531816594,
    1531816594 
FROM
    `wx_bb_uid_map` 
WHERE
    NOT EXISTS ( SELECT id FROM `wx_bb_uid_map` WHERE system_uid = 1024) 
    LIMIT 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;客服回复消息频率控制&quot;&gt;客服回复消息频率控制&lt;/h3&gt;
&lt;p&gt;由于我方的微信账号(个销号)是：给每个账号分配若干个人工客服进行消息收发，为防止由于消息发送频率过高导致的被风控，我们对人工客服对单个微信账号的回复频率做了频率限制。此处的频率限制使用了Redis做频率计数器，并以秒为单位过期计数器，达到控制发送速率的目的。&lt;/p&gt;</content><author><name></name></author><summary type="html">最近与同事协作完成微信客服项目的设计和开发工作。系统要完成的功能也很简单：打通微信与客服IM系统，让用户（像跟普通好友聊天一样）在自己微信上就可以实现与客服系统的直接对话。</summary></entry><entry><title type="html">日常开发问题记录</title><link href="http://localhost:4000/2018/08/01/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html" rel="alternate" type="text/html" title="日常开发问题记录" /><published>2018-08-01T00:00:00+08:00</published><updated>2018-08-01T00:00:00+08:00</updated><id>http://localhost:4000/2018/08/01/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95</id><content type="html" xml:base="http://localhost:4000/2018/08/01/%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html">&lt;h2 id=&quot;邮件发送时一直报错问题排查&quot;&gt;邮件发送时一直报错问题排查&lt;/h2&gt;
&lt;p&gt;今天需要用Spring Boot发送邮件，使用的腾讯企业邮箱（QQ邮箱），yaml配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;spring:
  mail:
    host: smtp.exmail.qq.com
    port: 465
    username: biz-noreply@example.com
    password: password-example
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
            required: true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Spring Boot引入了mail包之后，使用自动注入的Bean&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaMailSender&lt;/code&gt;发送邮件，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SimpleMailMessage simpleMailMessage = new SimpleMailMessage();
simpleMailMessage.setFrom(&quot;biz-noreply@example.com&quot;);
simpleMailMessage.setTo(emails);
simpleMailMessage.setSubject(title);
simpleMailMessage.setText(content);
javaMailSender.send(simpleMailMessage);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结果每次在发送时，始终都会报&lt;code class=&quot;highlighter-rouge&quot;&gt;Could not connect to SMTP host: smtp.exmail.qq.com, port: 465, response: -1&lt;/code&gt;的错误，怎么试都是这个结果，错误详情如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;javax.mail.MessagingException: Could not connect to SMTP host: smtp.exmail.qq.com, port: 465, response: -1
    at com.sun.mail.smtp.SMTPTransport.openServer(SMTPTransport.java:2197)
    at com.sun.mail.smtp.SMTPTransport.protocolConnect(SMTPTransport.java:740)
    at javax.mail.Service.connect(Service.java:366)
    at org.springframework.mail.javamail.JavaMailSenderImpl.connectTransport(JavaMailSenderImpl.java:515)
    at org.springframework.mail.javamail.JavaMailSenderImpl.testConnection(JavaMailSenderImpl.java:396)
    at org.springframework.boot.actuate.mail.MailHealthIndicator.doHealthCheck(MailHealthIndicator.java:43)
    at org.springframework.boot.actuate.health.AbstractHealthIndicator.health(AbstractHealthIndicator.java:84)
    at org.springframework.boot.actuate.health.CompositeHealthIndicator.health(CompositeHealthIndicator.java:68)
    at org.springframework.boot.actuate.health.HealthEndpoint.health(HealthEndpoint.java:47)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:498)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;后来，&lt;strong&gt;把端口从&lt;code class=&quot;highlighter-rouge&quot;&gt;465&lt;/code&gt;改为&lt;code class=&quot;highlighter-rouge&quot;&gt;587&lt;/code&gt;就好了&lt;/strong&gt;，就是这么神奇。&lt;/p&gt;

&lt;p&gt;而且，腾讯企业邮的帮助文档里，压根就没提到587这个端口(http://service.exmail.qq.com/cgi-bin/help?subtype=1&amp;amp;&amp;amp;id=28&amp;amp;&amp;amp;no=1000585 )！我还是在QQ邮箱的帮助页面找到的这个端口…&lt;/p&gt;</content><author><name></name></author><summary type="html">邮件发送时一直报错问题排查 今天需要用Spring Boot发送邮件，使用的腾讯企业邮箱（QQ邮箱），yaml配置如下：</summary></entry><entry><title type="html">Java并发编程之：Java内存模型</title><link href="http://localhost:4000/2018/07/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" rel="alternate" type="text/html" title="Java并发编程之：Java内存模型" /><published>2018-07-30T00:00:00+08:00</published><updated>2018-07-30T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B:Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B</id><content type="html" xml:base="http://localhost:4000/2018/07/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html">&lt;div class=&quot;wiki-content&quot;&gt;
                           &lt;p&gt;前言：Java内存模型详细说明了Java虚拟机(以下将使用JVM这个术语)是如何与计算机的内存(RAM)进行交互的。JVM是一个完整计算机的模型，所以该模型也包含了内存模块，也就是我们熟知的Java内存模型。&lt;/p&gt;&lt;p&gt;想要设计出符合预期的并发程序，了解Java的内存模型是非常重要的。Java内存模型详细描述了不同的线程如何以及何时可以看见被其他线程写入的共享变量，以及在需要时如何同步使用共享变量。&lt;/p&gt;&lt;p&gt;Java内存模型在一开始是不够完善的，不过它在Java 1.5中被改进了。Java8依然在使用这一改进版本的内存模型。&lt;/p&gt;&lt;h1 id=&quot;id-译文：Java并发编程之：Java内存模型-一、一窥Java内存模型的内部&quot;&gt;一、一窥Java内存模型的内部&lt;/h1&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;JVM中的Java内存模型将内存分为线程栈(thread stacks)和堆(heap)。下图从逻辑角度演示了Java的内存模型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-1.png&quot; data-image-src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-1.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;在JVM中运行的每个线程都有自己的线程栈。线程栈包含的信息为：当前方法执行到的点。我将称这个栈为“调用栈”，当线程执行代码时，调用栈也会随之变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;线程栈还包含了每个被执行的方法（所有位于调用栈的方法）内部的所有局部变量(local variables)。一个线程只能访问自己的线程栈。由一个线程创建的内部变量，对其他线程是不可见的。即便两个线程在执行一模一样的代码，他们仍然会在自己的线程栈中创建各自的局部变量。也就是说，每个线程都有自己的局部变量的版本。&lt;/p&gt;&lt;p&gt;所有原始类型( boolean, byte, short, char, int, long, float, double)的局部变量全部都存储在线程栈中，所以它们对其他线程是不可见的。一个线程可以向其他线程传递原始类型变量的拷贝，但无法共享内部的原始类型变量。&lt;/p&gt;&lt;p&gt;堆则包含了所有Java对象(objects)，无论它们是由哪个线程创建的，这些对象包括对原始类型封装而成的包装类(Integer、Long等)。无论对象是在局部被创建并赋值给局部变量，还是作为其他对象的成员被创建的。这些对象始终都位于堆中。&lt;/p&gt;&lt;p&gt;下图展示了线程栈中存储的调用栈和局部变量，以及堆中存储的对象：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-2.png&quot; data-image-src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-2.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;一个局部变量如果是原始类型的，则它会存储在线程栈中。&lt;/p&gt;&lt;p&gt;一个局部变量如果是对一个对象的引用，则这个变量的引用会存储在线程栈中，但引用的对象则会存储在堆中。&lt;/p&gt;&lt;p&gt;一个对象的方法以及方法内的局部变量，也是存储在线程栈中，即便这个对象本身存储在堆中。&lt;/p&gt;&lt;p&gt;一个对象的成员变量(Field)和对象一样存储在堆中，无论这个成员变量是原始类型还是对对象的引用。此外，静态类变量也是存储在堆中。&lt;/p&gt;&lt;p&gt;处于堆中的对象，可以被任何拥有其引用的线程访问到。当一个线程访问一个对象时，它也可以访问到对象的成员变量(Field)和方法。如果两个线程在同一时间访问同一个对象的方法，他们可以同时调用该对象的该方法，不过每个线程都会拥有一份方法内的局部变量的拷贝。&lt;/p&gt;&lt;p&gt;下图演示了上面提到的那些点：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-3.png&quot; data-image-src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-3.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;两个线程有一组局部变量。其中一个局部变量Local Variable 2指向了位于堆中的对象Object 3。这两个线程的局部变量和引用是不一样的，它们存储在各自的线程栈中，虽然二者指向的同一个对象存储在堆中。&lt;/p&gt;&lt;p&gt;注意对象Object 3的成员变量，分别引用了对象Object 2和对象Object 4（注意图中Object 3指向Object 2和Object 4的箭头），藉由对象Object 3中的成员变量，两个线程也可以访问到对象Object 2和Object 4。&lt;/p&gt;&lt;p&gt;图中也展示了：线程栈中的methodTwo()中的局部变量Local Variable 1指向位于堆中的两个不同对象的情况。此时这个引用指向了两个不同的对象（Object 1和Object 5），而不是同一对象。理论上每个线程都可以访问到这两个对象Object 1和Object 5，前提是每个线程都有指向这两个对象的引用。不过在上图中，每个线程只有一个指向两个对象之一的引用。&lt;/p&gt;&lt;p&gt;那么，用什么样的Java代码可以反推出上面的内存图呢？其实，图例对应的Java代码也很简单：&lt;/p&gt;


&lt;pre&gt;&lt;code&gt;public class MyRunnable implements Runnable() {
 
    public void run() {
        methodOne();
    }
 
    public void methodOne() {
        int localVariable1 = 45;
 
        MySharedObject localVariable2 =
            MySharedObject.sharedInstance;
 
        //... do more with local variables.
 
        methodTwo();
    }
 
    public void methodTwo() {
        Integer localVariable1 = new Integer(99);
 
        //... do more with local variable.
    }
}
&lt;/code&gt;&lt;/pre&gt;


&lt;pre&gt;&lt;code&gt;public class MySharedObject {
 
    //static variable pointing to instance of MySharedObject
 
    public static final MySharedObject sharedInstance =
        new MySharedObject();
 
 
    //member variables pointing to two objects on the heap
 
    public Integer object2 = new Integer(22);
    public Integer object4 = new Integer(44);
 
    public long member1 = 12345;
    public long member1 = 67890;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;br /&gt;如果启动两个线程同时执行run()方法，就能得出上图中的那些关系。run()方法调用了methodOne()，methodOne()又调用了methodTwo().&lt;p&gt;methodOne()定义了一个原始int型的局部变量localVariable1，以及一个对对象引用的局部变量localVariable2。&lt;/p&gt;&lt;p&gt;每个执行methodOne()的线程都会在自己的线程栈中创建localVariable1和localVariable2的拷贝。各线程之间的localVariable1是完全隔离的，只存在于各自的线程栈中。线程A无法看到其他线程对拷贝来的localVariable1做出的改变。&lt;/p&gt;&lt;p&gt;每个执行methodOne()的方法，也都会创建属于自己的localVariable2的拷贝。然而，这两份独立的互不相干的localVariable2拷贝，其引用都指向了位于堆中的同一对象Object 3。从代码中可以看出，localVariable2的引用指向了另外一个对象MySharedObject中的静态成员变量sharedInstance。我们知道对象的静态成员变量只有一份，而且是存储在堆中的。这样一来，两份独立的localVariable2的拷贝最终都指向了MySharedObject对象中的同一个静态成员变量所指向的对象：MySharedObject的实例，也就是上图中的Object 3。&lt;/p&gt;&lt;p&gt;注意观察MySharedObject也包含了两个Integer类型的成员变量。这两个成员变量和对象本身都存储在堆中。二者分别指向了两个即时创建的Integer对象Object 2和Object 4，如上图所示。&lt;/p&gt;&lt;p&gt;注意观察methodTwo()创建了一个局部变量localVariable1。这个局部变量是对一个Integer对象的引用。该方法将localVariable1的引用指向了一个新的Integer对象实例。局部变量localVariable1储存在每个执行methodTwo()的线程的线程栈中。由于每个线程每次执行methodTwo()时都会创建新的Integer对象，所以当两个线程执行该方法时会创建两个独立的Integer对象，即上图中的Object 1和Object 5。&lt;/p&gt;&lt;p&gt;注意MySharedObject对象中的两个原始long类型的成员变量。由于这些变量是原始类型的，所以他们和对象本身都会存储在堆中。只有方法中的局部变量会存储在线程栈中。&lt;/p&gt;&lt;h1 id=&quot;id-译文：Java并发编程之：Java内存模型-二、物理内存的结构&quot;&gt;二、物理内存的结构&lt;/h1&gt;&lt;p&gt;现代的物理内存架构和JVM中的Java内存模型有些不同。为了更好地理解Java内存模型是如何与硬件内存相互协作的，我们也需要了解下物理内存的结构。本节会描述一个常见的物理内存架构，后续章节则会介绍Java内存模型是如何与之协作的。&lt;/p&gt;&lt;p&gt;下面是一个简化版的现代计算机硬件结构图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-4.png&quot; data-image-src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-4.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;一个现代计算机通常会有2个或更多的CPU，有些CPU还会有多个核心。关键在于，一个拥有两个或更多CPU的现代计算机，同步执行多个线程任务是完全可能的。每个CPU在任何时间都可以执行一个线程。也就是说，如果你的Java应用是多线程的，那么为每个线程分配一个CPU，同步(并行)地运行的Java任务也是有可能的。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;每个CPU都包含了一组寄存器，这些寄存器本质上其实是更靠近CPU的内存(in-CPU memory)，我们还是叫它寄存器吧。CPU在寄存器上执行的操作比在主内存(main memory)上要快得多。这是因为CPU访问寄存器的速度比访问主内存要快得多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个CPU可能也会有一个CPU缓存层。事实上，大多数现代CPU都有一个大小不一的缓存层。CPU访问缓存的速度虽然没有访问内部寄存器快，但却比访问主内存要快的多。所以CPU访问缓存的速度是介于访问内部寄存器和访问主内存之间的。有些CPU可能会有多层级的缓存（Level 1 and Level 2等），但这跟理解Java内存模型的原理关系不大，重要的是了解到CPU有一个缓存层。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;计算机还有一个主内存(main memory area，即RAM)。所有CPU都可以访问主内存。主内存的大小通常也比CPU的缓存更大一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;通常情况下，当CPU需要访问主内存时，它会读取部分主内存中的信息放入CPU缓存。CPU也会读取部分缓存中的信息放入内部寄存器，然后在其之上进行操作。当CPU需要把计算结果写回主内存时，它会先把内部寄存器的值flush(拷贝后清空)至缓存，然后在某个时间点再把缓存中的值flush至主内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;CPU缓存中的值flush至主内存，通常发生在CPU需要在缓存中存储其他值时。在某个时间点，CPU缓存中写入的数据只占了缓存空间的一部分，同样在某个时间点，它会flush back部分数据至主内存。当数据更新时，它并不需要读取或写入整个缓存。通常情况下，缓存以一个更小的内存块来更新，这个内存块就叫做”缓存行”(cache lines)。一条或多条缓存行会被读入缓存中，另外一条或多条缓存行又会被flush back至主内存中。&lt;/span&gt;&lt;/p&gt;&lt;h1 id=&quot;id-译文：Java并发编程之：Java内存模型-三、打通Java内存模型与物理内存结构&quot;&gt;三、打通Java内存模型与物理内存结构&lt;/h1&gt;&lt;p&gt;上面已经说过Java内存模型和物理内存结构是不同的。物理内存结构不会区分线程栈和堆。在硬件层面，线程栈和堆都是存储在主内存中的。部分线程栈或堆的信息会出现在CPU缓存及内部寄存器中。线程栈和堆在CPU寄存器、缓存以及主内存中的存储关系如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-5.png&quot; data-image-src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-5.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;当对象和变量存储在计算机中不同的存储区域（如CPU缓存和主内存中）时，某些问题便会出现。两个主要的问题有：&lt;/p&gt;&lt;ol style=&quot;margin-left: 30.0px;&quot;&gt;&lt;li&gt;线程更新共享变量时的可见性&lt;/li&gt;&lt;li&gt;共同读、检查以及写共享变量时引发的竞争情形(Race conditions)&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面章节会讨论这两个问题。&lt;/p&gt;&lt;h2 id=&quot;id-译文：Java并发编程之：Java内存模型-31共享对象的可见性问题&quot;&gt;3.1 共享对象的可见性问题&lt;/h2&gt;&lt;p&gt;如果两个或更多的线程共享同一对象，又没有恰当地使用volatile声明或synchronization声明，那么当线程A更新共享对象的信息时，其他线程可能看不到。&lt;/p&gt;&lt;p&gt;想象一下，共享的对象一开始存储在主内存中。运行在CPU-1中的线程A将共享对象读入CPU缓存中，接着对共享对象做了一个更新操作。只要CPU-1中的缓存没有被flush back至主内存，那么共享对象变更后的版本对运行在其他CPU上的线程便是不可见的。这样一来，运行在不同CPU中的线程，在各自CPU的缓存中都会对共享的对象有一份各自的临时拷贝。&lt;/p&gt;&lt;p&gt;下面的图例演示了这种情况：运行在左侧CPU中的线程将共享对象拷贝至CPU缓存中，然后将该对象的count变量更新为2. 但这个变更对运行在右侧CPU中的线程是不可见的，因为此时更新后的count值还没有被flush back至主内存中。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-6.png&quot; data-image-src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-6.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;你可以使用Java中的&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;关键字来避免这种情况。&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;关键字可以保证在读取给定变量时直接从主内存中读取，当变量值更新时又会被写回主内存中。&lt;/p&gt;&lt;h2 id=&quot;id-译文：Java并发编程之：Java内存模型-32竞争情形（Raceconditions）&quot;&gt;3.2 竞争情形（Race conditions）&lt;/h2&gt;&lt;p&gt;如果两个或以上的线程共享同一对象，并且有一个或多个线程在更新共享的对象，竞争情形便会出现。&lt;/p&gt;&lt;p&gt;想象一下：线程A将共享对象的count变量读入CPU缓存中，接着线程B也做了同样的事，不过读入了另外一个CPU缓存中。现在线程A将count加1，线程B也会这么做。那么count变量实际自增了两次，分别在两个CPU缓存中完成。&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;如果这些自增是按顺序执行的（即在同一CPU缓存中执行），那么count变量会被自增两次，最后以count + 2的结果写回主内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span style=&quot;&quot;&gt;然而，这两次的自增实际上是并行执行的，并且没有保证顺序。尽管线程A和B分别对count自增了一次，之后也会将更新后的结果回写至主内存，但最终的结果是count只增加了1。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面的图例演示了上面提到的竞争情形：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-5.png&quot; data-image-src=&quot;http://hellolyfing.github.io/images/java_concurrency/java-memory-model-5.png&quot; /&gt;&lt;/p&gt;&lt;p&gt;你可以使用Java中的synchronized结构体来避免这种情况。一个synchronized代码块保证在同一时间只有一个线程可以进入关键区域执行代码。Synchronized代码块也会保证所有包含在代码块中的变量，直接从内存中读取，在线程步出代码块时，所有更新过的变量会被回写至主内存中，无论这些变量是否用volatile声明过。&lt;/p&gt;&lt;hr /&gt;&lt;p&gt;本篇文章翻译自：&lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/java-memory-model.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://tutorials.jenkov.com/java-concurrency/java-memory-model.html&lt;/a&gt;&lt;/p&gt;&lt;p&gt;后记：前段时间看《Java并发编程的艺术》这本书，发现书中对&lt;code class=&quot;highlighter-rouge&quot;&gt;volatile&lt;/code&gt;关键字的介绍有些深入不浅出。后来在网上找相关资料时发现了这个并发编程系列的博客，一读之后豁然开朗，于是便有了翻译过来与各位共享的想法。后续还会继续翻译一些该系列中的博客。&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;
    
        &lt;/div&gt;</content><author><name></name></author><summary type="html">前言：Java内存模型详细说明了Java虚拟机(以下将使用JVM这个术语)是如何与计算机的内存(RAM)进行交互的。JVM是一个完整计算机的模型，所以该模型也包含了内存模块，也就是我们熟知的Java内存模型。想要设计出符合预期的并发程序，了解Java的内存模型是非常重要的。Java内存模型详细描述了不同的线程如何以及何时可以看见被其他线程写入的共享变量，以及在需要时如何同步使用共享变量。Java内存模型在一开始是不够完善的，不过它在Java 1.5中被改进了。Java8依然在使用这一改进版本的内存模型。一、一窥Java内存模型的内部JVM中的Java内存模型将内存分为线程栈(thread stacks)和堆(heap)。下图从逻辑角度演示了Java的内存模型：在JVM中运行的每个线程都有自己的线程栈。线程栈包含的信息为：当前方法执行到的点。我将称这个栈为“调用栈”，当线程执行代码时，调用栈也会随之变化。线程栈还包含了每个被执行的方法（所有位于调用栈的方法）内部的所有局部变量(local variables)。一个线程只能访问自己的线程栈。由一个线程创建的内部变量，对其他线程是不可见的。即便两个线程在执行一模一样的代码，他们仍然会在自己的线程栈中创建各自的局部变量。也就是说，每个线程都有自己的局部变量的版本。所有原始类型( boolean, byte, short, char, int, long, float, double)的局部变量全部都存储在线程栈中，所以它们对其他线程是不可见的。一个线程可以向其他线程传递原始类型变量的拷贝，但无法共享内部的原始类型变量。堆则包含了所有Java对象(objects)，无论它们是由哪个线程创建的，这些对象包括对原始类型封装而成的包装类(Integer、Long等)。无论对象是在局部被创建并赋值给局部变量，还是作为其他对象的成员被创建的。这些对象始终都位于堆中。下图展示了线程栈中存储的调用栈和局部变量，以及堆中存储的对象：一个局部变量如果是原始类型的，则它会存储在线程栈中。一个局部变量如果是对一个对象的引用，则这个变量的引用会存储在线程栈中，但引用的对象则会存储在堆中。一个对象的方法以及方法内的局部变量，也是存储在线程栈中，即便这个对象本身存储在堆中。一个对象的成员变量(Field)和对象一样存储在堆中，无论这个成员变量是原始类型还是对对象的引用。此外，静态类变量也是存储在堆中。处于堆中的对象，可以被任何拥有其引用的线程访问到。当一个线程访问一个对象时，它也可以访问到对象的成员变量(Field)和方法。如果两个线程在同一时间访问同一个对象的方法，他们可以同时调用该对象的该方法，不过每个线程都会拥有一份方法内的局部变量的拷贝。下图演示了上面提到的那些点：两个线程有一组局部变量。其中一个局部变量Local Variable 2指向了位于堆中的对象Object 3。这两个线程的局部变量和引用是不一样的，它们存储在各自的线程栈中，虽然二者指向的同一个对象存储在堆中。注意对象Object 3的成员变量，分别引用了对象Object 2和对象Object 4（注意图中Object 3指向Object 2和Object 4的箭头），藉由对象Object 3中的成员变量，两个线程也可以访问到对象Object 2和Object 4。图中也展示了：线程栈中的methodTwo()中的局部变量Local Variable 1指向位于堆中的两个不同对象的情况。此时这个引用指向了两个不同的对象（Object 1和Object 5），而不是同一对象。理论上每个线程都可以访问到这两个对象Object 1和Object 5，前提是每个线程都有指向这两个对象的引用。不过在上图中，每个线程只有一个指向两个对象之一的引用。那么，用什么样的Java代码可以反推出上面的内存图呢？其实，图例对应的Java代码也很简单：</summary></entry><entry><title type="html">Memcached核心技术初探</title><link href="http://localhost:4000/2018/06/29/Memcached%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2.html" rel="alternate" type="text/html" title="Memcached核心技术初探" /><published>2018-06-29T00:00:00+08:00</published><updated>2018-06-29T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/29/Memcached%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2</id><content type="html" xml:base="http://localhost:4000/2018/06/29/Memcached%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2.html">&lt;h1 id=&quot;1-memcached概述&quot;&gt;1 Memcached概述&lt;/h1&gt;
&lt;h2 id=&quot;11-memcached是什么&quot;&gt;1.1 Memcached是什么&lt;/h2&gt;
&lt;p&gt;Memcached是一个高性能、分布式的内存缓存系统，它通过在内存中缓存数据和对象来减少数据库的读取次数，从而提升动态数据库驱动型网站的访问体验。&lt;/p&gt;

&lt;p&gt;Memcached本质上是一个基于String类型的键/值对的缓存系统。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1.png?raw=true&quot; alt=&quot;---1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-memcached的特性&quot;&gt;1.2 Memcached的特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;支持文本和二进制两种通信协议&lt;/em&gt;&lt;/strong&gt;
文本协议(&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII Protocol&lt;/code&gt;)是Memcached一开始使用的协议，它简单可靠，我们可以通过telnet工具试用一下该协议：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.

# 客户端set命令
set testkey 0 60 5
hello

# 服务端响应内容
STORED

# 客户端get命令
get testkey

# 服务端响应内容
VALUE testkey 0 5
hello
END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了提升客户端命令解析的速度，提高数据内容的可扩展性，Memcached在v1.3之后引入了Binary协议(&lt;code class=&quot;highlighter-rouge&quot;&gt;Binary Protocol&lt;/code&gt;)。对这种协议感兴趣的可自行了解一下，此处不再细说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;基于Libevent处理请求&lt;/em&gt;&lt;/strong&gt;
Libevent是一个提供异步事件回调的C程序。它支持&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/poll&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;kqueue(2)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;POSIX select(2)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Windows IOCP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;poll(2)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;epoll(4)&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;Solaris event ports&lt;/code&gt;等各系统的调用，并对外提供了一套统一的API，使其在Server端跨平台的高并发应用场景中拥有独特优势。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用内存作为唯一存储介质&lt;/em&gt;&lt;/strong&gt;
是的，Memcached是一个只关注于缓存的系统，它不支持缓存的持久化，一切数据都只在RAM中存储。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Key与Value长度有上限&lt;/em&gt;&lt;/strong&gt;
Key长度不能超过250个字节，Value长度则不能超过1MB.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;存储超限时使用LRU策略淘汰数据&lt;/em&gt;&lt;/strong&gt;
LRU(Least recently used)淘汰算法是实现简单、应用最为广泛的淘汰算法之一，后面我们会详细讨论它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;实现逻辑：一半在服务端，一半在客户端&lt;/em&gt;&lt;/strong&gt;
比如Memcached分布式的实现，就是依靠客户端对Key的Hash散列实现的
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-1.png?raw=true&quot; alt=&quot;---1-1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-memcached的内存模型&quot;&gt;2 Memcached的内存模型&lt;/h1&gt;
&lt;p&gt;下图是Memcached内存中的数据结构概览。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-8.png?raw=true&quot; alt=&quot;---1-8&quot; /&gt;
其中slab-class用来管理slab, 每个slab都是固定大小1MB的，但slab中真正用于存储数据(item)的chunk，它的尺寸在同一slab中是相等的。图中的item-hash-table用于存储key-item的映射关系。&lt;/p&gt;

&lt;p&gt;那么slab到底是什么呢？Memcached在数据存储时为减少申请、释放内存产生的系统调用的次数（以提高效率）和释放内存产生的碎片， 每次向系统申请内存时会直接申请一个slab page size(1M)大小的内存空间，并将其分配给特定slab。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-2.png?raw=true&quot; alt=&quot;---1-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该slab则会将内存空间切分为size相同的块(chunk)
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-3.png?raw=true&quot; alt=&quot;---1-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个缓存的item，最终会落到和自己长度最接近的slab chunk中(item size &amp;lt;= trunk size)
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-7.png?raw=true&quot; alt=&quot;---1-7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个slab大小都为1MB，为支持各种长度的item存储，多个slab在初始化其内部chunk时会按照增长因子(&lt;code class=&quot;highlighter-rouge&quot;&gt;factor&lt;/code&gt;，可配置)依次递增，从而达到存储各种尺寸item的目的。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-6.png?raw=true&quot; alt=&quot;---1-6&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-memcached的数据结构&quot;&gt;3 Memcached的数据结构&lt;/h1&gt;
&lt;p&gt;Memcached内部数据结构的核心是：LRU策略的缓存实现。这通常是由HashMap + LRU队列共同完成的。二者的关联关系如下图所示：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-9.png?raw=true&quot; alt=&quot;---1-9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于在执行每一次的set/get等命令时需要变更HashMap和LRU队列的顺序，在高并发场景下为保护数据的一致性，就必须对这两个数据结构进行加锁操作。当然了，加锁必然会带来并发性能的急剧下降。&lt;/p&gt;

&lt;p&gt;我们来看一下一次客户端请求Memcached的完整工作流：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-11.png?raw=true&quot; alt=&quot;---1-11&quot; /&gt;
从上图可以看出对HashMap和LRU队列进行的操作加了全局锁，在高并发场景下，这种全局锁肯定是不可接受的，我们将试着提出一些优化的思路。不过在这之前，我们先简单了解一下这两种数据结构。&lt;/p&gt;

&lt;p&gt;HashMap的结构图如下所示：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-10.png?raw=true&quot; alt=&quot;---1-10&quot; /&gt;
我们知道根据一致性哈希算法，给定一个key，它一定会落到HashMap(Table)中的某个Bucket中，多个落到同一Bucket中的key会被放入单向链表中去。&lt;/p&gt;

&lt;p&gt;已知这个数据结构后我们会发现，给定单个key-item后，只需要完成对特定Bucket的锁定即可，无需锁定全局HashMap，这种锁便是分区锁。事实上Java语言中的ConcurrentHashMap就是通过这种锁实现的高并发操作。加锁的结构示意图如下：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-12.png?raw=true&quot; alt=&quot;---1-12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们再了解一下LRU队列。LRU是一种淘汰机制，当给定空间不足时以最近最少使用为指标淘汰数据。其在操作系统内存管理、Innodb缓存管理中都有应用。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-13.png?raw=true&quot; alt=&quot;---1-13&quot; /&gt;
LRU的实现通常都是一个双向的链表，在不加锁的情况下对链表进行高并发操作容易造成各种问题（比如空指针），如下图所示。但加上全局锁则会对性能造成影响。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-14.png?raw=true&quot; alt=&quot;---1-14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对LRU的高并发操作的优化是一个持续的话题，本篇不再细讲，感兴趣的同学可以自行了解下。&lt;/p&gt;

&lt;p&gt;通过对HashMap和LRU这两种核心数据结构进行分区锁/无锁的优化后，一次请求的流程图将变为下图所示的样子：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-19.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-memcached的网络模型&quot;&gt;4 Memcached的网络模型&lt;/h1&gt;
&lt;p&gt;为了支持高并发连接和跨平台部署，Memcached使用了Libevent来进行网络连接管理。&lt;/p&gt;

&lt;p&gt;Libevent是一个提供异步事件回调的C程序。它支持 /dev/poll, kqueue(2), POSIX select(2), Windows IOCP, poll(2), epoll(4) 以及 Solaris event ports等各系统的调用，并对外提供了一套统一的API，使其在跨平台的高并发应用场景拥有独特优势。&lt;/p&gt;

&lt;p&gt;说到select/poll，以及epoll/kqueue，就不得不说下他们的历史。从上世纪80年代开始，由于只有select和poll同步阻塞式的系统调用，Server端对客户端高并发网络连接的支持只能通过创建更多线程(池)或更强劲的机器性能实现。select和poll本质上相差不多，他们的时间复杂度都是O(n).
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-15.png?raw=true&quot; alt=&quot;---1-15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过当Unix系统引入了epoll和kqueue等系统调用后，Server端对高并发网络连接的支持困境得到了极大优化。二者的时间复杂度都是O(1)!
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-16.png?raw=true&quot; alt=&quot;---1-16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Libevent正是上面所述的系统调用的集大成者，它封装个底层操作系统的系统调用函数并对开发者提供了统一的API，也难怪它被广泛地应用在跨平台的高并发场景。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-17.png?raw=true&quot; alt=&quot;---1-17&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;5-memcached-vs-redis&quot;&gt;5 Memcached vs Redis&lt;/h1&gt;
&lt;p&gt;谈到Memcached的对比，就不得不拿老对手Redis来进行一番比较。以下是二者的对比
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-18.png?raw=true&quot; alt=&quot;---1-18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从对比中可以看出，Redis在不断迭代中已经成长为一个更全能的存储DB，缓存服务只是它功能的一部分(虽然仍是主要部分)；Memcached则始终关注String缓存这一功能，并且借由开源工具弥补了自己在集群、备份、主从等方面的短板。&lt;/p&gt;

&lt;p&gt;二者并没有完全的孰优孰劣的情况，在实战中应根据实际场景具体问题具体分析，毕竟最合适的才是最好的。&lt;/p&gt;</content><author><name></name></author><category term="Tech" /><summary type="html">1 Memcached概述 1.1 Memcached是什么 Memcached是一个高性能、分布式的内存缓存系统，它通过在内存中缓存数据和对象来减少数据库的读取次数，从而提升动态数据库驱动型网站的访问体验。</summary></entry><entry><title type="html">Bughole(虫洞)工具:预发断点调试PHP利器</title><link href="http://localhost:4000/2018/04/25/Bughole(%E8%99%AB%E6%B4%9E)%E5%B7%A5%E5%85%B7-%E9%A2%84%E5%8F%91%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95PHP%E5%88%A9%E5%99%A8.html" rel="alternate" type="text/html" title="Bughole(虫洞)工具:预发断点调试PHP利器" /><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/25/Bughole(%E8%99%AB%E6%B4%9E)%E5%B7%A5%E5%85%B7:%E9%A2%84%E5%8F%91%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95PHP%E5%88%A9%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/2018/04/25/Bughole(%E8%99%AB%E6%B4%9E)%E5%B7%A5%E5%85%B7-%E9%A2%84%E5%8F%91%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95PHP%E5%88%A9%E5%99%A8.html">&lt;div class=&quot;wiki-content&quot;&gt;
                           &lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-true&quot;&gt;&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-效果图&quot;&gt;效果图&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-试用&quot;&gt;试用&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-debug获取评价列表API- BeibeiItemRateGet&quot;&gt;debug: 获取评价列表API -&amp;nbsp;BeibeiItemRateGet&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-debugProductTestTask任务product-module &quot;&gt;debug: ProductTestTask任务(product-module)&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-实战&quot;&gt;实战&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-实战1：debug任意URL&quot;&gt;实战1：debug任意URL&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-实战2：debugPHP任务（同上方debugProductTestTask）&quot;&gt;实战2：debug PHP任务（同上方debug ProductTestTask）&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.3&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-遇到问题要反馈？&quot;&gt;遇到问题要反馈？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;4&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-预发布如何部署&quot;&gt;预发布如何部署&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;5&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-Bughole原理&quot;&gt;Bughole原理&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;5.1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-工程结构图&quot;&gt;工程结构图&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;5.2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-时序图&quot;&gt;时序图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;6&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-安全考虑&quot;&gt;安全考虑&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;7&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-项目源码&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/h2&gt;&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-效果图&quot;&gt;效果图&lt;/h2&gt;&lt;p&gt;Bughole工具实现了PHPStorm中&lt;span&gt;95%以上&lt;/span&gt;的debug功能。借助该工具在预发布调试：PHP的业务代码、API甚至任务脚本，都将变得极为方便！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;900&quot; src=&quot;http://wx1.sinaimg.cn/large/6480dca9ly9fr2nh08b2kj218g0s6tog.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-试用&quot;&gt;试用&lt;/h2&gt;&lt;p&gt;Bughole整套工具在预发9已经部署完备，以下步骤将分别演示：1）debug获取评价列表的API；2）debug PHP
任务&lt;/p&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-debug获取评价列表API-&amp;nbsp;BeibeiItemRateGet&quot;&gt;debug: 获取评价列表API -&amp;nbsp;BeibeiItemRateGet&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;打开bughole UI：&lt;a href=&quot;&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;#(暂不对外开放)&lt;/a&gt;&amp;nbsp;，&lt;strong&gt;并且确认自己已经连上了预发9&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;添加断点。在断点模块，点击“Add”按钮，新增断点信息(可通过类似方式不断增加断点)&lt;/li&gt;&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;文件路径：***/***/api/ItemRateGet.php&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;断点行号：26&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;填好断点信息，点击确定&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;点击“建立连接”按钮。则服务端agent开始监听Xdebug的拦截信息&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;在新标签页访问：&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://sapi.beibei.com/item/rate/0-27221145-1-10-1.html?preview=1&amp;amp;XDEBUG_SESSION_START=1&quot; style=&quot;font-size: 10.0pt;&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://sapi.beibei.com/item/rate/0-27221145-1-10-1.html?preview=1&amp;amp;XDEBUG_SESSION_START=1&lt;/a&gt;&amp;nbsp;。这个访问也必须是预发9的！此时Xdebug会尝试拦截这个访问，具体表现为：页面hanging转圈不返回&lt;/li&gt;&lt;li&gt;回到bughole UI，点击页面顶端的“点我测试”按钮。如果一切正常，你将看到如下图所示信息，这表明Xdebug已经正确开始了&lt;/li&gt;&lt;li&gt;试试StepOver命令，StepInto命令，StepOut命令？当然你也可以使用RunToLine命令。&lt;br /&gt;想查看当前Context的变量信息，就在右侧的Context面板查找吧。右下方还有调用栈信息&lt;br /&gt;最后，&lt;strong&gt;一定要记得点击“Stop”按钮停止debug&lt;/strong&gt;&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;500&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9ly9fr2osazim8j20z00oogyl.jpg&quot; /&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-debugProductTestTask任务product-module&amp;nbsp;&quot;&gt;debug: ProductTestTask任务(product-module)&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;打开bughole UI：&lt;a href=&quot;#&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;#（暂不对外开放）&lt;/a&gt;&amp;nbsp;，&lt;strong&gt;并且确认自己已经连上了预发9&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;添加断点。在断点模块，点击“Add”按钮，新增断点信息(可通过类似方式不断增加断点)&lt;/li&gt;&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;文件路径：***/***/src/task/ProductTestTask.php&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;断点行号：17&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;填好断点信息，点击确定&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;点击“建立连接”按钮。则服务端agent开始监听Xdebug的拦截信息&lt;/li&gt;&lt;li&gt;&lt;p&gt;在预发9机器上依次执行：&lt;/p&gt;
    &lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_722052&quot; class=&quot;syntaxhighlighter nogutter  bash&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# 切换到root用户&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;bash functions&quot;&gt;sudo&lt;/code&gt; &lt;code class=&quot;bash functions&quot;&gt;su&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# 为root用户设置环境变量(设置后Xdebug会主动拦截PHP脚本的运行)&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;bash functions&quot;&gt;export&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;XDEBUG_CONFIG=&lt;/code&gt;&lt;code class=&quot;bash string&quot;&gt;&quot;idekey=bughole&quot;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# 执行任务（切记不要加sudo）&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;bash functions&quot;&gt;bash&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;/task/task_admin&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.sh start --module=product ProductTestTask&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;回到bughole UI，点击页面顶端的“点我测试”按钮。如果一切正常，你将看到如上图所示信息，这表明Xdebug已经正确开始了&lt;/li&gt;&lt;li&gt;&lt;span&gt;试试StepOver命令，StepInto命令，StepOut命令？当然你也可以使用RunToLine命令。&lt;/span&gt;&lt;br /&gt;&lt;span&gt;想查看当前Context的变量信息，就在右侧的Context面板查找吧。右下方还有调用栈信息&lt;/span&gt;&lt;br /&gt;&lt;span&gt;最后，&lt;/span&gt;&lt;strong&gt;一定要记得点击“Stop”按钮停止debug&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;说明：debug模式同一时间只允许一个人进行debug，如果有其他人也在debug，则可能出现错乱情况。&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;解决办法：1）避免同时使用debug；2）如果debug已经不正常，尝试重启：kill这个任务（python bughole/agent.py);重新运行:&amp;nbsp;python /tmp/tiny-scripts/bughole/agent.py (无需sudo)&lt;/span&gt;&lt;/p&gt;&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-实战&quot;&gt;实战&lt;/h2&gt;&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-实战1：debug任意URL&quot;&gt;实战1：debug任意URL&lt;/h3&gt;&lt;p&gt;详细步骤，请参考：debug获取评价列表API。&lt;/p&gt;&lt;p&gt;上方步骤4中触发Xdebug启动拦截的关键在于：URL后面要增加一个query（GET、POST皆可）:&amp;nbsp;&lt;u&gt;XDEBUG_SESSION_START=1&lt;/u&gt; 即可触发调试模式&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;当然，很多API接口会&lt;u&gt;对请求参数中的sign做安全校验&lt;/u&gt;，意即URL的GET参数不能随意增删，否则会报错：sign校验失败。遇到这种情况，可以通过在&lt;u&gt;Cookie中添加参数触发Xdebug启动&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;情况1：&lt;/strong&gt;如果你在Chrome浏览器中，可以通过Cookie管理工具为当前API域名添加Cookie:&amp;nbsp;XDEBUG_SESSION = 1, HX-BETA = 9；或者直接在网页console中输入: document.cookie = 'HX-BETA=9; XDEBUG_SESSION=1;'&amp;nbsp; &amp;nbsp;然后接着上述步骤4的指示继续即可&lt;/p&gt;&lt;p&gt;&lt;strong&gt;情况2：&lt;/strong&gt;如果你在Charlse中，可以通过Rewrite工具为API添加Cookie，然后接着上述步骤4的指示继续即可&lt;/p&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-实战2：debugPHP任务（同上方debugProductTestTask）&quot;&gt;实战2：debug PHP任务（同上方debug ProductTestTask）&lt;/h3&gt;&lt;p&gt;步骤参考debug ProductTestTask任务。&lt;span&gt;触发Xdebug启动拦截的关键在于：当前用户的环境变量中设置了:&amp;nbsp;&lt;u&gt;XDEBUG_CONFIG=idekey=bughole&lt;/u&gt;&amp;nbsp;这个变量（使用env命令可以查看当前用户空间的变量）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由于通过sudo export命令设置环境变量会失败，所以需要切换到root用户运行任务脚本。&lt;/p&gt;&lt;p&gt;注意：&lt;span&gt;多进程的任务(worker_num &amp;gt;= 2)在debug时会出现异常，解决办法：debug时将worker_num设为1，debug完成后再改回原值。&lt;/span&gt;&lt;/p&gt;&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-遇到问题要反馈？&quot;&gt;遇到问题要反馈？&lt;/h3&gt;&lt;p&gt;遇到使用问题，烦请联系我qq: 379396993, 我会尽快帮忙查看问题&lt;/p&gt;&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-预发布如何部署&quot;&gt;预发布如何部署&lt;/h2&gt;&lt;p&gt;1）拉取agent代码。注意将 GitLab用户名 替换为自己的用户名&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_530619&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;cd /tmp&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;git clone http:&lt;/code&gt;&lt;code class=&quot;java comments&quot;&gt;//GitLab用户名@git.example.com/dongxu.lu/tiny-scripts.git&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;2）安装Xdebug（如果已安装请跳过本步）&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_392489&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# 查看是否安装Xdebug，如果已安装请跳过本步&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;/opt/php-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7.1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/bin/php -m |grep Xdebug&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# copy编译好的扩展至PHP指定目录&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;cp /tmp/tiny-scripts/bughole/xdebug.so /opt/php-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7.1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/lib/php/extensions/no-debug-non-zts-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;20160303&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# 新建文件: /opt/php-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7.1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/etc/conf.d/xdebug.ini , 内容如下&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;zend_extension = xdebug.so&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_enable = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_connect_back = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_host = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;127.0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.1&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_port = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;21733&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_handler = dbgp&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_mode = req&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_autostart = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.idekey = &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;bughole&quot;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# 重启PHP-FPM&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;service php-fpm-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;restart&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;3）agent持久运行&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_666068&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;python /tmp/tiny-scripts/bughole/agent.py &amp;gt; /tmp/bughole-agent.log &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;gt;&amp;amp;&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p class=&quot;p1&quot;&gt;4）部署已完成。确认agent已运行&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_831199&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# agent会返回OK&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;curl http:&lt;/code&gt;&lt;code class=&quot;java comments&quot;&gt;//127.0.0.1:21734&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-Bughole原理&quot;&gt;Bughole原理&lt;/h2&gt;&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-工程结构图&quot;&gt;工程结构图&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;900&quot; src=&quot;http://wx4.sinaimg.cn/large/6480dca9gy1fr2oyic41bj211m0mqq5k.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-时序图&quot;&gt;时序图&lt;/h3&gt;&lt;p&gt;以最常用的StepOver(下一行)命令的执行时序作为示例&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;900&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fr2ozus21pj21bu0tc783.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-安全考虑&quot;&gt;安全考虑&lt;/h2&gt;&lt;p&gt;Bughole未提供&lt;strong&gt;eval接口&lt;/strong&gt;，所有操作都为“读”操作，不会对线上业务数据造成污染&lt;/p&gt;&lt;p&gt;待本周发布上线试用几天后会及时更新使用和部署(Agent)文档&lt;/p&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-项目源码&quot;&gt;项目源码&lt;/h2&gt;
https://github.com/HelloLyfing/bughole
&lt;/div&gt;</content><author><name></name></author><summary type="html">1 效果图 2 试用 2.1 debug: 获取评价列表API -&amp;nbsp;BeibeiItemRateGet 2.2 debug: ProductTestTask任务(product-module)&amp;nbsp; 3 实战 3.1 实战1：debug任意URL 3.2 实战2：debug PHP任务（同上方debug ProductTestTask） 3.3 遇到问题要反馈？ 4 预发布如何部署 5 Bughole原理 5.1 工程结构图 5.2 时序图 6 安全考虑 7 项目源码 效果图Bughole工具实现了PHPStorm中95%以上的debug功能。借助该工具在预发布调试：PHP的业务代码、API甚至任务脚本，都将变得极为方便！</summary></entry><entry><title type="html">PHP任务的多进程处理</title><link href="http://localhost:4000/2018/03/20/PHP%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86.html" rel="alternate" type="text/html" title="PHP任务的多进程处理" /><published>2018-03-20T00:00:00+08:00</published><updated>2018-03-20T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/20/PHP%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86</id><content type="html" xml:base="http://localhost:4000/2018/03/20/PHP%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86.html">&lt;div class=&quot;wiki-content&quot;&gt;
                           &lt;p&gt;&lt;/p&gt;&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;1&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-概述&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-PHP的多进程管理（PCNTL扩展）&quot;&gt;PHP的多进程管理（PCNTL扩展）&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.1&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-示例1：简易demo&quot;&gt;示例1：简易demo&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.2&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-示例2：实际应用场景初探&quot;&gt;示例2：实际应用场景初探&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-PCNTL扩展进阶使用&quot;&gt;PCNTL扩展进阶使用&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.1&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-子进程的管理（监控终止子进程）&quot;&gt;子进程的管理（监控/终止子进程）&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.2&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-父子进程的信号处理&quot;&gt;父/子进程的信号处理&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.3&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-任务（进程）的后台执行&quot;&gt;任务（进程）的后台执行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;4&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-附录：通用PHP任务框架流程图&quot;&gt;附录：通用PHP任务框架流程图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 id=&quot;PHP任务的多进程处理-概述&quot;&gt;概述&lt;/h2&gt;&lt;p&gt;很多以PHP为编程语言的Web项目，在需要做异步业务、数据的处理时，仍然会选择使用PHP语言来编写任务脚本。&lt;span&gt;这么做的优点不言而喻，通用的底层model、业务service、熟悉的公共类及方法，让熟悉Web业务开发的工程师可以花最快的时间以及最小的学习成本快速编写出特定场景的业务脚本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而PHP是为Web网页制作而生的单进程处理语言，当他遇到大数据场景下的业务数据的处理需求时，如果仍然依靠单进程的方式进行，不仅耗费更多时间、浪费服务器资源，而且可能很快就会遇到性能瓶颈。在这样一种场景需求下，PHP语言的多进行/线程处理能力就显得尤为需要了。&lt;br /&gt;&lt;br /&gt;PHP对多进程处理的支持虽然已经到来了(&lt;a href=&quot;https://github.com/krakjoe/pthreads&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/krakjoe/pthreads&lt;/a&gt;&amp;nbsp;)，然而它却只能在PHP7.2+以上的版本中运行，而且需要&lt;span style=&quot;color: rgb(34,34,34);&quot;&gt;Thread Safety特性的支持。在这样一种现状下，使PHP支持多进程处理似乎是唯一（但不是最坏）的选择了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 id=&quot;PHP任务的多进程处理-PHP的多进程管理（PCNTL扩展）&quot;&gt;PHP的多进程管理（PCNTL扩展）&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/intro.pcntl.php&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;PCNTL扩展&lt;/a&gt;&amp;nbsp;实现了类Unix系统中的进程创建、执行、信号处理以及最终的进程终止，更具体的实现方式可以参考类Unix系统提供的&lt;a href=&quot;http://man7.org/linux/man-pages/man2/fork.2.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;fork(2)&lt;/a&gt;、waitpid(2)和signal(2)函数接口。&lt;/p&gt;&lt;p&gt;贝贝PHP的开发环境默认配置了PCNTL扩展，如果你的环境需要安装或配置该扩展，还请自行查找方法，此处略过。&lt;/p&gt;&lt;p&gt;对PCNTL扩展有了初步的认识后，我们先来编写一个多进程的demo任务练练手，熟悉一下该扩展中核心函数pcntl_fork的使用场景及方法&lt;/p&gt;&lt;h4 id=&quot;PHP任务的多进程处理-示例1：简易demo&quot;&gt;示例1：简易demo&lt;/h4&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_269057&quot; class=&quot;syntaxhighlighter nogutter  php&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;&amp;lt;?php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;I'm in the Main process!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;php comments&quot;&gt;// 当前进程：主进程&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= pcntl_fork();&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;php comments&quot;&gt;// pcntl_fork()被执行后，系统会立即创建子进程，而且子进程的执行入口为紧跟在pcntl_fork()之后的代码，与主进程即将执行的代码一致&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Who am I ?\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;php comments&quot;&gt;// 此时需要一种机制或约定来让编程人员判断当前代码执行的环境为主进程中or子进程中&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== -1) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Fork child process faield, exit!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(1);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;I'm in the child process!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Child process exit.\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(0);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;&amp;gt; 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;I'm still in the main process!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Main process exit.\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(0);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;上面那段代码的输出会是什么样子呢？&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;运行结果&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_525915&quot; class=&quot;syntaxhighlighter collapsed nogutter  bash&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_expandSource expandSource&quot;&gt;expand source&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;[root@1d42e4522359 tmp]&lt;/code&gt;&lt;code class=&quot;bash comments&quot;&gt;# php test.php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;I'm &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;the Main process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Who am I ?&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;I'm still &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;the main process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Main process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Who am I ?&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;I'm &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;the child process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Child process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;从上面的示例代码中可以看出：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不同于多线程中只会被新线程执行的特定代码块，多进程代码在被执行时，父进程与子进程几乎共用同一份代码，即&lt;span&gt;pcntl_fork()之后的代码&lt;/span&gt;&lt;/li&gt;&lt;li&gt;由于子进程被创建之后，父进程与子进程就相当于两个独立的进程，二者共用pcntl_fork()之后的代码，而且执行顺序没有保证，所以需要通过pcntl_fork()函数的返回值来判断当前进程所属父/子进程，以便通过if-else判断为父/子进程预设置不同的执行代码。pcntl_fork()函数的返回值$pid有三种情况：&lt;br /&gt;&lt;ul&gt;&lt;li&gt;$pid = -1: 子进程创建失败，通常情况下子进程创建失败，程序都会记录原因后主动退出&lt;/li&gt;&lt;li&gt;$pid &amp;gt; 0: 子进程创建成功。当前进程为父进程，其中$pid的值即为刚创建成功的子进程的进程id&lt;/li&gt;&lt;li&gt;$pid = 0: 子进程创建成功。当前进程为子进程&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;PHP任务的多进程处理-示例2：实际应用场景初探&quot;&gt;示例2：实际应用场景初探&lt;/h4&gt;&lt;p&gt;下面我们来编写一例有实际应用场景的例子：父&lt;span&gt;进程创建2个子进程，每个子进程的工作内容相同：从主进程分配给自己的网址中抓取网页的标题字段并打印出来，然后退出程序。父进程在sleep几秒（其实是在等待子程序执行完并主动退出）后也退出程序。&lt;/span&gt;&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_440581&quot; class=&quot;syntaxhighlighter  php&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line number22 index21 alt1&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line number23 index22 alt2&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line number24 index23 alt1&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line number25 index24 alt2&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line number26 index25 alt1&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line number27 index26 alt2&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line number28 index27 alt1&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line number29 index28 alt2&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line number30 index29 alt1&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line number31 index30 alt2&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line number32 index31 alt1&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line number33 index32 alt2&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line number34 index33 alt1&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line number35 index34 alt2&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line number36 index35 alt1&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line number37 index36 alt2&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line number38 index37 alt1&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line number39 index38 alt2&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line number40 index39 alt1&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line number41 index40 alt2&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line number42 index41 alt1&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line number43 index42 alt2&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line number44 index43 alt1&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line number45 index44 alt2&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line number46 index45 alt1&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line number47 index46 alt2&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line number48 index47 alt1&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line number49 index48 alt2&quot;&gt;49&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;&amp;lt;?php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$msg&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php variable&quot;&gt;$msg&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;. &lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;get_url_title(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$content&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= &lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;file_get_contents&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= NULL;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$content&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;preg_match(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'/&amp;lt;title&amp;gt;(.+?)&amp;lt;\/title&amp;gt;/'&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$content&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;&amp;amp;&amp;amp; &lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;count&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) === 2) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;[1];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;NULL;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'Task begin.'&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number22 index21 alt1&quot;&gt;&lt;code class=&quot;php variable&quot;&gt;$site_urls&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;array&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number23 index22 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'&lt;a href=&quot;https://www.beibei.com'&quot;&gt;https://www.beibei.com'&lt;/a&gt;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;,&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number24 index23 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'&lt;a href=&quot;https://www.jd.com'&quot;&gt;https://www.jd.com'&lt;/a&gt;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;,&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number25 index24 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number26 index25 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number27 index26 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number28 index27 alt1&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;foreach&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$site_urls&lt;/code&gt; &lt;code class=&quot;php keyword&quot;&gt;as&lt;/code&gt; &lt;code class=&quot;php variable&quot;&gt;$_url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number29 index28 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number30 index29 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= pcntl_fork();&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number31 index30 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number32 index31 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== -1) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number33 index32 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;Fork child process faield, exit!&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number34 index33 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(1);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number35 index34 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number36 index35 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;In the child process!&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number37 index36 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$_url&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;. &lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;' title =&amp;gt; '&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;. get_url_title(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$_url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;));&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number38 index37 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;Child process exit.&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number39 index38 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(0);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number40 index39 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;&amp;gt; 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number41 index40 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;In the parent process, do nothing.&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number42 index41 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number43 index42 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number44 index43 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number45 index44 alt2&quot;&gt;&lt;code class=&quot;php variable&quot;&gt;$i&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= 7;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number46 index45 alt1&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;while&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$i&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;--) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number47 index46 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;sleep(1);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number48 index47 alt1&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number49 index48 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;Task end.&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;运行结果&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_609586&quot; class=&quot;syntaxhighlighter collapsed nogutter  bash&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_expandSource expandSource&quot;&gt;expand source&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;[root@1d42e4522359 beibei]&lt;/code&gt;&lt;code class=&quot;bash comments&quot;&gt;# php testpcntl.php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Task begin.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the parent process, &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;do&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;nothing.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the child process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the parent process, &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;do&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;nothing.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the child process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;https:&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;//www&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.beibei.com title =&amp;gt; 贝贝网-买母婴上贝贝！1亿妈妈信赖的母婴正品特卖商城&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Child process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;https:&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;//www&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.jd.com title =&amp;gt; 京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Child process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Task end.&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;从上面的执行结果中我们又可以总结出PCNTL扩展函数的几个特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;1）子进程可以使用（继承了）父进程Context中的变量（如$_url）以及函数（如get_url_title()方法）&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2）如果移除父进程最后的sleep代码你会发现，子进程在父进程退出后依然可以正常运行，并不会随主进程的退出而退出&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;PHP任务的多进程处理-PCNTL扩展进阶使用&quot;&gt;PCNTL扩展进阶使用&lt;/h2&gt;&lt;h4 id=&quot;PHP任务的多进程处理-子进程的管理（监控终止子进程）&quot;&gt;子进程的管理（监控/终止子进程）&lt;/h4&gt;&lt;p&gt;在实际的任务框架编写中，开发者通常会首先创建一个master进程，然后再由master进程创建N个子进程。其中每个子进程作为工作进程（worker process）进行实际的业务处理，master进程作为管理者，主要负责工作进程的调度、监管、维护、回收等内容。&lt;span&gt;到了某个具体业务处理的场景下，对应业务的开发者仅需要完成自己业务逻辑部分，并将其作为工作进程的一部分，即可快速嵌入到整体的任务框架中去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在这种任务框架模式下，master进程对子进程的监控及控制能力就显得尤为重要了。那么如何借用PCNTL扩展的函数接口对子进程进行监管与控制呢？&lt;/p&gt;&lt;p&gt;对子进程的监控，主要分两个方面：1）需要记录每个子进程的进程ID；2）可以通过子进程的进程ID获取子进程的运行状态（是否已结束、是否为僵尸进程）&lt;/p&gt;&lt;p&gt;对子进程的控制，主要是指：可以通过子进程的进程ID获取其运行状态，并可以停止或中断其运行。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;获取子进程运行状态，需要用到函数&lt;strong&gt;pcntl_waitpid&lt;/strong&gt;(int $pid, int &amp;amp;$status, int $options = 0)。本函数依赖于Linux系统的waitpid(2)函数的实现，作用为：阻断当前进程直到给定$pid的子进程退出（当遇到系统信号需要终止运行或调用信号处理函数时会转去进行信号处理）。注意该函数默认是阻塞型函数（除非$options设置为&lt;em&gt;WNOHANG&lt;/em&gt;），其会根据入参的不同，做出多种可能的处理和返回（不过由于当前进程通常都为管理子进程的父进程，并非worker进程，所以即便阻塞也没关系）。参数解释：&lt;/span&gt;&lt;ul&gt;&lt;li&gt;$pid：根据$pid值的范围进行不同的处理：&lt;br /&gt;&lt;ul&gt;&lt;li&gt;$pid &amp;lt; -1: 等待指定进程组ID下所有子进程的退出。其中进程组ID = abs($pid)，即$pid的绝对值&lt;/li&gt;&lt;li&gt;$pid = -1: 等待任意子进程（这里不太清楚，任意是指：用户空间的所有fork出的子进程？）的退出&lt;/li&gt;&lt;li&gt;$pid =&amp;nbsp; 0: 等待指定进程组ID下所有子进程的退出。其中进程组ID = 当前进程的进程组ID&lt;/li&gt;&lt;li&gt;$pid &amp;gt;&amp;nbsp; 0: 等待进程ID为$pid的&lt;span&gt;子进程退出&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;$status会在调用结束后被赋予子进程的状态信息，对$status结果的判断可以使用以下函数：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;pcntl_wifexited($status): 判断子进程是否正常退出&amp;nbsp;&lt;/li&gt;&lt;li&gt;pcntl_wifstopped($status): 判断子进程是否已停止&lt;/li&gt;&lt;li&gt;pcntl_wstopsig($status): 获取导致子进程停止（stop）的信号(signal)，当pcntl_wifstopped返回TRUE时使用&lt;/li&gt;&lt;li&gt;pcntl_wifsignaled($status): 判断子进程是否由于某信号而退出&lt;/li&gt;&lt;li&gt;pcntl_wtermsig($status): 获取导致子进程终止运行（terminate）的信号（signal），当pcntl_wifsignaled返回TRUE时使用&lt;/li&gt;&lt;li&gt;pcntl_wexitstatus($status): 获取已终止子进程的退出值（exit_code）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;$options: 默认无需设置。但想要使用下面两种值需要&lt;span&gt;系统&lt;/span&gt;底层支持。参数&lt;span&gt;使用背景：&lt;/span&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;子进程退出时，内核会保存子进程的退出状态信息，直到父进程来消费这个状态信息，内核保存的状态信息即可释放&lt;/span&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;WNOHANG 作用：如果父进程不想阻塞式获取子进程状态可传入该值，则如果没有子进程退出，本次函数调用会立即return 0&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;WUNTRACED 作用：返回：进程已经stop了，但状态信息未被消费（取走）的子进程$pid&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;@return: 本次函数调用有3中返回结果，他们分别是：&lt;br /&gt;&lt;ul&gt;&lt;li&gt;result &amp;gt; 0: 返回值为：已退出的子进程的进程ID&lt;/li&gt;&lt;li&gt;result = -1: 函数调用出错&lt;/li&gt;&lt;li&gt;result = 0: 当使用&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;WNOHANG选项，并且无子进程退出时会返回0&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;PHP任务的多进程处理-父子进程的信号处理&quot;&gt;父/子进程的信号处理&lt;/h4&gt;&lt;h4 id=&quot;PHP任务的多进程处理-任务（进程）的后台执行&quot;&gt;任务（进程）的后台执行&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未完待续...&lt;/span&gt;&lt;/p&gt;&lt;h2 id=&quot;PHP任务的多进程处理-附录：通用PHP任务框架流程图&quot;&gt;附录：通用PHP任务框架流程图&lt;/h2&gt;&lt;p&gt;通用PHP任务框架流程图：&lt;a href=&quot;http://7b1gf6.com1.z0.glb.clouddn.com/PHP%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.svg&quot;&gt;PHP多进程任务流程图.svg&lt;/a&gt;&lt;/p&gt;
    
        &lt;/div&gt;</content><author><name></name></author><summary type="html">1 概述 2 PHP的多进程管理（PCNTL扩展） 2.1 示例1：简易demo 2.2 示例2：实际应用场景初探 3 PCNTL扩展进阶使用 3.1 子进程的管理（监控/终止子进程） 3.2 父/子进程的信号处理 3.3 任务（进程）的后台执行 4 附录：通用PHP任务框架流程图 概述很多以PHP为编程语言的Web项目，在需要做异步业务、数据的处理时，仍然会选择使用PHP语言来编写任务脚本。这么做的优点不言而喻，通用的底层model、业务service、熟悉的公共类及方法，让熟悉Web业务开发的工程师可以花最快的时间以及最小的学习成本快速编写出特定场景的业务脚本。然而PHP是为Web网页制作而生的单进程处理语言，当他遇到大数据场景下的业务数据的处理需求时，如果仍然依靠单进程的方式进行，不仅耗费更多时间、浪费服务器资源，而且可能很快就会遇到性能瓶颈。在这样一种场景需求下，PHP语言的多进行/线程处理能力就显得尤为需要了。PHP对多进程处理的支持虽然已经到来了(https://github.com/krakjoe/pthreads&amp;nbsp;)，然而它却只能在PHP7.2+以上的版本中运行，而且需要Thread Safety特性的支持。在这样一种现状下，使PHP支持多进程处理似乎是唯一（但不是最坏）的选择了。PHP的多进程管理（PCNTL扩展）PCNTL扩展&amp;nbsp;实现了类Unix系统中的进程创建、执行、信号处理以及最终的进程终止，更具体的实现方式可以参考类Unix系统提供的fork(2)、waitpid(2)和signal(2)函数接口。贝贝PHP的开发环境默认配置了PCNTL扩展，如果你的环境需要安装或配置该扩展，还请自行查找方法，此处略过。对PCNTL扩展有了初步的认识后，我们先来编写一个多进程的demo任务练练手，熟悉一下该扩展中核心函数pcntl_fork的使用场景及方法示例1：简易demo ?&amp;lt;?phpprint &quot;I'm in the Main process!\n&quot;;&amp;nbsp;// 当前进程：主进程$pid = pcntl_fork();// pcntl_fork()被执行后，系统会立即创建子进程，而且子进程的执行入口为紧跟在pcntl_fork()之后的代码，与主进程即将执行的代码一致print &quot;Who am I ?\n&quot;;&amp;nbsp;// 此时需要一种机制或约定来让编程人员判断当前代码执行的环境为主进程中or子进程中if ($pid === -1) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;Fork child process faield, exit!\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(1);} elseif ($pid === 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;I'm in the child process!\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;Child process exit.\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(0);} elseif ($pid &amp;gt; 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;I'm still in the main process!\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;Main process exit.\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(0);} 上面那段代码的输出会是什么样子呢？运行结果 expand source?[root@1d42e4522359 tmp]# php test.phpI'm in the Main process!Who am I ?I'm still in the main process!Main process exit.Who am I ?I'm in the child process!Child process exit. 从上面的示例代码中可以看出：不同于多线程中只会被新线程执行的特定代码块，多进程代码在被执行时，父进程与子进程几乎共用同一份代码，即pcntl_fork()之后的代码由于子进程被创建之后，父进程与子进程就相当于两个独立的进程，二者共用pcntl_fork()之后的代码，而且执行顺序没有保证，所以需要通过pcntl_fork()函数的返回值来判断当前进程所属父/子进程，以便通过if-else判断为父/子进程预设置不同的执行代码。pcntl_fork()函数的返回值$pid有三种情况：$pid = -1: 子进程创建失败，通常情况下子进程创建失败，程序都会记录原因后主动退出$pid &amp;gt; 0: 子进程创建成功。当前进程为父进程，其中$pid的值即为刚创建成功的子进程的进程id$pid = 0: 子进程创建成功。当前进程为子进程示例2：实际应用场景初探下面我们来编写一例有实际应用场景的例子：父进程创建2个子进程，每个子进程的工作内容相同：从主进程分配给自己的网址中抓取网页的标题字段并打印出来，然后退出程序。父进程在sleep几秒（其实是在等待子程序执行完并主动退出）后也退出程序。 ?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&amp;lt;?php&amp;nbsp;function printLine($msg) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print $msg . &quot;\n&quot;;}&amp;nbsp;function get_url_title($url) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$content = file_get_contents($url);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$match_arr = NULL;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ($content) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;preg_match('/&amp;lt;title&amp;gt;(.+?)&amp;lt;\/title&amp;gt;/', $content, $match_arr);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ($match_arr &amp;amp;&amp;amp; count($match_arr) === 2) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return $match_arr[1];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return NULL;}&amp;nbsp;printLine('Task begin.');&amp;nbsp;$site_urls = array(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'https://www.beibei.com',&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'https://www.jd.com',);&amp;nbsp;&amp;nbsp;foreach($site_urls as $_url) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$pid = pcntl_fork();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ($pid === -1) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;Fork child process faield, exit!&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(1);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} elseif ($pid === 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;In the child process!&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine($_url . ' title =&amp;gt; ' . get_url_title($_url));&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;Child process exit.&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(0);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} elseif ($pid &amp;gt; 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;In the parent process, do nothing.&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}}&amp;nbsp;$i = 7;while ($i--) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep(1);}printLine(&quot;Task end.&quot;); 运行结果 expand source?[root@1d42e4522359 beibei]# php testpcntl.phpTask begin.In the parent process, do nothing.In the child process!In the parent process, do nothing.In the child process!https://www.beibei.com title =&amp;gt; 贝贝网-买母婴上贝贝！1亿妈妈信赖的母婴正品特卖商城Child process exit.https://www.jd.com title =&amp;gt; 京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！Child process exit.Task end. 从上面的执行结果中我们又可以总结出PCNTL扩展函数的几个特点：1）子进程可以使用（继承了）父进程Context中的变量（如$_url）以及函数（如get_url_title()方法）2）如果移除父进程最后的sleep代码你会发现，子进程在父进程退出后依然可以正常运行，并不会随主进程的退出而退出PCNTL扩展进阶使用子进程的管理（监控/终止子进程）在实际的任务框架编写中，开发者通常会首先创建一个master进程，然后再由master进程创建N个子进程。其中每个子进程作为工作进程（worker process）进行实际的业务处理，master进程作为管理者，主要负责工作进程的调度、监管、维护、回收等内容。到了某个具体业务处理的场景下，对应业务的开发者仅需要完成自己业务逻辑部分，并将其作为工作进程的一部分，即可快速嵌入到整体的任务框架中去。在这种任务框架模式下，master进程对子进程的监控及控制能力就显得尤为重要了。那么如何借用PCNTL扩展的函数接口对子进程进行监管与控制呢？对子进程的监控，主要分两个方面：1）需要记录每个子进程的进程ID；2）可以通过子进程的进程ID获取子进程的运行状态（是否已结束、是否为僵尸进程）对子进程的控制，主要是指：可以通过子进程的进程ID获取其运行状态，并可以停止或中断其运行。获取子进程运行状态，需要用到函数pcntl_waitpid(int $pid, int &amp;amp;$status, int $options = 0)。本函数依赖于Linux系统的waitpid(2)函数的实现，作用为：阻断当前进程直到给定$pid的子进程退出（当遇到系统信号需要终止运行或调用信号处理函数时会转去进行信号处理）。注意该函数默认是阻塞型函数（除非$options设置为WNOHANG），其会根据入参的不同，做出多种可能的处理和返回（不过由于当前进程通常都为管理子进程的父进程，并非worker进程，所以即便阻塞也没关系）。参数解释：$pid：根据$pid值的范围进行不同的处理：$pid &amp;lt; -1: 等待指定进程组ID下所有子进程的退出。其中进程组ID = abs($pid)，即$pid的绝对值$pid = -1: 等待任意子进程（这里不太清楚，任意是指：用户空间的所有fork出的子进程？）的退出$pid =&amp;nbsp; 0: 等待指定进程组ID下所有子进程的退出。其中进程组ID = 当前进程的进程组ID$pid &amp;gt;&amp;nbsp; 0: 等待进程ID为$pid的子进程退出$status会在调用结束后被赋予子进程的状态信息，对$status结果的判断可以使用以下函数：pcntl_wifexited($status): 判断子进程是否正常退出&amp;nbsp;pcntl_wifstopped($status): 判断子进程是否已停止pcntl_wstopsig($status): 获取导致子进程停止（stop）的信号(signal)，当pcntl_wifstopped返回TRUE时使用pcntl_wifsignaled($status): 判断子进程是否由于某信号而退出pcntl_wtermsig($status): 获取导致子进程终止运行（terminate）的信号（signal），当pcntl_wifsignaled返回TRUE时使用pcntl_wexitstatus($status): 获取已终止子进程的退出值（exit_code）$options: 默认无需设置。但想要使用下面两种值需要系统底层支持。参数使用背景：子进程退出时，内核会保存子进程的退出状态信息，直到父进程来消费这个状态信息，内核保存的状态信息即可释放WNOHANG 作用：如果父进程不想阻塞式获取子进程状态可传入该值，则如果没有子进程退出，本次函数调用会立即return 0WUNTRACED 作用：返回：进程已经stop了，但状态信息未被消费（取走）的子进程$pid@return: 本次函数调用有3中返回结果，他们分别是：result &amp;gt; 0: 返回值为：已退出的子进程的进程IDresult = -1: 函数调用出错result = 0: 当使用WNOHANG选项，并且无子进程退出时会返回0父/子进程的信号处理任务（进程）的后台执行未完待续...附录：通用PHP任务框架流程图通用PHP任务框架流程图：PHP多进程任务流程图.svg</summary></entry><entry><title type="html">跨域请求那些事</title><link href="http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B.html" rel="alternate" type="text/html" title="跨域请求那些事" /><published>2018-03-15T00:00:00+08:00</published><updated>2018-03-15T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B</id><content type="html" xml:base="http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B.html">&lt;div class=&quot;wiki-content&quot;&gt;
    &lt;h2 id=&quot;id-跨域请求那些事-何为跨域请求Cross-originresourcesharing&quot;&gt;何为跨域请求(Cross-origin resource sharing)&lt;/h2&gt;
    &lt;p&gt;在网页浏览器中，当属于站点A的网页试图访问位于站点B上的某一资源&lt;span&gt;时&lt;/span&gt;（如图片、CSS、JS文件、指定URL的接口数据），这个请求就属于&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;跨域请求&lt;/a&gt;了。&lt;/p&gt;
    &lt;p&gt;通常情况下，站点A上的网页可以访问位于站点B上的图片、视频、CSS、JS等资源，但当站点A的网页向位于站点B的HTTP接口发送Ajax请求时，浏览器默认会检查该请求是否合法，意即：只有当站点B主动返回允许站点A访问该HTTP接口的许可信息时，站点A本次的Ajax请求才会被实际发送。从这一点可以看出，跨域请求的安全限制，实际是由浏览器保证并执行的。&lt;/p&gt;
    &lt;p&gt;浏览器对跨域的Ajax请求的处理流程图如下（资源来自维基百科&amp;nbsp;&lt;a href=&quot;/download/attachments/95368284/Flowchart_showing_Simple_and_Preflight_XHR.svg?version=1&amp;amp;modificationDate=1522826629000&quot;&gt;Flowchart_showing_Simple_and_Preflight_XHR.svg&lt;/a&gt;&amp;nbsp;）&lt;br /&gt;&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;800&quot; src=&quot;http://wx3.sinaimg.cn/large/6480dca9gy1fqc75j79ddj21kw0tqq95.jpg&quot; data-image-src=&quot;/download/attachments/95368284/image2018-4-4+14%3A16%3A14.png?version=1&amp;amp;modificationDate=1522826629000&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;从上图中可以看出，一个Ajax请求无论是GET形式还是POST形式，只要包含了特定的内容数据，都会触发浏览器的安全校验，所谓的安全校验是指：浏览器在发起本次请求之前，会对同一URL优先发起一次OPTIONS请求，通过OPTION请求返回的Header信息判定本次的&lt;span&gt;跨域&lt;/span&gt;Ajax请求是否合法，如果合法则请求被发出；否则请求被中止。&lt;/p&gt;
    &lt;p&gt;下方信息是从 hx.test.com 向 www.test.com/&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;api/upload_img.html&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;发起Ajax POST请求时抓取到的、浏览器优先发起OPTIONS请求的关键信息&lt;/span&gt;&lt;/p&gt;
    &lt;div class=&quot;table-wrap&quot;&gt;
        &lt;table class=&quot;confluenceTable&quot;&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;th colspan=&quot;2&quot; class=&quot;confluenceTh&quot;&gt;OPTIONS请求Header关键信息&lt;/th&gt;
                    &lt;th class=&quot;confluenceTh&quot;&gt;说明&lt;/th&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;状态行&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;OPTIONS /api/upload_img.html HTTP/1.1&amp;nbsp;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Host&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;www.test.com&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点B的域名&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Origin&amp;nbsp;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span class=&quot;nolink&quot;&gt;http://hx.test.com/&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点A的网址，跨域请求需携带&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Request-Method&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span&gt;POST&lt;/span&gt;&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;跨域请求需携带的Header&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Request-Headers&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;
                        &lt;p&gt;&lt;span&gt;X-&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;Requested-With&lt;/span&gt;&lt;/p&gt;
                    &lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span&gt;跨域请求需携带的Header&lt;/span&gt;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;highlight confluenceTd&quot; colspan=&quot;2&quot;&gt;&lt;span style=&quot;color: rgb(0,0,0);&quot;&gt;OPTIONS响应Header关键信息&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;highlight confluenceTd&quot; colspan=&quot;1&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;状态行&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;HTTP/1.1 200 OK&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Origin&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span class=&quot;nolink&quot;&gt;http://hx.test.com/&lt;/span&gt;&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点B允许站点A访问本资源&lt;br /&gt;若站点B设置该Header为 * ，则表示允许任意站点访问该资源&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Headers&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Origin, X-Requested-With, Content-Type&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点A请求站点B时可携带的Headers&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Methods&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;POST, OPTIONS&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点A请求站点B时可使用的Methods&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;
                        &lt;p&gt;Access-Control-Allow-Credentials&lt;/p&gt;
                    &lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;true&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点A请求站点B时，可携带站点B的Cookies&lt;br /&gt;若站点B未返回该Header，或将其设置为false，则站点A请求站点B不会携带站点B的Cookies）&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
    &lt;p&gt;综上可知，浏览器实现了W3C定义的安全约定，在站点跨域请求资源时，如果是Ajax请求并且请求的Header或Body中包含了触发安全校验的内容，则浏览器会优先发起（pre-flight）OPTIONS请求向目标站点询问：是否接受站点A的Ajax请求，以及可接受的请求内容（包括限定的Methods、Headers等）。最后再由浏览器检查核对后决定，允许并发起请求，或者，中止本次请求。&lt;/p&gt;
    &lt;p&gt;关于触发浏览器&lt;span&gt;安全校验（pre-flight）的条件详情，请参考火狐开发者文档：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;h2 id=&quot;id-跨域请求那些事-如何界定请求跨域了&quot;&gt;如何界定请求跨域了&lt;/h2&gt;
        &lt;p&gt;假如站点A的网页为：http://www.test.com ，请看下方界定请求跨域的例子&lt;/p&gt;
        &lt;div class=&quot;table-wrap&quot;&gt;
            &lt;table class=&quot;confluenceTable&quot;&gt;
                &lt;colgroup&gt;
                    &lt;col /&gt;
                    &lt;col /&gt;
                    &lt;col /&gt; &lt;/colgroup&gt;
                &lt;tbody&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;站点B列表&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;是否跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;原因&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com/dir/page2.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com/dir/page2.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;未跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com/dir2/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;未跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://username:password@www.test.com/dir2/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://username:password@www.test.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;未跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com:81/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com:81/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;已跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol and host but different port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;https://www.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://www.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different protocol&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://en.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://en.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host (exact match required)&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://v2.www.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://v2.www.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host (exact match required)&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com:80/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com:80/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;看浏览器实现&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Port explicit. Depends on implementation in browser&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
        &lt;h2 id=&quot;id-跨域请求那些事-PHP CodeIgniter框架对于跨域请求的注意点&quot;&gt;PHP CodeIgniter框架对于跨域请求的注意点&lt;/h2&gt;
        &lt;p&gt;随着业务线日益壮大，我也在日常的开发中遇到过几次跨域、跨站点请求（实则都为公司的子业务系统）失败、被阻的情况。&lt;/p&gt;
        &lt;p&gt;当遇到跨域请求失败的情况时，只需在后端代码中添加跨域允许的相关Header键值，即可通过浏览器的检查。&lt;/p&gt;
        &lt;p&gt;除此之外，&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;PHP的CodeIgniter框架还对跨站请求伪造（CSRF）进行了防御，下面针对这种情况做一下说明。&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&lt;span&gt;CSRF的实现逻辑是：&lt;/span&gt;&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;span&gt;1）可信用户A登录了test.com；&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;2）可信用户A访问危险网页或危险邮件，网页或邮件中隐藏着向test.com提交的表单内容（表单内容为普通form，由攻击发起者预先写死格式和内容）；&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;3）可信用户A被诱导点击了危险网页或邮件中的隐藏的form表单，导致表单内容被用户A提交至test.com，并且表单提交时携带的是可信用户A的可信Cookies&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div&gt;CodeIgniter对此做出的防御逻辑是：
            &lt;ul&gt;
                &lt;li&gt;1）每一次POST请求之前，客户端应首先发起GET请求拉取可信签名(csrf_defence_sign)并将签名放入Cookie中返回给客户端&lt;/li&gt;
                &lt;li&gt;2）POST数据时，需将可信签名作为表单的一部分同时提交，并由后端校验表单中的可信签名是否有效（具体的校验逻辑为：检查请求Cookie中的可信签名与POST中的可信签名一致，且可信签名有效）&lt;/li&gt;
            &lt;/ul&gt;
            &lt;p&gt;在公司做新的站点业务（testB.com)的时候，它共用了test.com的几乎所有代码，二者只是在域名上有区分，后端代码处理逻辑一模一样。由于需要从testB.com向test.com提交表单信息，此时CodeIgniter后端服务便误以为这些提交是CSRF攻击，因此直接中止了请求。&lt;/p&gt;
        &lt;/div&gt;

        &lt;p&gt;那么&lt;strong style=&quot;&quot;&gt;疑问来了&lt;/strong&gt;&lt;span style=&quot;&quot;&gt;：如果想从testB.com向test.com发送ajax跨域提交，是否可行？看下方流程图可知：由于CodeIgniter框架的CrossSiteRequestForgery检测和拦截在前，应用层设置跨域允许在后，所以结论是不可行。&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; width=&quot;660&quot; src=&quot;http://wx3.sinaimg.cn/large/6480dca9gy1fqc72ghlhuj20ww0lctbc.jpg&quot; /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;/div&gt;</content><author><name></name></author><summary type="html">何为跨域请求(Cross-origin resource sharing) 在网页浏览器中，当属于站点A的网页试图访问位于站点B上的某一资源时（如图片、CSS、JS文件、指定URL的接口数据），这个请求就属于跨域请求了。 通常情况下，站点A上的网页可以访问位于站点B上的图片、视频、CSS、JS等资源，但当站点A的网页向位于站点B的HTTP接口发送Ajax请求时，浏览器默认会检查该请求是否合法，意即：只有当站点B主动返回允许站点A访问该HTTP接口的许可信息时，站点A本次的Ajax请求才会被实际发送。从这一点可以看出，跨域请求的安全限制，实际是由浏览器保证并执行的。 浏览器对跨域的Ajax请求的处理流程图如下（资源来自维基百科&amp;nbsp;Flowchart_showing_Simple_and_Preflight_XHR.svg&amp;nbsp;） 从上图中可以看出，一个Ajax请求无论是GET形式还是POST形式，只要包含了特定的内容数据，都会触发浏览器的安全校验，所谓的安全校验是指：浏览器在发起本次请求之前，会对同一URL优先发起一次OPTIONS请求，通过OPTION请求返回的Header信息判定本次的跨域Ajax请求是否合法，如果合法则请求被发出；否则请求被中止。 下方信息是从 hx.test.com 向 www.test.com/api/upload_img.html&amp;nbsp;发起Ajax POST请求时抓取到的、浏览器优先发起OPTIONS请求的关键信息 OPTIONS请求Header关键信息 说明 状态行 OPTIONS /api/upload_img.html HTTP/1.1&amp;nbsp; &amp;nbsp; Host www.test.com 站点B的域名 Origin&amp;nbsp; http://hx.test.com/ 站点A的网址，跨域请求需携带 Access-Control-Request-Method POST 跨域请求需携带的Header Access-Control-Request-Headers X-Requested-With 跨域请求需携带的Header OPTIONS响应Header关键信息 &amp;nbsp; 状态行 HTTP/1.1 200 OK &amp;nbsp; Access-Control-Allow-Origin http://hx.test.com/ 站点B允许站点A访问本资源若站点B设置该Header为 * ，则表示允许任意站点访问该资源 Access-Control-Allow-Headers Origin, X-Requested-With, Content-Type 站点A请求站点B时可携带的Headers Access-Control-Allow-Methods POST, OPTIONS 站点A请求站点B时可使用的Methods Access-Control-Allow-Credentials true 站点A请求站点B时，可携带站点B的Cookies若站点B未返回该Header，或将其设置为false，则站点A请求站点B不会携带站点B的Cookies） 综上可知，浏览器实现了W3C定义的安全约定，在站点跨域请求资源时，如果是Ajax请求并且请求的Header或Body中包含了触发安全校验的内容，则浏览器会优先发起（pre-flight）OPTIONS请求向目标站点询问：是否接受站点A的Ajax请求，以及可接受的请求内容（包括限定的Methods、Headers等）。最后再由浏览器检查核对后决定，允许并发起请求，或者，中止本次请求。 关于触发浏览器安全校验（pre-flight）的条件详情，请参考火狐开发者文档：https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests 如何界定请求跨域了 假如站点A的网页为：http://www.test.com ，请看下方界定请求跨域的例子 站点B列表 是否跨域 原因 http://www.test.com/dir/page2.html 未跨域 Same protocol, host and port http://www.test.com/dir2/other.html 未跨域 Same protocol, host and port http://username:password@www.test.com/dir2/other.html 未跨域 Same protocol, host and port http://www.test.com:81/dir/other.html 已跨域 Same protocol and host but different port https://www.test.com/dir/other.html 已跨域 Different protocol http://en.test.com/dir/other.html 已跨域 Different host http://test.com/dir/other.html 已跨域 Different host (exact match required) http://v2.www.test.com/dir/other.html 已跨域 Different host (exact match required) http://www.test.com:80/dir/other.html 看浏览器实现 Port explicit. Depends on implementation in browser PHP CodeIgniter框架对于跨域请求的注意点 随着业务线日益壮大，我也在日常的开发中遇到过几次跨域、跨站点请求（实则都为公司的子业务系统）失败、被阻的情况。 当遇到跨域请求失败的情况时，只需在后端代码中添加跨域允许的相关Header键值，即可通过浏览器的检查。 除此之外，PHP的CodeIgniter框架还对跨站请求伪造（CSRF）进行了防御，下面针对这种情况做一下说明。 CSRF的实现逻辑是： 1）可信用户A登录了test.com； 2）可信用户A访问危险网页或危险邮件，网页或邮件中隐藏着向test.com提交的表单内容（表单内容为普通form，由攻击发起者预先写死格式和内容）； 3）可信用户A被诱导点击了危险网页或邮件中的隐藏的form表单，导致表单内容被用户A提交至test.com，并且表单提交时携带的是可信用户A的可信Cookies CodeIgniter对此做出的防御逻辑是： 1）每一次POST请求之前，客户端应首先发起GET请求拉取可信签名(csrf_defence_sign)并将签名放入Cookie中返回给客户端 2）POST数据时，需将可信签名作为表单的一部分同时提交，并由后端校验表单中的可信签名是否有效（具体的校验逻辑为：检查请求Cookie中的可信签名与POST中的可信签名一致，且可信签名有效） 在公司做新的站点业务（testB.com)的时候，它共用了test.com的几乎所有代码，二者只是在域名上有区分，后端代码处理逻辑一模一样。由于需要从testB.com向test.com提交表单信息，此时CodeIgniter后端服务便误以为这些提交是CSRF攻击，因此直接中止了请求。</summary></entry><entry><title type="html">PHP对象stdClass如何判断是否为空</title><link href="http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html" rel="alternate" type="text/html" title="PHP对象stdClass如何判断是否为空" /><published>2018-02-01T00:00:00+08:00</published><updated>2018-02-01T00:00:00+08:00</updated><id>http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA</id><content type="html" xml:base="http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;先来看下普通的为空判断，应用于stdClass类是什么表现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

if (!$obj) {
    echo '!(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo '!(obj) = FALSE' . &quot;\n&quot;;
}

if (empty($obj)) {
    echo 'empty(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo 'empty(obj) = FALSE' . &quot;\n&quot;;
}

if (is_null($obj)) {
    echo 'is_null(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo 'is_null(obj) = FALSE' . &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果（请先自己预测下？）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!(obj) = FALSE

empty(obj) = FALSE

is_null(obj) = FALSE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过在我接触过的各个语言中（Java、Python、Javascript），所有常规对象在进行布尔判断时都不为空，也算是符合业界通用的规则标准了&lt;/p&gt;

&lt;p&gt;那么想要判断一个stdClass是否为空时，应该使用什么方法呢？
业界通用的做法是：将stcClass转换（cast）为数组，再对数组进行判空操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

$obj_arr = (array) $obj;

if (!$obj_arr) { 
    echo 'bool judge false' . &quot;\n&quot;;
} else {
    echo 'bool judge true' . &quot;\n&quot;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然还有人提出这样的想法：使用get_object_vars方法获取这个对象的类属性，通过判断其返回值来间接进行判空的操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

$obj_attr_arr = get_object_vars($obj);

if (!$obj_attr_arr) {
    echo 'bool judge false' . &quot;\n&quot;;
} else {
    echo 'bool judge true' . &quot;\n&quot;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么这两种判空方式孰优孰劣呢？我对这两种方法分别执行500万次后发现&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法一（转为array）执行500万次耗时仅为0.8s左右；&lt;/li&gt;
  &lt;li&gt;方法二在执行同样次数后，耗时达到了惊人的17.8s左右&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此我们发现，通过将对象转为array以便间接判断stdClass是否为空是更高效的做法&lt;/p&gt;

&lt;h2 id=&quot;进阶&quot;&gt;进阶&lt;/h2&gt;
&lt;p&gt;当然，上面两种判断方法都是在：stdClass确实为空对象这一前提下进行的，那么如果stdClass是一个具有200个类属性的方法时，二者执行效率孰优孰劣？&lt;/p&gt;

&lt;p&gt;我们先来创建一个有200个类属性的对象&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

for ($i = 0; $i &amp;lt; 200; $i++) {
    $attr = &quot;{$i}rand{$i}&quot;;
    $obj-&amp;gt;$attr = $i;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再分别使用方式一和方式二对这个对象进行判空操作，对这两种方法分别执行500万次后发现：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法一（转为array）执行500万次耗时仍然维持在0.8s左右；&lt;/li&gt;
  &lt;li&gt;方法二在执行同样次数后，耗时比之前增加了5s，达到了23.45s&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;通过将对象转为array以间接判断stdClass是否为空，是更高效的做法&lt;/p&gt;</content><author><name></name></author><category term="Tech" /><summary type="html">背景 先来看下普通的为空判断，应用于stdClass类是什么表现：</summary></entry><entry><title type="html">Xdebug远程调试原理与实践</title><link href="http://localhost:4000/2018/01/10/Xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5.html" rel="alternate" type="text/html" title="Xdebug远程调试原理与实践" /><published>2018-01-10T00:00:00+08:00</published><updated>2018-01-10T00:00:00+08:00</updated><id>http://localhost:4000/2018/01/10/Xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5</id><content type="html" xml:base="http://localhost:4000/2018/01/10/Xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5.html">&lt;div class=&quot;wiki-content&quot;&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-1前言&quot;&gt;1. 前言&lt;/h2&gt;
    &lt;p&gt;&lt;span&gt;世界上有两种人：一种了解debug工具的好处，另一种则反之。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;那么debug工具到底有哪些优点呢？&lt;/span&gt;&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;1）在日常开发中洞悉大型架构的流程及设计；&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;2）在日常开发中快速debug，省时省力，&lt;span&gt;更能在debug过程中掌握程序运行流程及上下文&lt;/span&gt;；&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;3）&lt;strong&gt;debug驱动型开发习惯的养成&lt;/strong&gt;&lt;/p&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;span&gt;在PHP语言中有个叫&lt;/span&gt;&lt;code&gt;xdebug&lt;/code&gt;&lt;span&gt;的扩展，是业界最常用的PHP debug工具之一。xdebug有很多实用的特性，但本文只着重介绍&lt;/span&gt;&lt;em&gt;远程调试&lt;/em&gt;&lt;span&gt;这一特性的使用。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;注意：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;本文提到的IDE，意即：集成开发环境，例如PHPStrom、Eclipse就是很常见的IDE&lt;/li&gt;
        &lt;li&gt;PHPStrom和IDE在本文中可能会被混用，但他们都代表PHPStrom&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-2xdebug特性&quot;&gt;2. xdebug特性&lt;/h2&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;var_dump展示优化&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fdisplay&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;PHP输出notice、error等信息时，调用栈可定制化展示&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fstack_trace&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;函数调用报告&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fexecution_trace&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;代码覆盖率报告&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fcode_coverage&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;程序分析报告（profiler）&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fprofiler&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;远程调试。&lt;/strong&gt;本篇内容将着重介绍这一功能。如果你想获取有关如何配置可多人同时调试一台Web服务器的DBGp代理信息的话，也推荐你读完本文，这将对你后续的代理配置有一定帮助。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-3远程调试&quot;&gt;3. 远程调试&lt;/h2&gt;
    &lt;p&gt;xdebug的远程调试默认的通信协议为&lt;span&gt;&lt;strong&gt;DBGp协议&lt;/strong&gt;，它是基于XML文本传输的应用层协议，用于程序语言与IDE间的调试通信。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;DBGP协议规定：IDE向程序的调试器发送的内容为ascii命令，调试器向IDE发送的内容为XML数据&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;600&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fqc818gm2ij20rc09m74y.jpg&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

    &lt;p&gt;以下为基于DBGp协议进行debug的通信伪内容的示例。其中&quot;DBG&quot;是指程序调试器(比如xdebug)；&quot;IDE:&quot;是指IDE向DBG(xdebug)发送消息&quot;；&quot;DBG:&quot;是指DBG(xdebug)向IDE响应消息&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;IDE:  feature_get supports_async
DBG:  yes
IDE:  breakpoint_set file_path,file_line_no
DBG:  ok
IDE:  stdin redirect
DBG:  ok
IDE:  stderr redirect
DBG:  ok
IDE:  run
DBG:  stdin data...
DBG:  stdin data...
DBG:  reached breakpoint, pause running
IDE:  get context variables
DBG:  ok, here they are
IDE:  evaluate this expression
DBG:  stderr data...
DBG:  ok, done
IDE:  stop
DBG:  good bye&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;span&gt;由于DBGp协议是明文传输的，所以只需监听IDE的9000端口（IDE用于调试通信的端口）上的TCP通信，你便能一窥它的详细通信内容。如下方所示为局部通信内容截图。&lt;/span&gt;其中：172.17.0.2为Web服务器的IP，192.168.65.2是IDE所在开发机上的IP。&lt;/p&gt;

    &lt;p&gt;&lt;span&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;900&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fqc9m6lht5j21i60zgk9b.jpg&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;span style=&quot;color: rgb(0,0,0);font-size: 1.4em;font-weight: bold;&quot;&gt;3.1 xdebug调试(session)的生命周期&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;断点调试是有生命周期的。断点调试始于：手动或自动开启调试session，终止于：手动终止程序或程序自动运行退出。下方为xdebug的session状态流转图：&lt;/p&gt;
    &lt;p&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;555&quot; src=&quot;http://wx4.sinaimg.cn/large/6480dca9gy1fqc9thzsg4j20ho0m60u3.jpg&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;span&gt;xdebug调试的开始有以下两种方式&lt;/span&gt;&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-311外部触发xdebug启动调试&quot;&gt;3.1.1 外部触发xdebug启动调试&lt;/h4&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;请求的GET、POST的query中包含&lt;code&gt;XDEBUG_SESSION_START=sessName&lt;/code&gt;参数即可启动xdebug调试&lt;/li&gt;
        &lt;li&gt;Cookie中包含&lt;code&gt;XDEBUG_SESSION=sessName&lt;/code&gt;即可启动xdebug调试&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-312xdebug始终自启动调试（推荐使用）&quot;&gt;3.1.2 xdebug始终自启动调试（推荐使用）&lt;/h4&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;配置文件中设置&lt;code&gt;xdebug.remote_autostart=1&lt;/code&gt;，则PHP每次执行脚本都会启动xdebug调试（&lt;b&gt;没错，在命令行直接运行任务脚本也会启动调试&lt;/b&gt;）&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3 id=&quot;xdebug调试原理与实践-32xdebug主动连接IDE的两种方式&quot;&gt;3.2 xdebug主动连接IDE的两种方式&lt;/h3&gt;
    &lt;p&gt;xdebug的DBGp协议的第一步，是自xdebug启动调试session后，根据给定配置，主动连接IDE。在网上的相关教程中，我们往往会看到各式各样的xdebug.remote_host相关的配置，&lt;br /&gt;那么这些配置到底是起了什么作用呢？&lt;/p&gt;
    &lt;p&gt;这里就要讲到xdebug主动连接IDE的两种不同方式了，因为xdebug.remote_host相关的配置就是为了让xdebug可以连接到IDE的9000端口上。&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-321方式一：根据客户端请求IP连接IDE设置xdebugremoteconnectback1&quot;&gt;3.2.1 方式一：根据客户端请求IP连接IDE(设置&lt;code&gt;xdebug.remote_connect_back=1&lt;/code&gt;)&lt;/h4&gt;
    &lt;p&gt;xdebug连接IDE的方式一的时序图如下：&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-fafc337cf5d14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-fafc337cf5d14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;说明：&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;开发者发起URL请求后，xdebug通过解析&lt;code&gt;$_SERVER&lt;/code&gt;map中的&lt;code&gt;HTTP_X_FORWARDED_FOR&lt;/code&gt;和&lt;code&gt;REMOTE_ADDR&lt;/code&gt;字段获取开发者所在的IP地址&lt;/li&gt;
        &lt;li&gt;xdebug获取到开发者IP地址后，通过IP及IDE暴露的9000接口，与IDE建立连接，并进行后续通信&lt;/li&gt;
        &lt;li&gt;发起URL请求的机器与IDE必须属于同一IP(即同一台机器)&lt;/li&gt;
        &lt;li&gt;本方式适合IP变化频繁，或多个开发者共享同一台Web服务器等情况的使用&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-322方式二：根据指定IP连接IDE设置xdebugremotehostxxxx&quot;&gt;3.2.2方式二：根据指定IP连接IDE(设置&lt;code&gt;xdebug.remote_host=x.x.x.x&lt;/code&gt;)&lt;/h4&gt;
    &lt;p&gt;xdebug连接IDE的方式二的时序图如下：&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-f961516c23507d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-f961516c23507d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;说明：&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;以上两种连接方式，方式一优先级高于方式二。如下方配置所示，第二行配置将被忽略：&lt;br /&gt;xdebug.remote_connect_back = 1 &lt;br /&gt;xdebug.remote_host = x.x.x.x&amp;nbsp;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;如需使用方式二（固定IP），需将&lt;code&gt;xdebug.remote_connect_back&lt;/code&gt;置为0&lt;/li&gt;
        &lt;li&gt;第二种连接方式，适合开发机IP基本不变的开发者使用&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3 id=&quot;xdebug调试原理与实践-33PHPStrom配置xdebug调试&quot;&gt;3.3 PHPStrom配置xdebug调试&lt;/h3&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-331方式一（xdebugremoteconnectback1）的配置&quot;&gt;3.3.1 方式一（xdebug.remote_connect_back = 1）的配置&lt;/h4&gt;
    &lt;p&gt;xdebug.ini中的设置：&lt;/p&gt;
    &lt;pre class=&quot;hljs bash&quot;&gt;&lt;code class=&quot;bash&quot;&gt;zend_extension = xdebug.so &lt;br /&gt;&lt;/code&gt;xdebug.remote_enable = 1 ;开启远程调试 &lt;br /&gt;xdebug.remote_autostart = 1 ;自动启动调试 &lt;br /&gt;xdebug.remote_mode = req ;通过请求触发调试，另一种方式jit：遇到错误时触发 &lt;br /&gt;xdebug.remote_connect_back = 1 ;使用方式一连接 &lt;br /&gt;xdebug.remote_port = 9000 &lt;br /&gt;xdebug.remote_handler = dbgp ;xdebug与PHPStorm的debug协议 &lt;br /&gt;xdebug.idekey = &lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(42,161,152);&quot;&gt;&quot;PHPSTORM&quot;&lt;/span&gt;&lt;span style=&quot;font-family: Arial , Helvetica , FreeSans , sans-serif;;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/pre&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-332方式二（xdebugremotehostxxxx）的配置&quot;&gt;3.3.2 方式二（xdebug.remote_host = x.x.x.x）的配置&lt;/h4&gt;
    &lt;p&gt;xdebug.ini中的设置：&lt;/p&gt;
    &lt;pre class=&quot;hljs bash&quot;&gt;&lt;code class=&quot;bash&quot;&gt;zend_extension=xdebug.so &lt;br /&gt;xdebug.remote_enable = 1 &lt;br /&gt;xdebug.remote_autostart = 1 &lt;br /&gt;xdebug.remote_mode = req &lt;br /&gt;xdebug.remote_connect_back = 0 ;关闭方式一连接 &lt;br /&gt;xdebug.remote_host = 192.168.35.103 ;使用方式二连接 &lt;br /&gt;xdebug.remote_port = 9000 &lt;br /&gt;xdebug.remote_handler = dbgp &lt;br /&gt;xdebug.idekey = &lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(42,161,152);&quot;&gt;&quot;PHPSTORM&quot;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;
    
    &lt;h4&gt;3.3.3 设置未生效？问题排查&lt;/h4&gt;
    
    &lt;p&gt;有时我们已经按照教程设置好了一切，但打开IDE的断点调试，仍然没有任何效果。&lt;/p&gt;
    &lt;p&gt;我们会疑惑，程序为什么没有在运行到断点后暂停下来？&lt;span&gt;除了检查各种配置是否正确，开发者还有哪些工具、信息可以拿来推断到底是哪一部分出了问题？&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;其实知道了上述连接原理后，我们可以通过TCP工具监听9000端口上的网络通信，通过通信的内容，我们可以把问题细化到由于以下原因，导致的xdebug调试未生效，进而逐个解决问题：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;9000端口的网络连接并未发起，则推断是xdebug端的配置有问题，有可能是：1）xdebug设置有误；2）xdebug扩展未加载；3）PHP-fpm未启动；4）Nginx未启动&lt;/li&gt;
        &lt;li&gt;9000端口上发生了网络连接，但很快断掉了。有可能是：1）IDE的debug工具并未开启导致IDE的&lt;span&gt;9000&lt;/span&gt;端口不可用；2）IDE的端口设置不是9000；3）Web服务器并不能与IDE所在网络的指定端口通信&lt;/li&gt;
        &lt;li&gt;9000端口上发生了密密麻麻的网络通信。。。额，这个应该是IDE没有打断点吧？&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;span&gt;在这之前，我们需要打开IDE的debug开关，在代码入口第一行打上断点，然后&lt;/span&gt;&lt;span&gt;SSH进入Web服务器所在机器（通常是虚拟机，或docker容器），通过&lt;/span&gt;&lt;code&gt;tcpdump&lt;/code&gt;&lt;span&gt;工具进行问题排查。&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;tcpdump是TCP层通信的监听工具，由于DBGp协议是建立在TCP之上的应用层协议，所以可以通过更底层的工具监听DBGp协议的通信，上方截图中的DBGp协议局部通信内容，就是用tcpdump工具抓取的。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;由于tcpdump一次只能监听一个网卡上的网络通信，所以需要通过&lt;/span&gt;&lt;code&gt;ifconfig&lt;/code&gt;&lt;span&gt;命令获取Web服务器的IP经由的网卡&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;通过&lt;code&gt;ifconfig&lt;/code&gt;命令可以确定Web服务器的IP经由的网卡为&lt;code&gt;eth1&lt;/code&gt;。下面开始debug环节&lt;/p&gt;
    &lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
        &lt;div class=&quot;image-container&quot;&gt;
            &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-403848534eb9bb18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-403848534eb9bb18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;p&gt;&amp;nbsp;&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-333深度自检：在PHPStrom中入口代码第一行打断点，为什么代码未在断点处暂停&quot;&gt;3.3.4 深度自检：在PHPStrom中入口代码第一行打断点，为什么代码未在断点处暂停&lt;/h4&gt;
    &lt;p&gt;这种情况是大部分新手和新安装xdebu后的开发者会遇到的问题。遇到这种问题，该如何排查呢？&lt;/p&gt;
    &lt;p&gt;1）确定xdebug是否向PHPStrom发起网络连接。如果没有，则需要依次检查xdebug的设置是否正确。&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;在Web服务器命令行输入如下命令（注意网卡名称eth1应情况而异），开始监听xdebug在9000端口上的通信：&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;输入上述命令后，在开发机中访问URL，然后回到Web服务器命令行，查看是否有网络请求发起。如果命令行没有任何输出，则说明xdebug配置有误。请开始&lt;b&gt;步骤A自检&lt;/b&gt;：&lt;br /&gt;
            &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
                &lt;li&gt;xdebug扩展是否加载？在&lt;code&gt;phpinfo()&lt;/code&gt;中查看即可确定&lt;/li&gt;
                &lt;li&gt;xdebug设置是否按上方给出的两份设置正确填写？在&lt;code&gt;phpinfo()&lt;/code&gt;中也可以看到这些信息，请查看每项设置是否有多余字符出现？&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;2）在完成&lt;b&gt;步骤A自检&lt;/b&gt;后，重复1的操作，继续监听&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;。命令行输出结果如下图所示。其中&lt;span&gt;192.168.33.10&lt;/span&gt;的机器为Web服务器，&lt;span&gt;192.168.33.1&lt;/span&gt;的机器为IDE所在开发机，从图中信息可以看出Web服务器主动向开发机上的9000端口发起连接请求，但开发机拒绝了该连接请求（&lt;code&gt;Flags [R.]&lt;/code&gt;)&lt;/p&gt;
    &lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
        &lt;div class=&quot;image-container&quot;&gt;
            &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-5893f92aae47e33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-5893f92aae47e33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;遇到这种情况，请开始&lt;/span&gt;&lt;b&gt;步骤B自检&lt;/b&gt;：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;curl -v &lt;a rel=&quot;nofollow&quot;&gt;telnet://192.168.33.1:9000&lt;/a&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;。如果返回结果有&lt;/span&gt;&lt;em&gt;couldn't connect to host&lt;/em&gt;
        &lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;，则说明xdebug并不能使用给定IP端口与IDE通信。&lt;br /&gt;造成这的原因可能有：网络不可达（是否能ping通，如无法ping通，请换用其他可ping通的开发机IP，毕竟一个开发机可能有多个IP，最后使用方式二固定IP设置即可）；&lt;br /&gt;IDE端口设置并不是9000；&lt;br /&gt;或者IDE并未打开调试模式，如何打开请看下图&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-72da0495368975aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-72da0495368975aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;3）步骤B自检查完成后，再次在Web服务器命令行监听9000端口的通信：&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;。这一次，大量的连接信息开始输出，恭喜你，xdebug已经设置好了&lt;/p&gt;
&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-f57169afc6c70fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-f57169afc6c70fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;4）PHPStrom中接收到xdebug的网络连接后，如何设置与WebServer上代码的一一匹配&lt;/p&gt;

&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-0c8d5d9828b0fca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;总结：&lt;/b&gt;遇到xdebug设置相关的问题，最重要的是了解debug底层通信协议和原理，再通过TCP/IP抓包工具(比如tcpdump）进行问题排查及定位。通过上述步骤的排查，应该可以定位无法debug原因，并最终成功使用xdebug调试代码了。祝顺利~&lt;/p&gt;

&lt;/div&gt;</content><author><name></name></author><summary type="html">1. 前言 世界上有两种人：一种了解debug工具的好处，另一种则反之。 那么debug工具到底有哪些优点呢？ 1）在日常开发中洞悉大型架构的流程及设计； 2）在日常开发中快速debug，省时省力，更能在debug过程中掌握程序运行流程及上下文； 3）debug驱动型开发习惯的养成 在PHP语言中有个叫xdebug的扩展，是业界最常用的PHP debug工具之一。xdebug有很多实用的特性，但本文只着重介绍远程调试这一特性的使用。 注意： 本文提到的IDE，意即：集成开发环境，例如PHPStrom、Eclipse就是很常见的IDE PHPStrom和IDE在本文中可能会被混用，但他们都代表PHPStrom 2. xdebug特性 var_dump展示优化&amp;nbsp;&amp;gt;link PHP输出notice、error等信息时，调用栈可定制化展示&amp;nbsp;&amp;gt;link 函数调用报告&amp;nbsp;&amp;gt;link 代码覆盖率报告&amp;nbsp;&amp;gt;link 程序分析报告（profiler）&amp;gt;link 远程调试。本篇内容将着重介绍这一功能。如果你想获取有关如何配置可多人同时调试一台Web服务器的DBGp代理信息的话，也推荐你读完本文，这将对你后续的代理配置有一定帮助。 3. 远程调试 xdebug的远程调试默认的通信协议为DBGp协议，它是基于XML文本传输的应用层协议，用于程序语言与IDE间的调试通信。 DBGP协议规定：IDE向程序的调试器发送的内容为ascii命令，调试器向IDE发送的内容为XML数据</summary></entry><entry><title type="html">URL中的Hostname VS RequestHeader中的Host字段</title><link href="http://localhost:4000/2017/12/11/URL%E4%B8%AD%E7%9A%84Hostname_VS_RequestHeader%E4%B8%AD%E7%9A%84Host%E5%AD%97%E6%AE%B5.html" rel="alternate" type="text/html" title="URL中的Hostname VS RequestHeader中的Host字段" /><published>2017-12-11T00:00:00+08:00</published><updated>2017-12-11T00:00:00+08:00</updated><id>http://localhost:4000/2017/12/11/URL%E4%B8%AD%E7%9A%84Hostname_VS_RequestHeader%E4%B8%AD%E7%9A%84Host%E5%AD%97%E6%AE%B5</id><content type="html" xml:base="http://localhost:4000/2017/12/11/URL%E4%B8%AD%E7%9A%84Hostname_VS_RequestHeader%E4%B8%AD%E7%9A%84Host%E5%AD%97%E6%AE%B5.html">&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;通常情况下访问URL的时候，我们直接使用一个字段标明这个URL所属的HOST信息&lt;/p&gt;

&lt;p&gt;但是如果你的URL中的HostName是IPV4地址，同时在请求的Header中设置了”Host”字段，那么这个资源(URI)的寻找依据会是什么呢？&lt;/p&gt;

&lt;h2 id=&quot;准备步骤&quot;&gt;准备步骤：&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;把&lt;code class=&quot;highlighter-rouge&quot;&gt;i-dev.beibei.com&lt;/code&gt;的host指向&lt;code class=&quot;highlighter-rouge&quot;&gt;192.168.33.10&lt;/code&gt; (本机eth1的网卡IP地址)&lt;/li&gt;
  &lt;li&gt;访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://127.0.0.1/account/coupon.html&lt;/code&gt;，同时设置RequetHeader的Host字段为 &lt;code class=&quot;highlighter-rouge&quot;&gt;i-dev.beibei.com&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;开始访问: &lt;code class=&quot;highlighter-rouge&quot;&gt;curl -v --head --header &quot;host: i-dev.beibei.com&quot; &lt;/code&gt;
 (-v指明verbose详细信息；–head指明打印RequestHeader；–header用于设置RequestHeader的字段)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/4111-60fda1fdbe323bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过curl结果可以看到，寻找这个资源时，HTTP1.1 优先通过url中的ipv4地址和80端口直连web-server，RequestHeader中的Host绑定的ip：192.168.33.10并未出现在请求过程中&lt;/p&gt;

&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;h4 id=&quot;场景1&quot;&gt;场景1&lt;/h4&gt;
&lt;p&gt;现有：一个HTTP的调用方(例如RocketMQ的proxy)，同时有一个HTTP的提供方（server，例如www.beibei.com）。&lt;/p&gt;

&lt;p&gt;如何做到将这两个程序部署在同一机器上，而且HTTP调用方只会访问本机的HTTP提供方的服务？&lt;/p&gt;

&lt;p&gt;方法1：改动/etc/hosts文件，将host指向本机。方案点评：如果部署100台机器，就需要改动100次hosts文件。&lt;/p&gt;

&lt;p&gt;方法2：访问http://127.0.0.1/，同时在HTTP Request的Header中设置host为&lt;code class=&quot;highlighter-rouge&quot;&gt;www.beibei.com&lt;/code&gt;
方案点评：只需部署代码，无需改动机器配置&lt;/p&gt;

&lt;h4 id=&quot;场景2&quot;&gt;场景2&lt;/h4&gt;
&lt;p&gt;另一个应用场景：在本地开发时，需要触发某个URL被访问时，可以这样：
&lt;code class=&quot;highlighter-rouge&quot;&gt;curl --header &quot;host: 
 www.beibei.com&quot; http://127.0.0.1/preview/detail.html&lt;/code&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">概述 通常情况下访问URL的时候，我们直接使用一个字段标明这个URL所属的HOST信息</summary></entry></feed>