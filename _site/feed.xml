<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-04-27T14:36:10+08:00</updated><id>http://localhost:4000/</id><title type="html">蓝枫铭的技术博客</title><subtitle>不想做架构师的厨师不是好程序员</subtitle><entry><title type="html">跨域请求那些事</title><link href="http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B.html" rel="alternate" type="text/html" title="跨域请求那些事" /><published>2018-03-15T00:00:00+08:00</published><updated>2018-03-15T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B</id><content type="html" xml:base="http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B.html">&lt;div class=&quot;wiki-content&quot;&gt;
    &lt;h2 id=&quot;id-跨域请求那些事-何为跨域请求Cross-originresourcesharing&quot;&gt;何为跨域请求(Cross-origin resource sharing)&lt;/h2&gt;
    &lt;p&gt;在网页浏览器中，当属于站点A的网页试图访问位于站点B上的某一资源&lt;span&gt;时&lt;/span&gt;（如图片、CSS、JS文件、指定URL的接口数据），这个请求就属于&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;跨域请求&lt;/a&gt;了。&lt;/p&gt;
    &lt;p&gt;通常情况下，站点A上的网页可以访问位于站点B上的图片、视频、CSS、JS等资源，但当站点A的网页向位于站点B的HTTP接口发送Ajax请求时，浏览器默认会检查该请求是否合法，意即：只有当站点B主动返回允许站点A访问该HTTP接口的许可信息时，站点A本次的Ajax请求才会被实际发送。从这一点可以看出，跨域请求的安全限制，实际是由浏览器保证并执行的。&lt;/p&gt;
    &lt;p&gt;浏览器对跨域的Ajax请求的处理流程图如下（资源来自维基百科&amp;nbsp;&lt;a href=&quot;/download/attachments/95368284/Flowchart_showing_Simple_and_Preflight_XHR.svg?version=1&amp;amp;modificationDate=1522826629000&quot;&gt;Flowchart_showing_Simple_and_Preflight_XHR.svg&lt;/a&gt;&amp;nbsp;）&lt;br /&gt;&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;800&quot; src=&quot;http://wx3.sinaimg.cn/large/6480dca9gy1fqc75j79ddj21kw0tqq95.jpg&quot; data-image-src=&quot;/download/attachments/95368284/image2018-4-4+14%3A16%3A14.png?version=1&amp;amp;modificationDate=1522826629000&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;从上图中可以看出，一个Ajax请求无论是GET形式还是POST形式，只要包含了特定的内容数据，都会触发浏览器的安全校验，所谓的安全校验是指：浏览器在发起本次请求之前，会对同一URL优先发起一次OPTIONS请求，通过OPTION请求返回的Header信息判定本次的&lt;span&gt;跨域&lt;/span&gt;Ajax请求是否合法，如果合法则请求被发出；否则请求被中止。&lt;/p&gt;
    &lt;p&gt;下方信息是从 hx.test.com 向 www.test.com/&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;api/upload_img.html&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;发起Ajax POST请求时抓取到的、浏览器优先发起OPTIONS请求的关键信息&lt;/span&gt;&lt;/p&gt;
    &lt;div class=&quot;table-wrap&quot;&gt;
        &lt;table class=&quot;confluenceTable&quot;&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;th colspan=&quot;2&quot; class=&quot;confluenceTh&quot;&gt;OPTIONS请求Header关键信息&lt;/th&gt;
                    &lt;th class=&quot;confluenceTh&quot;&gt;说明&lt;/th&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;状态行&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;OPTIONS /api/upload_img.html HTTP/1.1&amp;nbsp;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Host&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;www.test.com&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点B的域名&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Origin&amp;nbsp;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span class=&quot;nolink&quot;&gt;http://hx.test.com/&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点A的网址，跨域请求需携带&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Request-Method&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span&gt;POST&lt;/span&gt;&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;跨域请求需携带的Header&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Request-Headers&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;
                        &lt;p&gt;&lt;span&gt;X-&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;Requested-With&lt;/span&gt;&lt;/p&gt;
                    &lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span&gt;跨域请求需携带的Header&lt;/span&gt;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;highlight confluenceTd&quot; colspan=&quot;2&quot;&gt;&lt;span style=&quot;color: rgb(0,0,0);&quot;&gt;OPTIONS响应Header关键信息&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;highlight confluenceTd&quot; colspan=&quot;1&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;状态行&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;HTTP/1.1 200 OK&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Origin&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span class=&quot;nolink&quot;&gt;http://hx.test.com/&lt;/span&gt;&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点B允许站点A访问本资源&lt;br /&gt;若站点B设置该Header为 * ，则表示允许任意站点访问该资源&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Headers&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Origin, X-Requested-With, Content-Type&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点A请求站点B时可携带的Headers&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Methods&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;POST, OPTIONS&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点A请求站点B时可使用的Methods&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;
                        &lt;p&gt;Access-Control-Allow-Credentials&lt;/p&gt;
                    &lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;true&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点A请求站点B时，可携带站点B的Cookies&lt;br /&gt;若站点B未返回该Header，或将其设置为false，则站点A请求站点B不会携带站点B的Cookies）&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
    &lt;p&gt;综上可知，浏览器实现了W3C定义的安全约定，在站点跨域请求资源时，如果是Ajax请求并且请求的Header或Body中包含了触发安全校验的内容，则浏览器会优先发起（pre-flight）OPTIONS请求向目标站点询问：是否接受站点A的Ajax请求，以及可接受的请求内容（包括限定的Methods、Headers等）。最后再由浏览器检查核对后决定，允许并发起请求，或者，中止本次请求。&lt;/p&gt;
    &lt;p&gt;关于触发浏览器&lt;span&gt;安全校验（pre-flight）的条件详情，请参考火狐开发者文档：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;h2 id=&quot;id-跨域请求那些事-如何界定请求跨域了&quot;&gt;如何界定请求跨域了&lt;/h2&gt;
        &lt;p&gt;假如站点A的网页为：http://www.test.com ，请看下方界定请求跨域的例子&lt;/p&gt;
        &lt;div class=&quot;table-wrap&quot;&gt;
            &lt;table class=&quot;confluenceTable&quot;&gt;
                &lt;colgroup&gt;
                    &lt;col /&gt;
                    &lt;col /&gt;
                    &lt;col /&gt; &lt;/colgroup&gt;
                &lt;tbody&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;站点B列表&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;是否跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;原因&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com/dir/page2.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com/dir/page2.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;未跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com/dir2/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;未跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://username:password@www.test.com/dir2/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://username:password@www.test.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;未跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com:81/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com:81/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;已跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol and host but different port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;https://www.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://www.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different protocol&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://en.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://en.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host (exact match required)&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://v2.www.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://v2.www.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host (exact match required)&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com:80/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com:80/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;看浏览器实现&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Port explicit. Depends on implementation in browser&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
        &lt;h2 id=&quot;id-跨域请求那些事-PHP CodeIgniter框架对于跨域请求的注意点&quot;&gt;PHP CodeIgniter框架对于跨域请求的注意点&lt;/h2&gt;
        &lt;p&gt;随着业务线日益壮大，我也在日常的开发中遇到过几次跨域、跨站点请求（实则都为公司的子业务系统）失败、被阻的情况。&lt;/p&gt;
        &lt;p&gt;当遇到跨域请求失败的情况时，只需在后端代码中添加跨域允许的相关Header键值，即可通过浏览器的检查。&lt;/p&gt;
        &lt;p&gt;除此之外，&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;PHP的CodeIgniter框架还对跨站请求伪造（CSRF）进行了防御，下面针对这种情况做一下说明。&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&lt;span&gt;CSRF的实现逻辑是：&lt;/span&gt;&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;span&gt;1）可信用户A登录了test.com；&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;2）可信用户A访问危险网页或危险邮件，网页或邮件中隐藏着向test.com提交的表单内容（表单内容为普通form，由攻击发起者预先写死格式和内容）；&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;3）可信用户A被诱导点击了危险网页或邮件中的隐藏的form表单，导致表单内容被用户A提交至test.com，并且表单提交时携带的是可信用户A的可信Cookies&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div&gt;CodeIgniter对此做出的防御逻辑是：
            &lt;ul&gt;
                &lt;li&gt;1）每一次POST请求之前，客户端应首先发起GET请求拉取可信签名(csrf_defence_sign)并将签名放入Cookie中返回给客户端&lt;/li&gt;
                &lt;li&gt;2）POST数据时，需将可信签名作为表单的一部分同时提交，并由后端校验表单中的可信签名是否有效（具体的校验逻辑为：检查请求Cookie中的可信签名与POST中的可信签名一致，且可信签名有效）&lt;/li&gt;
            &lt;/ul&gt;
            &lt;p&gt;在公司做新的站点业务（testB.com)的时候，它共用了test.com的几乎所有代码，二者只是在域名上有区分，后端代码处理逻辑一模一样。由于需要从testB.com向test.com提交表单信息，此时CodeIgniter后端服务便误以为这些提交是CSRF攻击，因此直接中止了请求。&lt;/p&gt;
        &lt;/div&gt;

        &lt;p&gt;那么&lt;strong style=&quot;&quot;&gt;疑问来了&lt;/strong&gt;&lt;span style=&quot;&quot;&gt;：如果想从testB.com向test.com发送ajax跨域提交，是否可行？看下方流程图可知：由于CodeIgniter框架的CrossSiteRequestForgery检测和拦截在前，应用层设置跨域允许在后，所以结论是不可行。&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; width=&quot;660&quot; src=&quot;http://wx3.sinaimg.cn/large/6480dca9gy1fqc72ghlhuj20ww0lctbc.jpg&quot; /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;/div&gt;</content><author><name></name></author><summary type="html">何为跨域请求(Cross-origin resource sharing) 在网页浏览器中，当属于站点A的网页试图访问位于站点B上的某一资源时（如图片、CSS、JS文件、指定URL的接口数据），这个请求就属于跨域请求了。 通常情况下，站点A上的网页可以访问位于站点B上的图片、视频、CSS、JS等资源，但当站点A的网页向位于站点B的HTTP接口发送Ajax请求时，浏览器默认会检查该请求是否合法，意即：只有当站点B主动返回允许站点A访问该HTTP接口的许可信息时，站点A本次的Ajax请求才会被实际发送。从这一点可以看出，跨域请求的安全限制，实际是由浏览器保证并执行的。 浏览器对跨域的Ajax请求的处理流程图如下（资源来自维基百科&amp;nbsp;Flowchart_showing_Simple_and_Preflight_XHR.svg&amp;nbsp;） 从上图中可以看出，一个Ajax请求无论是GET形式还是POST形式，只要包含了特定的内容数据，都会触发浏览器的安全校验，所谓的安全校验是指：浏览器在发起本次请求之前，会对同一URL优先发起一次OPTIONS请求，通过OPTION请求返回的Header信息判定本次的跨域Ajax请求是否合法，如果合法则请求被发出；否则请求被中止。 下方信息是从 hx.test.com 向 www.test.com/api/upload_img.html&amp;nbsp;发起Ajax POST请求时抓取到的、浏览器优先发起OPTIONS请求的关键信息 OPTIONS请求Header关键信息 说明 状态行 OPTIONS /api/upload_img.html HTTP/1.1&amp;nbsp; &amp;nbsp; Host www.test.com 站点B的域名 Origin&amp;nbsp; http://hx.test.com/ 站点A的网址，跨域请求需携带 Access-Control-Request-Method POST 跨域请求需携带的Header Access-Control-Request-Headers X-Requested-With 跨域请求需携带的Header OPTIONS响应Header关键信息 &amp;nbsp; 状态行 HTTP/1.1 200 OK &amp;nbsp; Access-Control-Allow-Origin http://hx.test.com/ 站点B允许站点A访问本资源若站点B设置该Header为 * ，则表示允许任意站点访问该资源 Access-Control-Allow-Headers Origin, X-Requested-With, Content-Type 站点A请求站点B时可携带的Headers Access-Control-Allow-Methods POST, OPTIONS 站点A请求站点B时可使用的Methods Access-Control-Allow-Credentials true 站点A请求站点B时，可携带站点B的Cookies若站点B未返回该Header，或将其设置为false，则站点A请求站点B不会携带站点B的Cookies） 综上可知，浏览器实现了W3C定义的安全约定，在站点跨域请求资源时，如果是Ajax请求并且请求的Header或Body中包含了触发安全校验的内容，则浏览器会优先发起（pre-flight）OPTIONS请求向目标站点询问：是否接受站点A的Ajax请求，以及可接受的请求内容（包括限定的Methods、Headers等）。最后再由浏览器检查核对后决定，允许并发起请求，或者，中止本次请求。 关于触发浏览器安全校验（pre-flight）的条件详情，请参考火狐开发者文档：https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests 如何界定请求跨域了 假如站点A的网页为：http://www.test.com ，请看下方界定请求跨域的例子 站点B列表 是否跨域 原因 http://www.test.com/dir/page2.html 未跨域 Same protocol, host and port http://www.test.com/dir2/other.html 未跨域 Same protocol, host and port http://username:password@www.test.com/dir2/other.html 未跨域 Same protocol, host and port http://www.test.com:81/dir/other.html 已跨域 Same protocol and host but different port https://www.test.com/dir/other.html 已跨域 Different protocol http://en.test.com/dir/other.html 已跨域 Different host http://test.com/dir/other.html 已跨域 Different host (exact match required) http://v2.www.test.com/dir/other.html 已跨域 Different host (exact match required) http://www.test.com:80/dir/other.html 看浏览器实现 Port explicit. Depends on implementation in browser PHP CodeIgniter框架对于跨域请求的注意点 随着业务线日益壮大，我也在日常的开发中遇到过几次跨域、跨站点请求（实则都为公司的子业务系统）失败、被阻的情况。 当遇到跨域请求失败的情况时，只需在后端代码中添加跨域允许的相关Header键值，即可通过浏览器的检查。 除此之外，PHP的CodeIgniter框架还对跨站请求伪造（CSRF）进行了防御，下面针对这种情况做一下说明。 CSRF的实现逻辑是： 1）可信用户A登录了test.com； 2）可信用户A访问危险网页或危险邮件，网页或邮件中隐藏着向test.com提交的表单内容（表单内容为普通form，由攻击发起者预先写死格式和内容）； 3）可信用户A被诱导点击了危险网页或邮件中的隐藏的form表单，导致表单内容被用户A提交至test.com，并且表单提交时携带的是可信用户A的可信Cookies CodeIgniter对此做出的防御逻辑是： 1）每一次POST请求之前，客户端应首先发起GET请求拉取可信签名(csrf_defence_sign)并将签名放入Cookie中返回给客户端 2）POST数据时，需将可信签名作为表单的一部分同时提交，并由后端校验表单中的可信签名是否有效（具体的校验逻辑为：检查请求Cookie中的可信签名与POST中的可信签名一致，且可信签名有效） 在公司做新的站点业务（testB.com)的时候，它共用了test.com的几乎所有代码，二者只是在域名上有区分，后端代码处理逻辑一模一样。由于需要从testB.com向test.com提交表单信息，此时CodeIgniter后端服务便误以为这些提交是CSRF攻击，因此直接中止了请求。</summary></entry><entry><title type="html">PHP对象stdClass如何判断是否为空</title><link href="http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html" rel="alternate" type="text/html" title="PHP对象stdClass如何判断是否为空" /><published>2018-02-01T00:00:00+08:00</published><updated>2018-02-01T00:00:00+08:00</updated><id>http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA</id><content type="html" xml:base="http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html">&lt;p&gt;先来看下普通的为空判断，应用于stdClass类是什么表现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

if (!$obj) {
    echo '!(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo '!(obj) = FALSE' . &quot;\n&quot;;
}

if (empty($obj)) {
    echo 'empty(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo 'empty(obj) = FALSE' . &quot;\n&quot;;
}

if (is_null($obj)) {
    echo 'is_null(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo 'is_null(obj) = FALSE' . &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果（请先自己预测下？）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!(obj) = FALSE

empty(obj) = FALSE

is_null(obj) = FALSE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过在我接触过的各个语言中（Java、Python、Javascript），所有常规对象在进行布尔判断时都不为空，也算是符合业界通用的规则标准了&lt;/p&gt;

&lt;p&gt;那么想要判断一个stdClass是否为空时，应该使用什么方法呢？
业界通用的做法是：将stcClass转换（cast）为数组，再对数组进行判空操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

$obj_arr = (array) $obj;

if (!$obj_arr) { 
    echo 'bool judge false' . &quot;\n&quot;;
} else {
    echo 'bool judge true' . &quot;\n&quot;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然还有人提出这样的想法：使用get_object_vars方法获取这个对象的类属性，通过判断其返回值来间接进行判空的操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

$obj_attr_arr = get_object_vars($obj);

if (!$obj_attr_arr) {
    echo 'bool judge false' . &quot;\n&quot;;
} else {
    echo 'bool judge true' . &quot;\n&quot;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么这两种判空方式孰优孰劣呢？我对这两种方法分别执行500万次后发现&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法一（转为array）执行500万次耗时仅为0.8s左右；&lt;/li&gt;
  &lt;li&gt;方法二在执行同样次数后，耗时达到了惊人的17.8s左右&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;显然，通过将对象转为array以便间接判断stdClass是否为空是更高效的做法&lt;/p&gt;</content><author><name></name></author><category term="Tech" /><summary type="html">先来看下普通的为空判断，应用于stdClass类是什么表现：</summary></entry><entry><title type="html">xdebug远程调试原理与实践</title><link href="http://localhost:4000/2018/01/10/xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5.html" rel="alternate" type="text/html" title="xdebug远程调试原理与实践" /><published>2018-01-10T00:00:00+08:00</published><updated>2018-01-10T00:00:00+08:00</updated><id>http://localhost:4000/2018/01/10/xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5</id><content type="html" xml:base="http://localhost:4000/2018/01/10/xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5.html">&lt;div class=&quot;wiki-content&quot;&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-1前言&quot;&gt;1. 前言&lt;/h2&gt;
    &lt;p&gt;&lt;span&gt;世界上有两种人：一种了解debug工具的好处，另一种则反之。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;那么debug工具到底有哪些优点呢？&lt;/span&gt;&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;1）在日常开发中洞悉大型架构的流程及设计；&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;2）在日常开发中快速debug，省时省力，&lt;span&gt;更能在debug过程中掌握程序运行流程及上下文&lt;/span&gt;；&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;3）&lt;strong&gt;debug驱动型开发习惯的养成&lt;/strong&gt;&lt;/p&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;span&gt;在PHP语言中有个叫&lt;/span&gt;&lt;code&gt;xdebug&lt;/code&gt;&lt;span&gt;的扩展，是业界最常用的PHP debug工具之一。xdebug有很多实用的特性，但本文只着重介绍&lt;/span&gt;&lt;em&gt;远程调试&lt;/em&gt;&lt;span&gt;这一特性的使用。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;注意：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;本文提到的IDE，意即：集成开发环境，例如PHPStrom、Eclipse就是很常见的IDE&lt;/li&gt;
        &lt;li&gt;PHPStrom和IDE在本文中可能会被混用，但他们都代表PHPStrom&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-2xdebug特性&quot;&gt;2. xdebug特性&lt;/h2&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;var_dump展示优化&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fdisplay&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;PHP输出notice、error等信息时，调用栈可定制化展示&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fstack_trace&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;函数调用报告&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fexecution_trace&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;代码覆盖率报告&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fcode_coverage&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;程序分析报告（profiler）&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fprofiler&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;远程调试。&lt;/strong&gt;本篇内容将着重介绍这一功能。如果你想获取有关如何配置可多人同时调试一台Web服务器的DBGp代理信息的话，也推荐你读完本文，这将对你后续的代理配置有一定帮助。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-3远程调试&quot;&gt;3. 远程调试&lt;/h2&gt;
    &lt;p&gt;xdebug的远程调试默认的通信协议为&lt;span&gt;&lt;strong&gt;DBGp协议&lt;/strong&gt;，它是基于XML文本传输的应用层协议，用于程序语言与IDE间的调试通信。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;DBGP协议规定：IDE向程序的调试器发送的内容为ascii命令，调试器向IDE发送的内容为XML数据&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;600&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fqc818gm2ij20rc09m74y.jpg&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

    &lt;p&gt;以下为基于DBGp协议进行debug的通信伪内容的示例。其中&quot;DBG&quot;是指程序调试器(比如xdebug)；&quot;IDE:&quot;是指IDE向DBG(xdebug)发送消息&quot;；&quot;DBG:&quot;是指DBG(xdebug)向IDE响应消息&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;IDE:  feature_get supports_async
DBG:  yes
IDE:  breakpoint_set file_path,file_line_no
DBG:  ok
IDE:  stdin redirect
DBG:  ok
IDE:  stderr redirect
DBG:  ok
IDE:  run
DBG:  stdin data...
DBG:  stdin data...
DBG:  reached breakpoint, pause running
IDE:  get context variables
DBG:  ok, here they are
IDE:  evaluate this expression
DBG:  stderr data...
DBG:  ok, done
IDE:  stop
DBG:  good bye&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;span&gt;由于DBGp协议是明文传输的，所以只需监听IDE的9000端口（IDE用于调试通信的端口）上的TCP通信，你便能一窥它的详细通信内容。如下方所示为局部通信内容截图。&lt;/span&gt;其中：172.17.0.2为Web服务器的IP，192.168.65.2是IDE所在开发机上的IP。&lt;/p&gt;

    &lt;p&gt;&lt;span&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;900&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fqc9m6lht5j21i60zgk9b.jpg&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;span style=&quot;color: rgb(0,0,0);font-size: 1.4em;font-weight: bold;&quot;&gt;3.1 xdebug调试(session)的生命周期&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;断点调试是有生命周期的。断点调试始于：手动或自动开启调试session，终止于：手动终止程序或程序自动运行退出。下方为xdebug的session状态流转图：&lt;/p&gt;
    &lt;p&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;555&quot; src=&quot;http://wx4.sinaimg.cn/large/6480dca9gy1fqc9thzsg4j20ho0m60u3.jpg&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;span&gt;xdebug调试的开始有以下两种方式&lt;/span&gt;&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-311外部触发xdebug启动调试&quot;&gt;3.1.1 外部触发xdebug启动调试&lt;/h4&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;请求的GET、POST的query中包含&lt;code&gt;XDEBUG_SESSION_START=sessName&lt;/code&gt;参数即可启动xdebug调试&lt;/li&gt;
        &lt;li&gt;Cookie中包含&lt;code&gt;XDEBUG_SESSION=sessName&lt;/code&gt;即可启动xdebug调试&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-312xdebug始终自启动调试（推荐使用）&quot;&gt;3.1.2 xdebug始终自启动调试（推荐使用）&lt;/h4&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;配置文件中设置&lt;code&gt;xdebug.remote_autostart=1&lt;/code&gt;，则PHP每次执行脚本都会启动xdebug调试（&lt;b&gt;没错，在命令行直接运行任务脚本也会启动调试&lt;/b&gt;）&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3 id=&quot;xdebug调试原理与实践-32xdebug主动连接IDE的两种方式&quot;&gt;3.2 xdebug主动连接IDE的两种方式&lt;/h3&gt;
    &lt;p&gt;xdebug的DBGp协议的第一步，是自xdebug启动调试session后，根据给定配置，主动连接IDE。在网上的相关教程中，我们往往会看到各式各样的xdebug.remote_host相关的配置，&lt;br /&gt;那么这些配置到底是起了什么作用呢？&lt;/p&gt;
    &lt;p&gt;这里就要讲到xdebug主动连接IDE的两种不同方式了，因为xdebug.remote_host相关的配置就是为了让xdebug可以连接到IDE的9000端口上。&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-321方式一：根据客户端请求IP连接IDE设置xdebugremoteconnectback1&quot;&gt;3.2.1 方式一：根据客户端请求IP连接IDE(设置&lt;code&gt;xdebug.remote_connect_back=1&lt;/code&gt;)&lt;/h4&gt;
    &lt;p&gt;xdebug连接IDE的方式一的时序图如下：&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-fafc337cf5d14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-fafc337cf5d14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;说明：&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;开发者发起URL请求后，xdebug通过解析&lt;code&gt;$_SERVER&lt;/code&gt;map中的&lt;code&gt;HTTP_X_FORWARDED_FOR&lt;/code&gt;和&lt;code&gt;REMOTE_ADDR&lt;/code&gt;字段获取开发者所在的IP地址&lt;/li&gt;
        &lt;li&gt;xdebug获取到开发者IP地址后，通过IP及IDE暴露的9000接口，与IDE建立连接，并进行后续通信&lt;/li&gt;
        &lt;li&gt;发起URL请求的机器与IDE必须属于同一IP(即同一台机器)&lt;/li&gt;
        &lt;li&gt;本方式适合IP变化频繁，或多个开发者共享同一台Web服务器等情况的使用&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-322方式二：根据指定IP连接IDE设置xdebugremotehostxxxx&quot;&gt;3.2.2方式二：根据指定IP连接IDE(设置&lt;code&gt;xdebug.remote_host=x.x.x.x&lt;/code&gt;)&lt;/h4&gt;
    &lt;p&gt;xdebug连接IDE的方式二的时序图如下：&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-f961516c23507d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-f961516c23507d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;说明：&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;以上两种连接方式，方式一优先级高于方式二。如下方配置所示，第二行配置将被忽略：&lt;br /&gt;xdebug.remote_connect_back = 1 &lt;br /&gt;xdebug.remote_host = x.x.x.x&amp;nbsp;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;如需使用方式二（固定IP），需将&lt;code&gt;xdebug.remote_connect_back&lt;/code&gt;置为0&lt;/li&gt;
        &lt;li&gt;第二种连接方式，适合开发机IP基本不变的开发者使用&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3 id=&quot;xdebug调试原理与实践-33PHPStrom配置xdebug调试&quot;&gt;3.3 PHPStrom配置xdebug调试&lt;/h3&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-331方式一（xdebugremoteconnectback1）的配置&quot;&gt;3.3.1 方式一（xdebug.remote_connect_back = 1）的配置&lt;/h4&gt;
    &lt;p&gt;xdebug.ini中的设置：&lt;/p&gt;
    &lt;pre class=&quot;hljs bash&quot;&gt;&lt;code class=&quot;bash&quot;&gt;zend_extension = xdebug.so &lt;br /&gt;&lt;/code&gt;xdebug.remote_enable = 1 ;开启远程调试 &lt;br /&gt;xdebug.remote_autostart = 1 ;自动启动调试 &lt;br /&gt;xdebug.remote_mode = req ;通过请求触发调试，另一种方式jit：遇到错误时触发 &lt;br /&gt;xdebug.remote_connect_back = 1 ;使用方式一连接 &lt;br /&gt;xdebug.remote_port = 9000 &lt;br /&gt;xdebug.remote_handler = dbgp ;xdebug与PHPStorm的debug协议 &lt;br /&gt;xdebug.idekey = &lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(42,161,152);&quot;&gt;&quot;PHPSTORM&quot;&lt;/span&gt;&lt;span style=&quot;font-family: Arial , Helvetica , FreeSans , sans-serif;;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/pre&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-332方式二（xdebugremotehostxxxx）的配置&quot;&gt;3.3.2 方式二（xdebug.remote_host = x.x.x.x）的配置&lt;/h4&gt;
    &lt;p&gt;xdebug.ini中的设置：&lt;/p&gt;
    &lt;pre class=&quot;hljs bash&quot;&gt;&lt;code class=&quot;bash&quot;&gt;zend_extension=xdebug.so &lt;br /&gt;xdebug.remote_enable = 1 &lt;br /&gt;xdebug.remote_autostart = 1 &lt;br /&gt;xdebug.remote_mode = req &lt;br /&gt;xdebug.remote_connect_back = 0 ;关闭方式一连接 &lt;br /&gt;xdebug.remote_host = 192.168.35.103 ;使用方式二连接 &lt;br /&gt;xdebug.remote_port = 9000 &lt;br /&gt;xdebug.remote_handler = dbgp &lt;br /&gt;xdebug.idekey = &lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(42,161,152);&quot;&gt;&quot;PHPSTORM&quot;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;
    
    &lt;h4&gt;3.3.3 设置未生效？问题排查&lt;/h4&gt;
    
    &lt;p&gt;有时我们已经按照教程设置好了一切，但打开IDE的断点调试，仍然没有任何效果。&lt;/p&gt;
    &lt;p&gt;我们会疑惑，程序为什么没有在运行到断点后暂停下来？&lt;span&gt;除了检查各种配置是否正确，开发者还有哪些工具、信息可以拿来推断到底是哪一部分出了问题？&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;其实知道了上述连接原理后，我们可以通过TCP工具监听9000端口上的网络通信，通过通信的内容，我们可以把问题细化到由于以下原因，导致的xdebug调试未生效，进而逐个解决问题：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;9000端口的网络连接并未发起，则推断是xdebug端的配置有问题，有可能是：1）xdebug设置有误；2）xdebug扩展未加载；3）PHP-fpm未启动；4）Nginx未启动&lt;/li&gt;
        &lt;li&gt;9000端口上发生了网络连接，但很快断掉了。有可能是：1）IDE的debug工具并未开启导致IDE的&lt;span&gt;9000&lt;/span&gt;端口不可用；2）IDE的端口设置不是9000；3）Web服务器并不能与IDE所在网络的指定端口通信&lt;/li&gt;
        &lt;li&gt;9000端口上发生了密密麻麻的网络通信。。。额，这个应该是IDE没有打断点吧？&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;span&gt;在这之前，我们需要打开IDE的debug开关，在代码入口第一行打上断点，然后&lt;/span&gt;&lt;span&gt;SSH进入Web服务器所在机器（通常是虚拟机，或docker容器），通过&lt;/span&gt;&lt;code&gt;tcpdump&lt;/code&gt;&lt;span&gt;工具进行问题排查。&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;tcpdump是TCP层通信的监听工具，由于DBGp协议是建立在TCP之上的应用层协议，所以可以通过更底层的工具监听DBGp协议的通信，上方截图中的DBGp协议局部通信内容，就是用tcpdump工具抓取的。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;由于tcpdump一次只能监听一个网卡上的网络通信，所以需要通过&lt;/span&gt;&lt;code&gt;ifconfig&lt;/code&gt;&lt;span&gt;命令获取Web服务器的IP经由的网卡&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;通过&lt;code&gt;ifconfig&lt;/code&gt;命令可以确定Web服务器的IP经由的网卡为&lt;code&gt;eth1&lt;/code&gt;。下面开始debug环节&lt;/p&gt;
    &lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
        &lt;div class=&quot;image-container&quot;&gt;
            &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-403848534eb9bb18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-403848534eb9bb18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;p&gt;&amp;nbsp;&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-333深度自检：在PHPStrom中入口代码第一行打断点，为什么代码未在断点处暂停&quot;&gt;3.3.4 深度自检：在PHPStrom中入口代码第一行打断点，为什么代码未在断点处暂停&lt;/h4&gt;
    &lt;p&gt;这种情况是大部分新手和新安装xdebu后的开发者会遇到的问题。遇到这种问题，该如何排查呢？&lt;/p&gt;
    &lt;p&gt;1）确定xdebug是否向PHPStrom发起网络连接。如果没有，则需要依次检查xdebug的设置是否正确。&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;在Web服务器命令行输入如下命令（注意网卡名称eth1应情况而异），开始监听xdebug在9000端口上的通信：&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;输入上述命令后，在开发机中访问URL，然后回到Web服务器命令行，查看是否有网络请求发起。如果命令行没有任何输出，则说明xdebug配置有误。请开始&lt;b&gt;步骤A自检&lt;/b&gt;：&lt;br /&gt;
            &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
                &lt;li&gt;xdebug扩展是否加载？在&lt;code&gt;phpinfo()&lt;/code&gt;中查看即可确定&lt;/li&gt;
                &lt;li&gt;xdebug设置是否按上方给出的两份设置正确填写？在&lt;code&gt;phpinfo()&lt;/code&gt;中也可以看到这些信息，请查看每项设置是否有多余字符出现？&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;2）在完成&lt;b&gt;步骤A自检&lt;/b&gt;后，重复1的操作，继续监听&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;。命令行输出结果如下图所示。其中&lt;span&gt;192.168.33.10&lt;/span&gt;的机器为Web服务器，&lt;span&gt;192.168.33.1&lt;/span&gt;的机器为IDE所在开发机，从图中信息可以看出Web服务器主动向开发机上的9000端口发起连接请求，但开发机拒绝了该连接请求（&lt;code&gt;Flags [R.]&lt;/code&gt;)&lt;/p&gt;
    &lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
        &lt;div class=&quot;image-container&quot;&gt;
            &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-5893f92aae47e33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-5893f92aae47e33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;遇到这种情况，请开始&lt;/span&gt;&lt;b&gt;步骤B自检&lt;/b&gt;：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;curl -v &lt;a rel=&quot;nofollow&quot;&gt;telnet://192.168.33.1:9000&lt;/a&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;。如果返回结果有&lt;/span&gt;&lt;em&gt;couldn't connect to host&lt;/em&gt;
        &lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;，则说明xdebug并不能使用给定IP端口与IDE通信。&lt;br /&gt;造成这的原因可能有：网络不可达（是否能ping通，如无法ping通，请换用其他可ping通的开发机IP，毕竟一个开发机可能有多个IP，最后使用方式二固定IP设置即可）；&lt;br /&gt;IDE端口设置并不是9000；&lt;br /&gt;或者IDE并未打开调试模式，如何打开请看下图&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-72da0495368975aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-72da0495368975aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;3）步骤B自检查完成后，再次在Web服务器命令行监听9000端口的通信：&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;。这一次，大量的连接信息开始输出，恭喜你，xdebug已经设置好了&lt;/p&gt;
&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-f57169afc6c70fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-f57169afc6c70fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;4）PHPStrom中接收到xdebug的网络连接后，如何设置与WebServer上代码的一一匹配&lt;/p&gt;

&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-0c8d5d9828b0fca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;总结：&lt;/b&gt;遇到xdebug设置相关的问题，最重要的是了解debug底层通信协议和原理，再通过TCP/IP抓包工具(比如tcpdump）进行问题排查及定位。通过上述步骤的排查，应该可以定位无法debug原因，并最终成功使用xdebug调试代码了。祝顺利~&lt;/p&gt;

&lt;/div&gt;</content><author><name></name></author><summary type="html">1. 前言 世界上有两种人：一种了解debug工具的好处，另一种则反之。 那么debug工具到底有哪些优点呢？ 1）在日常开发中洞悉大型架构的流程及设计； 2）在日常开发中快速debug，省时省力，更能在debug过程中掌握程序运行流程及上下文； 3）debug驱动型开发习惯的养成 在PHP语言中有个叫xdebug的扩展，是业界最常用的PHP debug工具之一。xdebug有很多实用的特性，但本文只着重介绍远程调试这一特性的使用。 注意： 本文提到的IDE，意即：集成开发环境，例如PHPStrom、Eclipse就是很常见的IDE PHPStrom和IDE在本文中可能会被混用，但他们都代表PHPStrom 2. xdebug特性 var_dump展示优化&amp;nbsp;&amp;gt;link PHP输出notice、error等信息时，调用栈可定制化展示&amp;nbsp;&amp;gt;link 函数调用报告&amp;nbsp;&amp;gt;link 代码覆盖率报告&amp;nbsp;&amp;gt;link 程序分析报告（profiler）&amp;gt;link 远程调试。本篇内容将着重介绍这一功能。如果你想获取有关如何配置可多人同时调试一台Web服务器的DBGp代理信息的话，也推荐你读完本文，这将对你后续的代理配置有一定帮助。 3. 远程调试 xdebug的远程调试默认的通信协议为DBGp协议，它是基于XML文本传输的应用层协议，用于程序语言与IDE间的调试通信。 DBGP协议规定：IDE向程序的调试器发送的内容为ascii命令，调试器向IDE发送的内容为XML数据</summary></entry><entry><title type="html">轻文本编辑器 vs 重型IDE</title><link href="http://localhost:4000/2017/10/10/%E8%BD%BB%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8_vs_%E9%87%8D%E5%9E%8BIDE.html" rel="alternate" type="text/html" title="轻文本编辑器 vs 重型IDE" /><published>2017-10-10T00:00:00+08:00</published><updated>2017-10-10T00:00:00+08:00</updated><id>http://localhost:4000/2017/10/10/%E8%BD%BB%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8_vs_%E9%87%8D%E5%9E%8BIDE</id><content type="html" xml:base="http://localhost:4000/2017/10/10/%E8%BD%BB%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8_vs_%E9%87%8D%E5%9E%8BIDE.html">&lt;blockquote&gt;
  &lt;p&gt;注：本文所说的重型IDE，例如开发PHP用到的PHPStorm、开发Java用到的Eclipse等IDE，有别于类似Sublime Text这样的轻型文本编辑器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在刚开始学习和使用PHP，乃至在学习和使用python、js的时候，我都在使用Sublime Text(以下简称SbText)进行编码工作。相较于每次打开重型IDE时”漫长”的等待时间，SbText一类编辑器却可以做到秒开！
于是新手便会有一个错觉，以为同样的工作量，使用重型IDE会花费更多时间。&lt;/p&gt;

&lt;p&gt;可是后来我自己实践下来的经验是：重型IDE的协同开发效率更高。注意这里提到的一个关键词：协同开发，它指的是团队间的共同开发，有别于独自开发一个项目。&lt;/p&gt;

&lt;p&gt;为什么在协同开发时，重型IDE的效率更高呢？你可能会开始思考：下列的功能明明轻型IDE也是可以支持的啊&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;代码提示及自动补全&lt;/li&gt;
  &lt;li&gt;语法高亮&lt;/li&gt;
  &lt;li&gt;拼写检查&lt;/li&gt;
  &lt;li&gt;代码格式化工具&lt;/li&gt;
  &lt;li&gt;断点调试&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在一个独立开发者进行项目开发时，上面这些功能貌似已经够用了。但是在协同开发的场景下，重型IDE许多特性是轻型IDE所不具备的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口文档自动解析及提示。轻型IDE往往不具备这样的特性，例如：
    &lt;ul&gt;
      &lt;li&gt;想要查看一个接口参数的定义，后者往往要进入到这个文件中的接口位置处才能看到。&lt;/li&gt;
      &lt;li&gt;再者，如果这个接口已经被声明为已废弃或已删除，说明接口开发者不希望外界继续使用本接口了。但轻型IDE是不会提示到的，如果此时开发者恰好是复制的其他部分的代码，就很有可能继续用到这些已经废弃的接口，从而让团队协作的效率变得低下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;接口调用的动态提示及检测。轻型IDE一般只提供程序语言无关的文本编辑功能，但是涉及到程序语言相关的内容检测时，它的短板便显现出来。你在调用某个对象的某个接口时，下面这些检查会大幅提升你的编码效率：
    &lt;ul&gt;
      &lt;li&gt;这个接口是否存在&lt;/li&gt;
      &lt;li&gt;你调用接口传入的参数类型、参数个数是否正确&lt;/li&gt;
      &lt;li&gt;你所定义的参数的返回值类型是否和接口声明的一致&lt;/li&gt;
      &lt;li&gt;阅读代码时，之前老代码相关的调用是否正确&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;强大且丰富的断点调试功能。我之前在一个技术分享上曾听到这样一种观点：开发项目时如果你连断点调试工具都没有配置好，那么基本可以判断：1) 你的debug效率将会极其低下；2) 你对项目的整体架构的了解将不会有很大增长（大牛请忽略这样一种论断）。轻型IDE的debug功能一般都很精简，此处推荐重型IDE的debug功能&lt;/li&gt;
  &lt;li&gt;阅读代码时的展示一致性。你能看到的IDE为你做出的通用提示、警告，其他开发者也会看到。这一方面会敦促你编写不会让IDE出现烦人提示的代码(一定意义上更规范的代码)，另一方面也督促你，要求其他开发者不要写类似的代码。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Tech" /><summary type="html">注：本文所说的重型IDE，例如开发PHP用到的PHPStorm、开发Java用到的Eclipse等IDE，有别于类似Sublime Text这样的轻型文本编辑器</summary></entry><entry><title type="html">写在离职季，记录我的第一份编程工作</title><link href="http://localhost:4000/2015/06/28/what-i-have-learned-from-this-job-now.html" rel="alternate" type="text/html" title="写在离职季，记录我的第一份编程工作" /><published>2015-06-28T00:00:00+08:00</published><updated>2015-06-28T00:00:00+08:00</updated><id>http://localhost:4000/2015/06/28/what-i-have-learned-from-this-job-now</id><content type="html" xml:base="http://localhost:4000/2015/06/28/what-i-have-learned-from-this-job-now.html">&lt;h2 id=&quot;一只编程菜鸟只为找一份编程的工作&quot;&gt;一只编程菜鸟，只为找一份编程的工作&lt;/h2&gt;
&lt;p&gt;13年7月份毕业，听从家里人的安排，去了本省的一家国企工作，直接被派去到东北的项目基地实习。因为会和技术老外讲英语，还和第三方外包人员一起合作调试好了他们承接的电气化自动排水项目的程序，基地领导青睐有加，想把我留在那里。我考虑了一下拒绝了。等工作到12月份的时候，基本已经确定，这份工作不是我想要的。遂瞒着家里人和领导请了一个月的病假，从东北坐了33个小时的火车来到江南，杭州。当时已是冬季，但下火车后仍然觉得“春风拂面”，比起东北让人冻得骨头疼的冷，杭州的天气温和到简直像是春天。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;投靠到朋友那里，开始了投简历、找工作的经历。因为大三才开始自学编程，基础不牢，项目经验少得可怜。找了快一个月的时间，却只有零星的几次线上交流、笔试的机会，offer始终无果。眼看着一个月的假就要耗完，马上就要春节了，工作依然没有着落，心里开始灰心。直到在准备离开杭州的前两天，才终于有了一次面试的机会，这就是目前的这份工作的起点。这是一家小公司，做海外代购的，同时也在做商品聚合平台。聊了一个多小时，人家觉得还不错，遂口头答应了offer。于是终于在离开杭州的那天，收到了这家公司的正式offer。这个offer就像一根救命稻草一般，没有经历过之前的绝望，就根本体会不到这个offer带来的激动和心安：如果找不到工作，就只能回原来的单位上班了，而当初是做了死也要死外边的打算的。&lt;/p&gt;

&lt;p&gt;因为这是收到的唯一一个offer，所以在回去后的第三天就接受了这份工作。所幸可以安安心心地过一个年，年后去上班。&lt;/p&gt;

&lt;h2 id=&quot;初入职场菜鸟快快长大&quot;&gt;初入职场，菜鸟快快长大&lt;/h2&gt;
&lt;p&gt;年后2月份来上班。最开始的工作只是很基础的用PHP索取数据渲染至HTML并输出的过程，还要经常使用Javascript完成前端动态交互。PHP和Javascript之前都没怎么接触过，所以需要一步步学习。&lt;/p&gt;

&lt;p&gt;其实只要使用过函数式编程的语言（如C）便不难发现，PHP语言其实很好入门和进阶。但是Javascript则完全是不一样的逻辑，因为是EventDriven模式的，有着层层的回调和scope，而且代码执行流程也不是从上到下式的。所以在刚开始接触、使用JS的时候一定会遇到奇怪无比的坑。不过当你最终从坑里爬出来的时候，整个世界便又是另一番景象了。在这个过程中花时间学习和阅读Javascript相关的内容和资料的时间比正牌的后端PHP语言还要多，其实刚开始会有疑问，PHP毕竟是热门的后端语言，而JS只是很小众的前端交互助手而已，值得这样投入时间吗？在后来的工作中，以及nodejs火热起来之后我发现这些投入还是非常值得的，因为JS真的是我接触的第一个可以利用客户端的计算资源的语言，因为你用JS写好一个应用之后，剩余的运算执行是在客户端完成的，它使用的完全是客户端的计算资源！&lt;/p&gt;

&lt;p&gt;现在回想一下，在编程工作起步的时候，最对的，也最受益无穷的选择便是坚持使用、查看英文资料。这真的是一个一本万利的事情。当时访问最多的编程问答网站就是Stackoverflow了。也许对一个有一定积累的人来说SO并没有多少更高的价值，但对于像我这样的菜鸟来说，SO简直就是高纯度的知识海洋。很多东西是对比着才能体会到其间的巨大差别的，当我总是查看英文的技术内容时，再回过头来偶尔看一下中文的问答或博客，简直如啖甘蔗：虽然看着内容很多，其实真正“香甜的甘蔗汁”只有那么一丁点，其余大部分全是废渣。&lt;/p&gt;

&lt;p&gt;因为工作压力并不是很大，所以还利用晚上的时间参加了一门&lt;a href=&quot;http://blog.lyfing.co/2014/07/06/using-js-to-build-a-spaceship-floating-in-the-outer-space.html&quot;&gt;Python公开课&lt;/a&gt;的学习，一来可以练习英语（全英语视、听、作业），二来可以在学习编写小游戏的同时练习Python语言。就这样在持续学习了几个月后，自己在Python方面的实践经验也开始多起来。事实证明，很多看似无用、却由兴趣驱使着去做的事情，往往在后来可以大有所用，此事待后面详述。&lt;/p&gt;

&lt;p&gt;日子就这样平淡着过去，转眼已是立夏。这时候公司开始想要做一款浏览器插件(Extension)，主要用来快速采集用户HTML中的产品信息，具体内容为跟用户所见的HTML交互并在用户人工识别页面信息后，友好地提取其中的产品信息，最后以表单的形式提交至我方服务器。这个&lt;a href=&quot;https://chrome.google.com/webstore/detail/%E6%B5%B7%E6%B7%98%E5%AE%9D-v2%E9%9D%9E%E7%9D%BF%E8%8E%AB%E6%80%9D/obnbgneldjmmpgkbnnbiiinijmiclpaa?hl=zh-CN&quot;&gt;扩展&lt;/a&gt;在立项的时候是由另外一个同事负责开发的，但当时我意识到：1) 这是一个极好的了解浏览器API和练习用Javascript做App的机会；2) 那个同事的技术在我看来不足以做出我认为足够酷炫、友好的交互。我便先跟那位同事交流了我想独担这个任务的想法，取得他的同意后我向Boss主动请缨，Boss也欣然答应了。于是我接下了这个任务，开始了为期一个月的JSApp的编写工作。&lt;/p&gt;

&lt;p&gt;JSApp的实现过程中最大的收获之一是接触到设计合理、博大精深的Chrome API。一直以来都以为Chrome只是快、好用而已，从未想到它竟然有如此多分层合理、设计合理的对外接口，简直就像是一个小型的操作系统。俗话说得好，经常使用设计良好的API，人生逼格也会静默升级呢(kidding)。也开始因为开发需要而接触到很多安全方面的issues，例如iFrame和它的父窗口之间只能发消息，但不能访问父窗口内的资源(window scope variables，like window.document)，例如&lt;a href=&quot;/2014/06/28/upload-browser-side-resources-by-using-xhr.html&quot;&gt;跨域访问&lt;/a&gt;限制（虽然ChromeExtension运行空间直接允许跨域访问），例如&lt;a href=&quot;https://developer.chrome.com/apps/contentSecurityPolicy&quot;&gt;content security policy&lt;/a&gt;等。有时候会被这些看似太过苛刻的限制弄得f&lt;strong&gt;&lt;em&gt;这f&lt;/em&gt;&lt;/strong&gt;那的，这时候便会去试着了解一下他们这么做的原因或者好处。一来有助于缓解心中的”仇恨”(kidding)，二来也可以多学些东西。&lt;/p&gt;

&lt;p&gt;JSApp实现过程中另一大收获便是Javascript的应用水平大大提高，开始逐渐喜欢上这门语言（有时候甚至会选择用它来练习算法）。在慢慢熟悉了JS的scope和回调之后，开始将一个个业务逻辑封装到独立的scope中，然后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Publish/Subscribe&lt;/code&gt; Event&amp;amp;Msg-Driven的方式来连通各个scope，并驱动程序执行。这样做的好处有：1) 每个scope变得像是面向对象的类，封装了细节和实现; 2)因为使用消息驱动，所以代码解耦实现起来相对轻松。当然也是有坏处的，消息多了容易串，所以专门建立了一个manifest文件来快速查找、管理、记录这些消息/事件。&lt;/p&gt;

&lt;p&gt;JSApp在完成发布后，Boss大加赞赏。对于一个刚开始只是做后端PHP开发的人员来说，出色地完成前端JSApp的实现也算是超出Boss的预期了。&lt;/p&gt;

&lt;p&gt;Chrome扩展完成后，除了定期的维护升级外，基本就是日常的PHP端的HTML实现的工作分担一些，这样下来算是又闲下来了。我这人一旦闲下来就又开始不安分了。因为我们网站每天也有一万左右的访问量，所以有机会收集用户的请求信息。&lt;/p&gt;

&lt;p&gt;网站后台当时有一个用户实时在线页面，可以查看哪些用户是最近登录的（实时在线只是个噱头，是根据session时间模拟的，毕竟HTTP无状态），也可以看到来自世界各地的用户请求。当时我突然想，要是能把我们客户在世界各地的分步情况实时地在一张平面的世界地图上展示出来，那该有多酷呀。说干就干，我利用业余时间开始做技术积累：用websocket实现服务器与客户端的实时通信，用python搭建websocket服务器，客户端直接使用JS(客户端需要支持websocket功能)；地图使用谷歌的，客户的访问IP转地理位置使用新浪的IPService接口，最后虽然做出来的样子不是很美观、也只能搭着梯子访问，但也算是达成目标了。&lt;/p&gt;

&lt;p&gt;接下来就是公司技术博客的搭建了。因为公司运行的项目也有四年之久了，但却从没有一个比较系统的地方来介绍、讨论公司各个项目的架构、细节，以及服务器运维方面的东西，所以我就利用业余时间在我们公司的内网服务器上搭建了这个博客平台(&lt;a href=&quot;http://ww1.sinaimg.cn/large/6480dca9gw1etmhyd79i8j20k40l6jvv.jpg&quot;&gt;截图&lt;/a&gt;，并邀请同事在上面分享日常的开发维护心得。&lt;/p&gt;

&lt;h2 id=&quot;人事遽变承担半边天&quot;&gt;人事遽变，承担半边天&lt;/h2&gt;

&lt;p&gt;就在我过着按部就班毫无压力的日子的时候，公司却突然发生了三个月内的第二次人事遽变。第一次人事遽变，因为还有有过多年开发经验的同事扛着，也平稳度过了，然而第二次人事变动的主角就是这位同事。他要一走，说真的公司剩下的人里再没有一个能扛起这么多事情了：开发服务器的运维，生产环境十几台服务器的运维，网络爬虫系统的运维，网络搜索系统的运维，Python后端数据接口服务器的运维。当时一下子感觉天都要塌下来了！事实上后来和老板聊天时他说道，当时他已经开始考虑要使用外包了，他也根本没想到不起眼的我可以力顶压力，在把这些东西都一一搞定了。当然这是后话。&lt;/p&gt;

&lt;p&gt;这位同事在半个月后就要离职，他当时也考虑过谁来接手项目的问题。当时公司其他搞开发的同事有用Python搞数据接口的，有用PHP搞前端页面实现和交互的。虽然他们有的有两年开发经验，但都是专注于自己的领域，在其他方向并没怎么拓展。而我恰恰在刚来的时候搞PHP页面实现和交互，在之后上Python公开课做过小项目(业余锻炼派上用场了)，再加上我为公司内网Linux服务器升级PHP及其扩展、搭建TODO App以及博客平台的经验，这位同事便推荐由我这个入职5个月的新人来接手这个项目，老板也是无可奈何地答应了（毕竟我们剩下的人中再无全能型技术人才了）。&lt;/p&gt;

&lt;p&gt;而真正的压力、挑战和技术成长也是从这里开始。&lt;/p&gt;

&lt;p&gt;首先是接手Python端数据接口项目。项目概述：组织内部自由业务，并为PHP提供Restful JSONFormat API。这个项目最大的挑战倒不是技术层面的，而是在内部业务方面既要知晓细节又要把控全局，那就没什么好说的，花大量时间阅读项目源码，理清脉络，在脑海中不断描述和完善整体结构。这个挑战持续了大概有两个月（和其他挑战并行），等到终于把大部分代码读过，又对项目使用的HTTP框架Flask有了进一步了解之后，就再无压力了。&lt;/p&gt;

&lt;p&gt;接着是网络爬虫这块。项目概述：用Python脚本+Phantomjs解析HTML中的产品信息，用Redis做缓存，用HTTP在业务服务器和下载伺服器之间交换抓取任务和抓取到的产品信息。这里边最痛苦的莫过于一个个独立的任务队列了。队列任务流程：业务触发新的抓取请求，请求被投入抓取请求队列(业务服务器)；上步队列消费者索取下载请求，将其提交给下载伺服器接口；下载伺服器接收下载请求，将其放入待抓取队列；上步队列消费者索取请求，解析请求对应HTML中的产品信息，将解析所得产品信息投入信息回传队列；上步队列消费者索取产品信息，将其回传(提交)至业务服务器接口（流程完）。这里边的挑战有很多，1是队列很多，容易挂掉，所以用&lt;code class=&quot;highlighter-rouge&quot;&gt;supervisor&lt;/code&gt;来保证队列生产消费者持续运行；2是由于队列过多带来的接口、流程复杂度的提高，因为项目一直也没有写测试代码，所以一个改动导致的bug很容易影响全盘的稳定运行。也是慢慢体会到没有测试代码所带来的代码改动时心里的没底以及随着改动带来的高额的人工debug的成本。不过好在各个环节都出几遍问题，自己再给调试好之后，整个项目的流程就彻底了然于胸了。在这个过程中稍微改动了一下用Redis做的队列的实现逻辑，为我们开发者提供了一些HTML内容索取接口和缓存服务，后期就只剩维护了。&lt;/p&gt;

&lt;h2 id=&quot;力顶压力独揽全局&quot;&gt;力顶压力，独揽全局&lt;/h2&gt;
&lt;p&gt;接下来就是跟ElasticSearch（ES）相关的最后一个让人大头的项目，ES是一个可以高效率全文检索的搜索引擎。我在接手这个项目的时候使用的是v0.92版，对ES的接口用的PHP的第三方客户端。这个搜索引擎布置在生产环境，由两个物理节点组成了Cluster。但因为数据量大（800万+条信息）所以占用系统内存很多（为它分配了一半的物理内存）；而且每条信息排序的时候需要即时计算score，所以一有搜索请求过来，CPU的压力就会上来一点；再加上这个版本本身的bug导致它运行不够稳定，通常隔几天就会崩溃。当时我最怕的就是它崩溃了，本身手头上的开发任务就多，其他项目又都需要接手维护或管理，所以基本无心再顾忌这个搜索引擎了，只求使用上任负责人交给的死办法重启维护就行了。然而经过几个回合的崩溃、重启之后，我终于受不了了，开始慢慢安排，计划用当时最新的v1.4.1&lt;strong&gt;无缝替换&lt;/strong&gt;掉线上运行的不稳定版本。接下来就是：用工作之余的时间不厌其烦地阅读有点不清晰的官方文档，在测试环境中下载、配置、安装和运行新版本，换用Python语言来使用ES更底层且灵活的API，为PHP写新的应用接口（Python提供），重建每条document在ES中的的检索/存储逻辑，把score的运算由即时分散到平时…所有这些准备工作花去了我一个月左右的业余时间，终于，最后成功地按照我的预期，在线上无缝地替换掉了旧版的ES。&lt;/p&gt;

&lt;p&gt;从此时起，我便成为了公司里第一个也是唯一一个对当时所有项目都了然于胸的人！那种刚开始在大森林里只是负责种树苗，最后却得以爬上高山去俯瞰整个森林的感觉，真的太妙了，所谓“一览众山小”说的就是这种感觉。&lt;/p&gt;

&lt;p&gt;也是从这时候起，Boss对我更加器重了（后来他还把他两室一厅的房子给我住，我住一间，另一件房间则允许我租出去，租金归我），自己做起其中的每个项目来，包括做出各种决策，也都更有方向感和把握了。&lt;/p&gt;

&lt;h2 id=&quot;人事萧条无心再战&quot;&gt;人事萧条，无心再战&lt;/h2&gt;
&lt;p&gt;然而从今年年初开始，随着公司开发人员的人才流失，到最后，基本就只剩我一个光杆司令了。Boss当时有些着急，直接允诺了不少的公司期权给我。然而我继续呆在这里，在可预见的未来，已经没有任何技术成长空间了。其实我最初来大城市的目的就是像牛人学习，结果到最后总是自己在推着自己向高处走，我觉得这样很不好，怕自己越来越狭隘。所以于最近（2015.06.28）向老板提交了辞职信，老板看我去意已决，再加上之前交流的时候有透露过这方面的想法，他也就没有再留我。当然公司这么多项目还是需要有人来接手的，所以我会再待一个月等人来接手。&lt;/p&gt;

&lt;h2 id=&quot;心怀感恩重新上路&quot;&gt;心怀感恩，重新上路&lt;/h2&gt;
&lt;p&gt;其实如果没有这份工作提供给我一个进入编程领域的入口，我是不可能有今天的。我记得刚开始就是这种态度，老板在我刚开始进公司的时候就握着我的手说，谢谢你，加入我们！我当时的回答，也是现在的回答，是：也谢谢你，给我提供这样一个平台和机会。&lt;/p&gt;</content><author><name></name></author><category term="Tech" /><category term="总结" /><summary type="html">一只编程菜鸟，只为找一份编程的工作 13年7月份毕业，听从家里人的安排，去了本省的一家国企工作，直接被派去到东北的项目基地实习。因为会和技术老外讲英语，还和第三方外包人员一起合作调试好了他们承接的电气化自动排水项目的程序，基地领导青睐有加，想把我留在那里。我考虑了一下拒绝了。等工作到12月份的时候，基本已经确定，这份工作不是我想要的。遂瞒着家里人和领导请了一个月的病假，从东北坐了33个小时的火车来到江南，杭州。当时已是冬季，但下火车后仍然觉得“春风拂面”，比起东北让人冻得骨头疼的冷，杭州的天气温和到简直像是春天。</summary></entry><entry><title type="html">我在2015年读过的编程相关的资料</title><link href="http://localhost:4000/2015/03/18/the-programming-related-materials-i-have-read-in-2015.html" rel="alternate" type="text/html" title="我在2015年读过的编程相关的资料" /><published>2015-03-18T00:00:00+08:00</published><updated>2015-03-18T00:00:00+08:00</updated><id>http://localhost:4000/2015/03/18/the-programming-related-materials-i-have-read-in-2015</id><content type="html" xml:base="http://localhost:4000/2015/03/18/the-programming-related-materials-i-have-read-in-2015.html">&lt;p&gt;平时会读一些技术博客什么的，但都是零零星星不成体统的。所以在此新建一篇博客来专门记录这些自己读过的编程相关的资料。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;时间：02.07&lt;br /&gt;
资料：《iptables防火墙原理详解》 | by seanlook | http://segmentfault.com/blog/seanlook/1190000002540601&lt;br /&gt;
评论:对数据包通过一个节点时的处理流程有了全面的了解，里面的图片很不错。再配合着看完网上的《2小时玩转iptables企业版.ppt》，终于有了俯瞰整个数据包走向流程的视野。&lt;/p&gt;

&lt;p&gt;时间：02.08 ~ 02.09 &lt;br /&gt;
资料：《What Every Programmer Should Know about Memory?》 | by Ulrich Drepper | http://www.akkadia.org/drepper/cpumemory.pdf&lt;br /&gt;
评论：论文篇幅太长，再者涉及内容偏重硬件设计，所以暂时搁置，有时间再读。&lt;/p&gt;

&lt;p&gt;时间：03.03&lt;br /&gt;
资料：《白话经典算法系列之六 快速排序 快速搞定》 | by MoreWindows | http://blog.csdn.net/morewindows/article/details/6684558&lt;br /&gt;
评论：精简地把快速排序的一种思路用精妙的“挖坑待种”的比喻表达了出来，看完并实验后发现这种思路下的快速排序的实现是如此简单！&lt;/p&gt;

&lt;p&gt;时间：03.10&lt;br /&gt;
资料：《白话经典算法系列之七 堆与堆排序》 | by MoreWindows | http://blog.csdn.net/morewindows/article/details/6709644/&lt;br /&gt;
评论：其实作为非科班出身的编程者，在做了很多表层的编程语言层面和公司业务层面的编程工作后，最基础的内功却几乎是空的。数据结构这一块一直是只对编程语言中的常见数据结构有接触，像更底层却很有意思的比如”堆”却几乎没接触过，所幸接触后发现至少堆结构还是很简单的。&lt;/p&gt;

&lt;p&gt;时间：03.17&lt;br /&gt;
资料：《What every web developer must know about URL encoding》 | by Stéphane Épardaud | http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding&lt;br /&gt;
评论：这是”编程人员应该知道的xxx”系列中的一篇，主要讲URL-Encoding的种种。其实看的时候更多的是共鸣（相比于其他资料带来的透彻感），因为这样的问题在自己搞开发的时候都已经考虑、验证过了。不过作者讲得更系统、全面一些，看完后至少开阔了眼界（看似乱码实则符合RFC规范的URL，url encode/decode在不同层级的服务上的处理情况如web-server层、编程语言层）&lt;/p&gt;

&lt;p&gt;时间：03.17&lt;br /&gt;
资料：《What Every Programmer Should know about Time》 | by EmilMikulic | https://unix4lyfe.org/time/?v=1 &lt;br /&gt;
评论：文章挺短的，还趁机看了一下其中提到的”leap seconds”和”Daylight saving”，还顺带回顾了一下两种用来计量时间的装置：石英钟和原子钟的原理。很喜欢文章中提到的一个观点：时间总是应该以Unix Timestamp的形式被保存起来，而不是”Y-m-D H:M:S”这种人类可读的方式，因为后者是表现层的事儿。&lt;/p&gt;

&lt;p&gt;时间：03.27&lt;br /&gt;
资料：《An Introduction To DOM Events》| by Wilson Page | http://www.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/&lt;br /&gt;
评论：最大收获是终于对着w3c的&lt;a href=&quot;http://www.w3.org/TR/DOM-Level-3-Events/eventflow.svg&quot;&gt;这张图&lt;/a&gt;把一个DOM Event的生命周期看懂了（之前尝试看了一次，模棱两可）。其次是琐碎的事了：了解了&lt;code class=&quot;highlighter-rouge&quot;&gt;func.bind()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;时间：06.12&lt;br /&gt;
资料：《Inside NGINX: How We Designed for Performance &amp;amp; Scale》| by OWEN GARRETT | http://nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/  &lt;br /&gt;
评论：很多架构解读型的文章，最生动和令人难忘的，大概都属随文展示出来的架构图了。这篇文章里列出了好几张非常不错的架构、流程图。它在拿自己的non-blocking设计和其他相对blocking的设计作对比时，举了个非常形象的例子：Web服务器和Web客户端的通信就像下棋一样，只不过Web服务器通常是一对多负责和很多客户端下棋。服务器可以为每个客户端分配一个棋手（blocking，每个线程/进程负责一个客户端），也可以只用一个棋手来同时跟若干个客户端轮询着下棋（non-blocking，现实中有真人1 vs 360同时进行的棋局哦http://t.cn/R2joHP0 ）。&lt;/p&gt;

&lt;p&gt;时间：06.25  &lt;br /&gt;
资料：《Thread Pools in NGINX Boost Performance 9x!》 | by VALENTIN BARTENEV | http://nginx.com/blog/thread-pools-boost-performance-9x/  &lt;br /&gt;
评论：整篇文章其实只是一个结果报告，Event-Driven-Handling，但是handle某些event时操作确实又是blocking的，怎么办？引入线程池。线程池一直都是用的各类语言自带的(java, python)，具体实现并不是很清楚，计划有时间了看一些线程池的实现的资料。&lt;/p&gt;

&lt;p&gt;时间：10.23&lt;br /&gt;
资料：《Visual Representation of SQL Joins》 | by C.L. Moffatt | http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins&lt;br /&gt;
评论：关系型数据库Join表的方式有哪些，每种join的使用结果如何？在对Mysql有了一定的业务层的使用经验后，再看这篇文章，觉得人家写的真是简洁而全面。&lt;/p&gt;</content><author><name></name></author><category term="资料" /><summary type="html">平时会读一些技术博客什么的，但都是零零星星不成体统的。所以在此新建一篇博客来专门记录这些自己读过的编程相关的资料。</summary></entry><entry><title type="html">MySQL技能二三事</title><link href="http://localhost:4000/2014/11/30/several-skills-about-mysql.html" rel="alternate" type="text/html" title="MySQL技能二三事" /><published>2014-11-30T00:00:00+08:00</published><updated>2014-11-30T00:00:00+08:00</updated><id>http://localhost:4000/2014/11/30/several-skills-about-mysql</id><content type="html" xml:base="http://localhost:4000/2014/11/30/several-skills-about-mysql.html">&lt;h1 id=&quot;其一-int10意欲何为&quot;&gt;其一: int(10)意欲何为&lt;/h1&gt;

&lt;p&gt;MySQL的Column-Type中的&lt;strong&gt;int&lt;/strong&gt;一类，不像其他Type如&lt;strong&gt;char&lt;/strong&gt;、&lt;strong&gt;varchar&lt;/strong&gt;是根据最大size来预置存储空间的，&lt;strong&gt;int&lt;/strong&gt;这一类的Column-Type所指定的size是作为显示宽度来存储的(涉及到size不足前端补零的场景-zerofill），它们所占用的实际空间大小是&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/integer-types.html&quot;&gt;固定&lt;/a&gt;的。所以想通过&lt;code class=&quot;highlighter-rouge&quot;&gt;int(10)&lt;/code&gt;来节省存储空间的想法是无效的。&lt;/p&gt;

&lt;h1 id=&quot;其二-index的prefix-length&quot;&gt;其二: index的prefix length&lt;/h1&gt;

&lt;p&gt;最近的一个项目需要存储互联网上的URL，并生成唯一ID，所以数据表里边会有&lt;code class=&quot;highlighter-rouge&quot;&gt;urlcmpr&lt;/code&gt;一栏&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;urlcmpr: 适当压缩过的url，用0、1代表http[s]，62进制的code代表hostname。示例：0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=379&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;当时的建表语句是这样的（其实项目用的是SQLAlchemy的ORM-Model，这里只是复现一下当时的情况）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE `urls` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `urlcmpr` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_urlcmpr` (`urlcmpr`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查看建好的表信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; DESC urls;
+---------+--------------+------+-----+---------+----------------+
| Field   | Type         | Null | Key | Default | Extra          |
+---------+--------------+------+-----+---------+----------------+
| id      | int(11)      | NO   | PRI | NULL    | auto_increment |
| urlcmpr | varchar(255) | YES  | UNI | NULL    |                |
+---------+--------------+------+-----+---------+----------------+
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;首先插入两条记录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insert into urls (urlcmpr) values 
  ('0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=0001'),
  ('0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=0002');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为我们已经为&lt;code class=&quot;highlighter-rouge&quot;&gt;urlcmpr&lt;/code&gt;建好了唯一索引，我们来试试重复插入一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;insert into urls (urlcmpr) values 
  ('0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=0001');
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不出所料，报错了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR 1062 (23000): 
Duplicate entry '0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-i'
for key 'idx_urlcmpr'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个原本也没什么，但由于下方已删除的那部分描述的缘由，我开始关注错误报告所反映的一个信息：&lt;code class=&quot;highlighter-rouge&quot;&gt;urlcmpr&lt;/code&gt;栏是255字符的，但据此建立的&lt;code class=&quot;highlighter-rouge&quot;&gt;unique-key&lt;/code&gt;却只有64字符的长度，这是怎么回事？&lt;/p&gt;

&lt;p&gt;其实后来才发现这个只是显示了&lt;em&gt;唯一Key&lt;/em&gt;的前64个字符而已，其实&lt;em&gt;唯一Key&lt;/em&gt;并不是只有64个字符。&lt;/p&gt;

&lt;s&gt;这里建唯一索引的目的是为了在重复误插入的时候被拒绝并报错，结果在程序准备正常插入的时候，MySQL也开始拒绝并报错了。但是事后当我试图重现这个问题时却发现，本段所描述的问题是不存在的！&lt;/s&gt;

&lt;p&gt;总之由于上面的一些误解（经过一步步查资料又自己推翻）就开始查资料了，查着查着找到了&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.1/en/create-index.html&quot;&gt;官方文档&lt;/a&gt;里的这样一段话（略有删减）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Indexes can be created that use only the leading part of column values, using col_name(length) syntax to specify an &lt;strong&gt;index prefix&lt;/strong&gt; length. Prefix lengths are given in characters… That is, index entries consist of the first length characters of each column value for CHAR, VARCHAR, and TEXT columns, and the first length bytes of each column value for BINARY, VARBINARY, and BLOB columns… using column prefixes for indexes can make the index file much smaller, which could save a lot of disk space and might also speed up INSERT operations.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;基本就是在说：chars类的column，在建立索引的时候会有&lt;strong&gt;index prefix length&lt;/strong&gt;一说，也就是只取本栏开头的若干个字符做索引（而不是本栏全部内容），这样做的好处是可以节省存储空间。&lt;/p&gt;

&lt;s&gt;虽然官方文档中没有说到为什么当一栏内容过大而且你没有设定它的index-prefix-length时，它的这个值会被设为64，但目前来看事实似乎就是这样的。&lt;/s&gt;

&lt;p&gt;如果是存储较长字符串(比如255 chars)的唯一索引，它的&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix-length&lt;/code&gt;该怎么定制（从节省存储空间的角度看）？用上面的例子做示例：&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;UNIQUE KEY 'idx_urlcmpr' ('urlcmpr'(100))&lt;/code&gt;&lt;br /&gt;
即在想要建立索引的栏名后面的括号中指定prefix-length。&lt;/p&gt;

&lt;p&gt;我们再来试试看&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE `urls2` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `urlcmpr` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `idx_urlcmpr` (`urlcmpr`(100))
) ENGINE=InnoDB DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;插入一段字符个数为100的string:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZab

Insert OK
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在上一段string尾部加一个字符&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;(101个字符长度)再试试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc 
ERROR 1062 (23000): Duplicate entry
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;无法插入了。上面的两步说明我们设定的唯一索引的&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix-length&lt;/code&gt;成功了，不过它也反映出一个问题：如果你要存储的内容在前半部分重复度很高，那么你的唯一索引可能会因为&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix-length&lt;/code&gt;过小而导致无法插入(如果两个string在开头的&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix-length&lt;/code&gt;以内是相同的)。因为确实已经遇到无法插入的问题了(500万+的URL），考虑了一下后我把&lt;em&gt;UniqueKey&lt;/em&gt;的限制给去掉了，改用普通Key: &lt;code class=&quot;highlighter-rouge&quot;&gt;KEY 'idx_urlcmpr' ('urlcmpr'(100))&lt;/code&gt;，是否重复则交由程序来判断，一来可以节省存储空间（Key也是要被存储记录的，不宜太长），二来防止将来有高度相似的URL无法插入。&lt;/p&gt;

&lt;h1 id=&quot;其三mysql搜索校验时的case--sensitive问题&quot;&gt;其三：MySQL搜索校验时的Case -Sensitive问题&lt;/h1&gt;

&lt;p&gt;由于业务需要，在存储这么多url的时候，每存储一条，还需要为它生成一个唯一码(unique code)。网上已经有不少优秀的唯一ID生成器了，但想要并入业务中还有些麻烦，再者业务要求很简单，保证code在单亿数量级以内唯一，于是自己就顺手写了一个62进制的&lt;a href=&quot;https://github.com/HelloLyfing/tiny-works/blob/master/HexConverter/HexCvter.py&quot;&gt;编码程序&lt;/a&gt;来生成unique code。由于code生成器是62进制的，如果是10个字符长的话，可表示的组合便是62的10次方，换算成10进制的话应该是一个近乎天文的数字了，唯一性是绝对保证了；程序还带了code+1功能，方便用来自增，有兴趣或有需要的朋友可以去看一下。&lt;/p&gt;

&lt;p&gt;言归正传，利用上面的code生成器产出的code是大小写敏感的，即&lt;code class=&quot;highlighter-rouge&quot;&gt;fooBar&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Foobar&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;fOOBaR&lt;/code&gt;分别代表着不同的10进制数值。新建一张表，把它们三个存进MySQL中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 新建表
CREATE TABLE `uni_code` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `code` varchar(10) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
Query OK, 0 rows affected (0.33 sec)

# 插入三条数据
INSERT INTO uni_code (code) VALUES ('foobar'),('fooBar'),('fOOBaR');
Query OK, 3 rows affected (0.03 sec)

# 查看刚刚插入的数据
mysql&amp;gt; SELECT * FROM uni_code;
+----+--------+
| id | code   |
+----+--------+
|  1 | foobar |
|  2 | fooBar |
|  3 | fOOBaR |
+----+--------+
3 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们再试着取出其中一条数据来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM uni_code WHERE code = 'foobar';
+----+--------+
| id | code   |
+----+--------+
|  1 | fooBar |
|  2 | fooBar |
|  3 | fOOBaR |
+----+--------+
3 rows in set (0.03 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;预期中的&lt;strong&gt;坑&lt;/strong&gt;出现了。我的code是大小写敏感的，但MySQL在查询校验的时候似乎忽略了这一点，直接把三条数据全部取出来了！&lt;/p&gt;

&lt;p&gt;当然你可以通过手动添加&lt;code class=&quot;highlighter-rouge&quot;&gt;Binary&lt;/code&gt;&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/charset-binary-op.html&quot;&gt;操作符&lt;/a&gt;将字符转换成字节来进行查询校验，或者指定&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/charset-general.html&quot;&gt;collation&lt;/a&gt;规则来进行查询校验&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; SELECT * FROM uni_code WHERE BINARY code = 'foobar';
+----+--------+
| id | code   |
+----+--------+
|  1 | foobar |
+----+--------+
1 row in set (0.00 sec)

mysql&amp;gt; SELECT * FROM uni_code WHERE code COLLATE utf8_bin = 'foobar';
+----+--------+
| id | code   |
+----+--------+
|  1 | foobar |
+----+--------+
1 row in set (0.09 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;但一来我用的ORM，使用原生SQL (关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;Binary&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Collate&lt;/code&gt;) 与使用ORM目的背离；二来四处滥用这些关键字会让程序代码混乱。最好能让MySQL在数据库层就完成大小写敏感的查询校验。&lt;/p&gt;

&lt;p&gt;查了查资料发现MySQL在查询校验的时候所使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;Collate&lt;/code&gt;规则集是有默认值的，正是这个规则集决定了字符比对的结果。那么&lt;code class=&quot;highlighter-rouge&quot;&gt;Collate&lt;/code&gt;是什么呢？&lt;/p&gt;

&lt;p&gt;在上面给出的&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/charset-general.html&quot;&gt;官方文档&lt;/a&gt;已经很好的解释了&lt;code class=&quot;highlighter-rouge&quot;&gt;Collate&lt;/code&gt;的作用，我在这里再赘述一二：&lt;/p&gt;

&lt;p&gt;数据库中有字符集&lt;strong&gt;charset&lt;/strong&gt;和规则集&lt;strong&gt;collate&lt;/strong&gt;一说，字符集自不必多说。规则集是&lt;strong&gt;在给定字符集上进行字符对比的规则&lt;/strong&gt;，比如大小写敏感否 (CI or CS)、&lt;code class=&quot;highlighter-rouge&quot;&gt;äöü&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;aou&lt;/code&gt;对等否等规则，每个字符集都有默认规则集。&lt;/p&gt;

&lt;p&gt;上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;... WHERE code COLLATE utf8_bin = ...&lt;/code&gt;就是指定了字符对比的规则集。这个规则集是大小写敏感的，它会覆盖默认的规则集。是的，MySQL中的每一个单元(Column、Table、Database)都可以有自己的字符集和规则集，我们通常只是指定字符集，MySQL则帮我们指定了该字符集对应的默认&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/charset-mysql.html&quot;&gt;规则集&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;这么一来就好办了，看来是MySQL为我指定了utf8编码下的默认规则集，而这个规则集在字符比对时是CI的。只要我们修改一下表(或者栏)的规则集，让它支持大小写敏感的比对就好了。&lt;/p&gt;

&lt;p&gt;我们先来看看&lt;code class=&quot;highlighter-rouge&quot;&gt;utf8&lt;/code&gt;的默认规则集，及可选规则集(下面内容可能会因版本、系统而异)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; show CHARACTER SET WHERE charset LIKE &quot;utf8&quot;;
+---------+---------------+-------------------+--------+
| Charset | Description   | Default collation | Maxlen |
+---------+---------------+-------------------+--------+
| utf8    | UTF-8 Unicode | utf8_general_ci   |      3 |
+---------+---------------+-------------------+--------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从上可以看出，utf8编码的默认规则集是&lt;code class=&quot;highlighter-rouge&quot;&gt;utf8_general_ci&lt;/code&gt; (规则集的命名规则通常是”字符集_规则集_大小写敏感否”的格式)，可以看到最后的&lt;code class=&quot;highlighter-rouge&quot;&gt;_ci&lt;/code&gt;表名了这个规则集是大小写不敏感的。我们找一个支持大小写敏感比对的规则集出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; SHOW COLLATION WHERE Charset LIKE 'utf8';
+--------------------------+---------+-----+---------+----------+---------+
| Collation                | Charset | Id  | Default | Compiled | Sortlen |
+--------------------------+---------+-----+---------+----------+---------+
| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |
| utf8_bin                 | utf8    |  83 |         | Yes      |       1 |
| utf8_unicode_ci          | utf8    | 192 |         | Yes      |       8 |
| utf8_icelandic_ci        | utf8    | 193 |         | Yes      |       8 |
| utf8_latvian_ci          | utf8    | 194 |         | Yes      |       8 |
| utf8_romanian_ci         | utf8    | 195 |         | Yes      |       8 |
| utf8_slovenian_ci        | utf8    | 196 |         | Yes      |       8 |
| utf8_polish_ci           | utf8    | 197 |         | Yes      |       8 |
| utf8_estonian_ci         | utf8    | 198 |         | Yes      |       8 |
| utf8_spanish_ci          | utf8    | 199 |         | Yes      |       8 |
| utf8_swedish_ci          | utf8    | 200 |         | Yes      |       8 |
| utf8_turkish_ci          | utf8    | 201 |         | Yes      |       8 |
| utf8_czech_ci            | utf8    | 202 |         | Yes      |       8 |
| utf8_danish_ci           | utf8    | 203 |         | Yes      |       8 |
| utf8_lithuanian_ci       | utf8    | 204 |         | Yes      |       8 |
| utf8_slovak_ci           | utf8    | 205 |         | Yes      |       8 |
| utf8_spanish2_ci         | utf8    | 206 |         | Yes      |       8 |
| utf8_roman_ci            | utf8    | 207 |         | Yes      |       8 |
| utf8_persian_ci          | utf8    | 208 |         | Yes      |       8 |
| utf8_esperanto_ci        | utf8    | 209 |         | Yes      |       8 |
| utf8_hungarian_ci        | utf8    | 210 |         | Yes      |       8 |
| utf8_sinhala_ci          | utf8    | 211 |         | Yes      |       8 |
| utf8_german2_ci          | utf8    | 212 |         | Yes      |       8 |
| utf8_croatian_ci         | utf8    | 213 |         | Yes      |       8 |
| utf8_unicode_520_ci      | utf8    | 214 |         | Yes      |       8 |
| utf8_vietnamese_ci       | utf8    | 215 |         | Yes      |       8 |
| utf8_general_mysql500_ci | utf8    | 223 |         | Yes      |       1 |
+--------------------------+---------+-----+---------+----------+---------+
27 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;纳尼… 27个选择几乎全是大小写不敏感的（可见大小写敏感的用例不是很广），幸好还有个&lt;code class=&quot;highlighter-rouge&quot;&gt;utf8_bin&lt;/code&gt;，它是支持大小写敏感比对的(用字节而非字符进行比对)。&lt;/p&gt;

&lt;p&gt;我们把上面的uni_code table的&lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt;一栏的&lt;code class=&quot;highlighter-rouge&quot;&gt;collate&lt;/code&gt;换成&lt;code class=&quot;highlighter-rouge&quot;&gt;utf8_bin&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; ALTER TABLE uni_code MODIFY code
    -&amp;gt;   VARCHAR(10)
    -&amp;gt;   CHARACTER SET utf8
    -&amp;gt;   COLLATE utf8_bin;
Query OK, 3 rows affected (1.44 sec)
Records: 3  Duplicates: 0  Warnings: 0

SHOW CREATE TABLE uni_code;
CREATE TABLE `uni_code` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `code` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们看到&lt;code class=&quot;highlighter-rouge&quot;&gt;code&lt;/code&gt;一栏的&lt;strong&gt;collate&lt;/strong&gt;属性已经改过来了。Table和DB的改动格式见&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/charset-table.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;再说说线上改表的问题。上面那张表也就3行数据，改动一栏尚且花了1.44s的时间，这要在500万+的数据表上做改动得花去多长时间，假如还要考虑线上表的访问、新增、更新请求就更需谨慎了。这里推荐一个&lt;a href=&quot;http://openarkkit.googlecode.com/svn/trunk/openarkkit/doc/html/oak-online-alter-table.html&quot;&gt;在线改表工具&lt;/a&gt;，好用的很。当时是暂停服务进行的改动整张表的collate属性的操作，有两栏是varchar的(size分别是10、255)，500万+的数据十几分钟就搞定。&lt;/p&gt;

&lt;h1 id=&quot;其四-update语句并不一定真的会update&quot;&gt;其四: Update语句并不一定真的会”Update”&lt;/h1&gt;

&lt;p&gt;有一张如下的表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; describe big_msg;
+-------+-------------+------+-----+---------+-------+
| Field | Type        | Null | Key | Default | Extra |
+-------+-------------+------+-----+---------+-------+
| key   | varchar(20) | YES  | MUL | NULL    |       |
| val   | text        | YES  |     | NULL    |       |
+-------+-------------+------+-----+---------+-------+
2 rows in set (0.01 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;插入一行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; INSERT INTO big_msg (`key`, `val`) VALUES (&quot;test-key&quot;, &quot;test-val&quot;);
Query OK, 1 row affected (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;查看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; UPDATE big_msg SET `val`=&quot;test-val&quot; WHERE `key`=&quot;test-key&quot;;
Query OK, 0 rows affected (0.00 sec)
Rows matched: 1  Changed: 0  Warnings: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;0 rows affected (0.00 sec)&lt;/code&gt;，也就是说这里并没有更新本行。这个在普通场景下并无大碍，不过当你使用的类似&lt;code class=&quot;highlighter-rouge&quot;&gt;PHP PDO&lt;/code&gt;面向对象的数据库类库，而且你的&lt;code class=&quot;highlighter-rouge&quot;&gt;Statement&lt;/code&gt;又依赖于&lt;code class=&quot;highlighter-rouge&quot;&gt;row affected&lt;/code&gt;这个返回值时（例如PHP-PDO的&lt;code class=&quot;highlighter-rouge&quot;&gt;PDOStatement::rowCount ( void )&lt;/code&gt;），这里就需要尤其注意一下了，&lt;strong&gt;如果你的更新值和原有值相同，则本次更新会被忽略, 返回值&lt;code class=&quot;highlighter-rouge&quot;&gt;affected rows&lt;/code&gt;将为0&lt;/strong&gt;。看官方文档中的说明：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you set a column to the value it currently has, MySQL notices this and does not update it.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name></name></author><category term="Tech" /><category term="Database" /><category term="Mysql" /><summary type="html">其一: int(10)意欲何为 MySQL的Column-Type中的int一类，不像其他Type如char、varchar是根据最大size来预置存储空间的，int这一类的Column-Type所指定的size是作为显示宽度来存储的(涉及到size不足前端补零的场景-zerofill），它们所占用的实际空间大小是固定的。所以想通过int(10)来节省存储空间的想法是无效的。 其二: index的prefix length 最近的一个项目需要存储互联网上的URL，并生成唯一ID，所以数据表里边会有urlcmpr一栏 urlcmpr: 适当压缩过的url，用0、1代表http[s]，62进制的code代表hostname。示例：0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=379 当时的建表语句是这样的（其实项目用的是SQLAlchemy的ORM-Model，这里只是复现一下当时的情况） CREATE TABLE `urls` ( `id` int(11) NOT NULL AUTO_INCREMENT, `urlcmpr` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `idx_urlcmpr` (`urlcmpr`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 查看建好的表信息 mysql&amp;gt; DESC urls; +---------+--------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +---------+--------------+------+-----+---------+----------------+ | id | int(11) | NO | PRI | NULL | auto_increment | | urlcmpr | varchar(255) | YES | UNI | NULL | | +---------+--------------+------+-----+---------+----------------+ 首先插入两条记录： insert into urls (urlcmpr) values ('0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=0001'), ('0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=0002'); 因为我们已经为urlcmpr建好了唯一索引，我们来试试重复插入一下： insert into urls (urlcmpr) values ('0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-id=0001'); 不出所料，报错了 ERROR 1062 (23000): Duplicate entry '0h^/Mucinex-Sinus-Max-Pressure-Caplets-Count/dp/B009XQHSUC/ref-i' for key 'idx_urlcmpr' 这个原本也没什么，但由于下方已删除的那部分描述的缘由，我开始关注错误报告所反映的一个信息：urlcmpr栏是255字符的，但据此建立的unique-key却只有64字符的长度，这是怎么回事？ 其实后来才发现这个只是显示了唯一Key的前64个字符而已，其实唯一Key并不是只有64个字符。 这里建唯一索引的目的是为了在重复误插入的时候被拒绝并报错，结果在程序准备正常插入的时候，MySQL也开始拒绝并报错了。但是事后当我试图重现这个问题时却发现，本段所描述的问题是不存在的！ 总之由于上面的一些误解（经过一步步查资料又自己推翻）就开始查资料了，查着查着找到了官方文档里的这样一段话（略有删减）： Indexes can be created that use only the leading part of column values, using col_name(length) syntax to specify an index prefix length. Prefix lengths are given in characters… That is, index entries consist of the first length characters of each column value for CHAR, VARCHAR, and TEXT columns, and the first length bytes of each column value for BINARY, VARBINARY, and BLOB columns… using column prefixes for indexes can make the index file much smaller, which could save a lot of disk space and might also speed up INSERT operations. 基本就是在说：chars类的column，在建立索引的时候会有index prefix length一说，也就是只取本栏开头的若干个字符做索引（而不是本栏全部内容），这样做的好处是可以节省存储空间。 虽然官方文档中没有说到为什么当一栏内容过大而且你没有设定它的index-prefix-length时，它的这个值会被设为64，但目前来看事实似乎就是这样的。 如果是存储较长字符串(比如255 chars)的唯一索引，它的prefix-length该怎么定制（从节省存储空间的角度看）？用上面的例子做示例： UNIQUE KEY 'idx_urlcmpr' ('urlcmpr'(100)) 即在想要建立索引的栏名后面的括号中指定prefix-length。 我们再来试试看 CREATE TABLE `urls2` ( `id` int(11) NOT NULL AUTO_INCREMENT, `urlcmpr` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `idx_urlcmpr` (`urlcmpr`(100)) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 插入一段字符个数为100的string: 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZab Insert OK 在上一段string尾部加一个字符c(101个字符长度)再试试： 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabc ERROR 1062 (23000): Duplicate entry 无法插入了。上面的两步说明我们设定的唯一索引的prefix-length成功了，不过它也反映出一个问题：如果你要存储的内容在前半部分重复度很高，那么你的唯一索引可能会因为prefix-length过小而导致无法插入(如果两个string在开头的prefix-length以内是相同的)。因为确实已经遇到无法插入的问题了(500万+的URL），考虑了一下后我把UniqueKey的限制给去掉了，改用普通Key: KEY 'idx_urlcmpr' ('urlcmpr'(100))，是否重复则交由程序来判断，一来可以节省存储空间（Key也是要被存储记录的，不宜太长），二来防止将来有高度相似的URL无法插入。 其三：MySQL搜索校验时的Case -Sensitive问题 由于业务需要，在存储这么多url的时候，每存储一条，还需要为它生成一个唯一码(unique code)。网上已经有不少优秀的唯一ID生成器了，但想要并入业务中还有些麻烦，再者业务要求很简单，保证code在单亿数量级以内唯一，于是自己就顺手写了一个62进制的编码程序来生成unique code。由于code生成器是62进制的，如果是10个字符长的话，可表示的组合便是62的10次方，换算成10进制的话应该是一个近乎天文的数字了，唯一性是绝对保证了；程序还带了code+1功能，方便用来自增，有兴趣或有需要的朋友可以去看一下。 言归正传，利用上面的code生成器产出的code是大小写敏感的，即fooBar、Foobar和fOOBaR分别代表着不同的10进制数值。新建一张表，把它们三个存进MySQL中： # 新建表 CREATE TABLE `uni_code` ( `id` int(11) NOT NULL AUTO_INCREMENT, `code` varchar(10) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; Query OK, 0 rows affected (0.33 sec) # 插入三条数据 INSERT INTO uni_code (code) VALUES ('foobar'),('fooBar'),('fOOBaR'); Query OK, 3 rows affected (0.03 sec) # 查看刚刚插入的数据 mysql&amp;gt; SELECT * FROM uni_code; +----+--------+ | id | code | +----+--------+ | 1 | foobar | | 2 | fooBar | | 3 | fOOBaR | +----+--------+ 3 rows in set (0.00 sec) 我们再试着取出其中一条数据来： mysql&amp;gt; SELECT * FROM uni_code WHERE code = 'foobar'; +----+--------+ | id | code | +----+--------+ | 1 | fooBar | | 2 | fooBar | | 3 | fOOBaR | +----+--------+ 3 rows in set (0.03 sec) 预期中的坑出现了。我的code是大小写敏感的，但MySQL在查询校验的时候似乎忽略了这一点，直接把三条数据全部取出来了！ 当然你可以通过手动添加Binary操作符将字符转换成字节来进行查询校验，或者指定collation规则来进行查询校验 mysql&amp;gt; SELECT * FROM uni_code WHERE BINARY code = 'foobar'; +----+--------+ | id | code | +----+--------+ | 1 | foobar | +----+--------+ 1 row in set (0.00 sec) mysql&amp;gt; SELECT * FROM uni_code WHERE code COLLATE utf8_bin = 'foobar'; +----+--------+ | id | code | +----+--------+ | 1 | foobar | +----+--------+ 1 row in set (0.09 sec) 但一来我用的ORM，使用原生SQL (关键字Binary、Collate) 与使用ORM目的背离；二来四处滥用这些关键字会让程序代码混乱。最好能让MySQL在数据库层就完成大小写敏感的查询校验。 查了查资料发现MySQL在查询校验的时候所使用的Collate规则集是有默认值的，正是这个规则集决定了字符比对的结果。那么Collate是什么呢？ 在上面给出的官方文档已经很好的解释了Collate的作用，我在这里再赘述一二： 数据库中有字符集charset和规则集collate一说，字符集自不必多说。规则集是在给定字符集上进行字符对比的规则，比如大小写敏感否 (CI or CS)、äöü与aou对等否等规则，每个字符集都有默认规则集。 上面的... WHERE code COLLATE utf8_bin = ...就是指定了字符对比的规则集。这个规则集是大小写敏感的，它会覆盖默认的规则集。是的，MySQL中的每一个单元(Column、Table、Database)都可以有自己的字符集和规则集，我们通常只是指定字符集，MySQL则帮我们指定了该字符集对应的默认规则集。 这么一来就好办了，看来是MySQL为我指定了utf8编码下的默认规则集，而这个规则集在字符比对时是CI的。只要我们修改一下表(或者栏)的规则集，让它支持大小写敏感的比对就好了。 我们先来看看utf8的默认规则集，及可选规则集(下面内容可能会因版本、系统而异)： mysql&amp;gt; show CHARACTER SET WHERE charset LIKE &quot;utf8&quot;; +---------+---------------+-------------------+--------+ | Charset | Description | Default collation | Maxlen | +---------+---------------+-------------------+--------+ | utf8 | UTF-8 Unicode | utf8_general_ci | 3 | +---------+---------------+-------------------+--------+ 1 row in set (0.00 sec) 从上可以看出，utf8编码的默认规则集是utf8_general_ci (规则集的命名规则通常是”字符集_规则集_大小写敏感否”的格式)，可以看到最后的_ci表名了这个规则集是大小写不敏感的。我们找一个支持大小写敏感比对的规则集出来： mysql&amp;gt; SHOW COLLATION WHERE Charset LIKE 'utf8'; +--------------------------+---------+-----+---------+----------+---------+ | Collation | Charset | Id | Default | Compiled | Sortlen | +--------------------------+---------+-----+---------+----------+---------+ | utf8_general_ci | utf8 | 33 | Yes | Yes | 1 | | utf8_bin | utf8 | 83 | | Yes | 1 | | utf8_unicode_ci | utf8 | 192 | | Yes | 8 | | utf8_icelandic_ci | utf8 | 193 | | Yes | 8 | | utf8_latvian_ci | utf8 | 194 | | Yes | 8 | | utf8_romanian_ci | utf8 | 195 | | Yes | 8 | | utf8_slovenian_ci | utf8 | 196 | | Yes | 8 | | utf8_polish_ci | utf8 | 197 | | Yes | 8 | | utf8_estonian_ci | utf8 | 198 | | Yes | 8 | | utf8_spanish_ci | utf8 | 199 | | Yes | 8 | | utf8_swedish_ci | utf8 | 200 | | Yes | 8 | | utf8_turkish_ci | utf8 | 201 | | Yes | 8 | | utf8_czech_ci | utf8 | 202 | | Yes | 8 | | utf8_danish_ci | utf8 | 203 | | Yes | 8 | | utf8_lithuanian_ci | utf8 | 204 | | Yes | 8 | | utf8_slovak_ci | utf8 | 205 | | Yes | 8 | | utf8_spanish2_ci | utf8 | 206 | | Yes | 8 | | utf8_roman_ci | utf8 | 207 | | Yes | 8 | | utf8_persian_ci | utf8 | 208 | | Yes | 8 | | utf8_esperanto_ci | utf8 | 209 | | Yes | 8 | | utf8_hungarian_ci | utf8 | 210 | | Yes | 8 | | utf8_sinhala_ci | utf8 | 211 | | Yes | 8 | | utf8_german2_ci | utf8 | 212 | | Yes | 8 | | utf8_croatian_ci | utf8 | 213 | | Yes | 8 | | utf8_unicode_520_ci | utf8 | 214 | | Yes | 8 | | utf8_vietnamese_ci | utf8 | 215 | | Yes | 8 | | utf8_general_mysql500_ci | utf8 | 223 | | Yes | 1 | +--------------------------+---------+-----+---------+----------+---------+ 27 rows in set (0.00 sec) 纳尼… 27个选择几乎全是大小写不敏感的（可见大小写敏感的用例不是很广），幸好还有个utf8_bin，它是支持大小写敏感比对的(用字节而非字符进行比对)。 我们把上面的uni_code table的code一栏的collate换成utf8_bin： mysql&amp;gt; ALTER TABLE uni_code MODIFY code -&amp;gt; VARCHAR(10) -&amp;gt; CHARACTER SET utf8 -&amp;gt; COLLATE utf8_bin; Query OK, 3 rows affected (1.44 sec) Records: 3 Duplicates: 0 Warnings: 0 SHOW CREATE TABLE uni_code; CREATE TABLE `uni_code` ( `id` int(11) NOT NULL AUTO_INCREMENT, `code` varchar(10) CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 我们看到code一栏的collate属性已经改过来了。Table和DB的改动格式见官方文档。 再说说线上改表的问题。上面那张表也就3行数据，改动一栏尚且花了1.44s的时间，这要在500万+的数据表上做改动得花去多长时间，假如还要考虑线上表的访问、新增、更新请求就更需谨慎了。这里推荐一个在线改表工具，好用的很。当时是暂停服务进行的改动整张表的collate属性的操作，有两栏是varchar的(size分别是10、255)，500万+的数据十几分钟就搞定。 其四: Update语句并不一定真的会”Update” 有一张如下的表： mysql&amp;gt; describe big_msg; +-------+-------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +-------+-------------+------+-----+---------+-------+ | key | varchar(20) | YES | MUL | NULL | | | val | text | YES | | NULL | | +-------+-------------+------+-----+---------+-------+ 2 rows in set (0.01 sec) 插入一行： mysql&amp;gt; INSERT INTO big_msg (`key`, `val`) VALUES (&quot;test-key&quot;, &quot;test-val&quot;); Query OK, 1 row affected (0.00 sec) 查看： mysql&amp;gt; UPDATE big_msg SET `val`=&quot;test-val&quot; WHERE `key`=&quot;test-key&quot;; Query OK, 0 rows affected (0.00 sec) Rows matched: 1 Changed: 0 Warnings: 0 注意这里的0 rows affected (0.00 sec)，也就是说这里并没有更新本行。这个在普通场景下并无大碍，不过当你使用的类似PHP PDO面向对象的数据库类库，而且你的Statement又依赖于row affected这个返回值时（例如PHP-PDO的PDOStatement::rowCount ( void )），这里就需要尤其注意一下了，如果你的更新值和原有值相同，则本次更新会被忽略, 返回值affected rows将为0。看官方文档中的说明： If you set a column to the value it currently has, MySQL notices this and does not update it.</summary></entry><entry><title type="html">MOOC课程小结：如何编写一个几乎无摩擦的太空飞船</title><link href="http://localhost:4000/2014/07/06/using-js-to-build-a-spaceship-floating-in-the-outer-space.html" rel="alternate" type="text/html" title="MOOC课程小结：如何编写一个几乎无摩擦的太空飞船" /><published>2014-07-06T00:00:00+08:00</published><updated>2014-07-06T00:00:00+08:00</updated><id>http://localhost:4000/2014/07/06/using-js-to-build-a-spaceship-floating-in-the-outer-space</id><content type="html" xml:base="http://localhost:4000/2014/07/06/using-js-to-build-a-spaceship-floating-in-the-outer-space.html">&lt;p&gt;四五月份的时候曾抱着试一试的心态参加了一门MOOC课程&lt;a href=&quot;https://class.coursera.org/interactivepython-004&quot;&gt;An Introduction to Interactive Programming in Python&lt;/a&gt;，课程内容主要是通过编写小游戏来完成Python编程入门。&lt;/p&gt;

&lt;p&gt;至于为什么要参加MOOC课程，又为什么选择了这一门呢？主要是MOOC这个话题太火了，弄得好像不参加就要当奥特曼了，所以希望通过参加一门简单的课程来了解MOOC；再者自己工作有闲暇时间，正好可以用业余时间学一学Python，也顺便学着编一些小游戏玩玩。&lt;/p&gt;

&lt;p&gt;上完课拿到&lt;a href=&quot;http://lyfing.qiniudn.com/docs/imgs/mooc/InteractivePython_Accomplishment_Statement.png&quot;&gt;证书&lt;/a&gt;后本想抽时间做个总结，却总是困于拖延症中无法自拔。自己这几天利用闲暇时间学了学HTML5的canvas，总算把当初在这门课程上学到的一丁点关于游戏开发的知识点 ——-穿行在摩擦系数极低的外太空中的太空飞船在飞行时的编程控制应该是怎样的—— 用javascript给实现了一下，就权当是总结吧。&lt;/p&gt;

&lt;p&gt;想要玩一玩这个简易飞船的戳这里：&lt;a href=&quot;http://lyfing.sinaapp.com/blog/demo/index/mooc-spaceship&quot;&gt;简易飞船demo&lt;/a&gt;&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;###如何实现
关于这个飞船的飞行，当初最吸引我的一点是它在加速飞行时，加速方向和运动方向并不总是一致的，也就是说这个飞船在运行时是有”漂移”特效的，然后我就很好奇这种”漂移”特效是如何用编程来实现的。下面我就说一说这方面的事情。&lt;/p&gt;

&lt;p&gt;####将飞船拟物化
也就是说从&lt;code class=&quot;highlighter-rouge&quot;&gt;面向对象&lt;/code&gt;编程的角度来思考这个问题。&lt;/p&gt;

&lt;p&gt;#####飞船的属性
拟物化的第一步是飞船在屏幕上得有一个起始点，在2d平面里可以直接用x（横坐标轴）和y（纵坐标轴）来标志起始位置即可。于是飞船有了第一个属性：当前坐标&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(x, y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;飞船从起始点(x1, y1)移动到(x2, y2)只能有一个原因，在某段时间内，它的速度不再为0(velocity)，然后用大家都熟悉的公式 &lt;code class=&quot;highlighter-rouge&quot;&gt;s2 = vel * time + s1&lt;/code&gt; 便可以获得(x1,y1)到(x2, y2)的距离，所以我们需要赋予飞船第二个属性：速度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vel速度(x、y代表速度分解到两坐标轴上的大小)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;飞船具有速度从而开始运动，是因为它获得了某个方向的加速度(acceleration)。我们可以用公式 &lt;code class=&quot;highlighter-rouge&quot;&gt;vel_2 = acc * time + vel_1&lt;/code&gt;  来获得飞船的速度，但前提是我们需要赋予飞船第三个属性：加速度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;acc加速度(x, y)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;#####飞船的方法
想想看如果你坐在一架飘浮于外太空的飞船上时，你最需要飞船有什么功能？&lt;/p&gt;

&lt;p&gt;答案当然是可以挂档啦，要不然你就只能一辈子静止在那里看流星雨了。所以飞船应该要有一个挂档的方法(功能)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;startAcc() // 开始加速
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note: 正如科学家牛顿说过的，挂档的动作并不是改变飞船的速度(vel)，而是在改变它的加速度(acc).&lt;/p&gt;

&lt;p&gt;如果你不想让飞船直接撞上附近某个星球，你就应该给它个挂空档的机会（即停止加速），要不然它真的会一直加速下去最终失控的（想想都可怕）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;stopAcc() // 停止加速
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;####万事具备，只欠挂档了&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;真的吗？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;于是，当你按下加速键(↑)后，飞船开始加速，这个过程是发生在某个时间段内的，我们暂且就把这段时间定义为&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;吧（此处速度、时间等不再继承物理世界的单位，方便演示和计算）&lt;/p&gt;

&lt;p&gt;在时间&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;内，君挂上档，飞船的加速度(&lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;)变化为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;acc = (10, 10) // 任意数值，以飞船实际飞行效果调优为准
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;考虑到飞船初始时是静止的，所以飞船的速度变化为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;newVel = acc * 1 + (0, 0) // newVel = (10, 10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;假设飞船初始位置为(0, 0)，那么飞船的位置变化为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;newPos = newVel * 1 + (0, 0) // newPos = (10, 10);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时如果君还没有挂空挡，那么在下一个时间&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;内，飞船的加速度(&lt;code class=&quot;highlighter-rouge&quot;&gt;acc&lt;/code&gt;)、速度(&lt;code class=&quot;highlighter-rouge&quot;&gt;vel&lt;/code&gt;)以及新位置(&lt;code class=&quot;highlighter-rouge&quot;&gt;pos&lt;/code&gt;)将变为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;acc = (10, 10) // 加速度此处设为常量（需要优化可以自己调优变动）
newVel = acc * 1 + oldVel // newVel = (20, 20);
newPos = newVel * 1 + oldPos // newPos = (20, 20);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时需要设定一个定时器，每隔一小段时间(&lt;code class=&quot;highlighter-rouge&quot;&gt;interval&lt;/code&gt;)把飞船的旧图像抹掉，再根据飞船的新位置将图像重绘一次，这样一来飞船看上去就好像动起来了。&lt;/p&gt;

&lt;p&gt;可是，说好的漂移特效呢？&lt;/p&gt;

&lt;p&gt;####飞船并不完整
要想有漂移，当然要有变向了。我们需要给飞船添加一个改变方向的方法，但前提是飞船要具有方向的概念（属性）。在飞船所处的2d世界，我们用&lt;strong&gt;弧度&lt;/strong&gt;来表示它所朝的方向。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 飞船新属性
ang = 0 // 0或者2π即表示水平向右的方向
// 飞船新方法
changeRotation() // 该方法的实质是改变飞船的 ang
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;添加新的属性和方法后，我们再来演示一遍在时间&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;内飞船各属性的变化（假设本时间段内飞船角度&lt;code class=&quot;highlighter-rouge&quot;&gt;ang&lt;/code&gt;为 π/3，且处于加速状态，考虑到无摩擦时飞船在若干次加速后将因为速度过快而变得无法控制，我们在飞船更新速度时，为它添加一个速度磨损）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 角度
ang = π / 3
// 加速度
acc = ( 10 * cos(ang), 10 * sin(ang) )
// 速度
vel = acc * 1 + oldVel
// 摩擦导致的2%的速度磨损
newVel = vel * 0.98 (小数大小以飞行体验调优为准)
// 新位置
newPos = newVel * 1 + oldPos
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;设置键盘&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;←和→按下时调用&lt;code class=&quot;highlighter-rouge&quot;&gt;changeRotation()&lt;/code&gt;方法来改变飞行角度&lt;/li&gt;
  &lt;li&gt;按下↑时调用&lt;code class=&quot;highlighter-rouge&quot;&gt;startAcc()&lt;/code&gt;方法启动加速&lt;/li&gt;
  &lt;li&gt;释放↑时调用&lt;code class=&quot;highlighter-rouge&quot;&gt;stopAcc()&lt;/code&gt;停止加速。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这次再试一试，飞船是不是开始漂移了？&lt;/p&gt;

&lt;p&gt;Good luck :)&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MOOC公开课&lt;strong&gt;Python交互式编程介绍&lt;/strong&gt;（飞船demo中所用图片素材也来自该课程）：https://class.coursera.org/interactivepython-004&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Tech" /><category term="Javascript" /><category term="MOOC" /><summary type="html">四五月份的时候曾抱着试一试的心态参加了一门MOOC课程An Introduction to Interactive Programming in Python，课程内容主要是通过编写小游戏来完成Python编程入门。 至于为什么要参加MOOC课程，又为什么选择了这一门呢？主要是MOOC这个话题太火了，弄得好像不参加就要当奥特曼了，所以希望通过参加一门简单的课程来了解MOOC；再者自己工作有闲暇时间，正好可以用业余时间学一学Python，也顺便学着编一些小游戏玩玩。 上完课拿到证书后本想抽时间做个总结，却总是困于拖延症中无法自拔。自己这几天利用闲暇时间学了学HTML5的canvas，总算把当初在这门课程上学到的一丁点关于游戏开发的知识点 ——-穿行在摩擦系数极低的外太空中的太空飞船在飞行时的编程控制应该是怎样的—— 用javascript给实现了一下，就权当是总结吧。 想要玩一玩这个简易飞船的戳这里：简易飞船demo ###如何实现 关于这个飞船的飞行，当初最吸引我的一点是它在加速飞行时，加速方向和运动方向并不总是一致的，也就是说这个飞船在运行时是有”漂移”特效的，然后我就很好奇这种”漂移”特效是如何用编程来实现的。下面我就说一说这方面的事情。 ####将飞船拟物化 也就是说从面向对象编程的角度来思考这个问题。 #####飞船的属性 拟物化的第一步是飞船在屏幕上得有一个起始点，在2d平面里可以直接用x（横坐标轴）和y（纵坐标轴）来标志起始位置即可。于是飞船有了第一个属性：当前坐标 (x, y) 飞船从起始点(x1, y1)移动到(x2, y2)只能有一个原因，在某段时间内，它的速度不再为0(velocity)，然后用大家都熟悉的公式 s2 = vel * time + s1 便可以获得(x1,y1)到(x2, y2)的距离，所以我们需要赋予飞船第二个属性：速度 vel速度(x、y代表速度分解到两坐标轴上的大小) 飞船具有速度从而开始运动，是因为它获得了某个方向的加速度(acceleration)。我们可以用公式 vel_2 = acc * time + vel_1 来获得飞船的速度，但前提是我们需要赋予飞船第三个属性：加速度 acc加速度(x, y) #####飞船的方法 想想看如果你坐在一架飘浮于外太空的飞船上时，你最需要飞船有什么功能？ 答案当然是可以挂档啦，要不然你就只能一辈子静止在那里看流星雨了。所以飞船应该要有一个挂档的方法(功能) startAcc() // 开始加速 Note: 正如科学家牛顿说过的，挂档的动作并不是改变飞船的速度(vel)，而是在改变它的加速度(acc). 如果你不想让飞船直接撞上附近某个星球，你就应该给它个挂空档的机会（即停止加速），要不然它真的会一直加速下去最终失控的（想想都可怕） stopAcc() // 停止加速 ####万事具备，只欠挂档了 真的吗？ 于是，当你按下加速键(↑)后，飞船开始加速，这个过程是发生在某个时间段内的，我们暂且就把这段时间定义为1吧（此处速度、时间等不再继承物理世界的单位，方便演示和计算） 在时间1内，君挂上档，飞船的加速度(acc)变化为： acc = (10, 10) // 任意数值，以飞船实际飞行效果调优为准 考虑到飞船初始时是静止的，所以飞船的速度变化为： newVel = acc * 1 + (0, 0) // newVel = (10, 10); 假设飞船初始位置为(0, 0)，那么飞船的位置变化为： newPos = newVel * 1 + (0, 0) // newPos = (10, 10); 此时如果君还没有挂空挡，那么在下一个时间1内，飞船的加速度(acc)、速度(vel)以及新位置(pos)将变为： acc = (10, 10) // 加速度此处设为常量（需要优化可以自己调优变动） newVel = acc * 1 + oldVel // newVel = (20, 20); newPos = newVel * 1 + oldPos // newPos = (20, 20); 此时需要设定一个定时器，每隔一小段时间(interval)把飞船的旧图像抹掉，再根据飞船的新位置将图像重绘一次，这样一来飞船看上去就好像动起来了。 可是，说好的漂移特效呢？ ####飞船并不完整 要想有漂移，当然要有变向了。我们需要给飞船添加一个改变方向的方法，但前提是飞船要具有方向的概念（属性）。在飞船所处的2d世界，我们用弧度来表示它所朝的方向。 // 飞船新属性 ang = 0 // 0或者2π即表示水平向右的方向 // 飞船新方法 changeRotation() // 该方法的实质是改变飞船的 ang 添加新的属性和方法后，我们再来演示一遍在时间1内飞船各属性的变化（假设本时间段内飞船角度ang为 π/3，且处于加速状态，考虑到无摩擦时飞船在若干次加速后将因为速度过快而变得无法控制，我们在飞船更新速度时，为它添加一个速度磨损） // 角度 ang = π / 3 // 加速度 acc = ( 10 * cos(ang), 10 * sin(ang) ) // 速度 vel = acc * 1 + oldVel // 摩擦导致的2%的速度磨损 newVel = vel * 0.98 (小数大小以飞行体验调优为准) // 新位置 newPos = newVel * 1 + oldPos 设置键盘 ←和→按下时调用changeRotation()方法来改变飞行角度 按下↑时调用startAcc()方法启动加速 释放↑时调用stopAcc()停止加速。 这次再试一试，飞船是不是开始漂移了？ Good luck :) 备注： MOOC公开课Python交互式编程介绍（飞船demo中所用图片素材也来自该课程）：https://class.coursera.org/interactivepython-004</summary></entry><entry><title type="html">通过XHR上传浏览器端的文件资源</title><link href="http://localhost:4000/2014/06/28/upload-browser-side-resources-by-using-xhr.html" rel="alternate" type="text/html" title="通过XHR上传浏览器端的文件资源" /><published>2014-06-28T00:00:00+08:00</published><updated>2014-06-28T00:00:00+08:00</updated><id>http://localhost:4000/2014/06/28/upload-browser-side-resources-by-using-xhr</id><content type="html" xml:base="http://localhost:4000/2014/06/28/upload-browser-side-resources-by-using-xhr.html">&lt;p&gt;最近在为公司开发一个&lt;a href=&quot;https://chrome.google.com/webstore/detail/obnbgneldjmmpgkbnnbiiinijmiclpaa&quot;&gt;海淘的Chrome扩展&lt;/a&gt;，扩展的需求之一是：获取当前页面中的某张图片，并将其上传至公司的服务器保存。&lt;/p&gt;

&lt;p&gt;当时的第一思路是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取图片的URL，然后把URL提交给服务器，让服务器进行下载操作&lt;/li&gt;
  &lt;li&gt;如果服务器访问图片资源时被拒绝，就需要让用户手动下载该图片，然后手动上传至我们的服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过在后来的实践中发现，其实可以直接通过&lt;strong&gt;发起&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt;请求并指定其返回类型&lt;/strong&gt;的方式来获取浏览器返回的raw数据(&lt;code class=&quot;highlighter-rouge&quot;&gt;Blob&lt;/code&gt;)，然后将这些raw数据当作文件上传至服务器。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;在这里首先要说明一点是的：这种将XHR的响应内容当作文件上传的思路，通常是需要&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;跨站请求资源&lt;/a&gt;(Cross-site HTTP requests)的，所以除非是在允许跨站请求的运行环境中（如Chrome扩展内）运行这些JS，否则这种思路几乎不可用&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;###思路
这种上传客户端资源的解决方案最先来自这里&lt;a href=&quot;http://stackoverflow.com/a/10002486/1241980&quot;&gt;upload-a-file-in-a-google-chrome-extension&lt;/a&gt;。基本思路是：当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;XHR&lt;/code&gt;向某个URL发起请求时（如请求某个&lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;css&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;js&lt;/code&gt;文件资源）我们可以设定它的返回类型（&lt;code class=&quot;highlighter-rouge&quot;&gt;responseType&lt;/code&gt;）；当我们把返回类型设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;blob&lt;/code&gt;时，我们便可以直接把返回的raw数据当作”文件”来上传到服务器，以此来实现客户端访问资源的上传。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;###怎么做
1) 通过XHR请求一个图片资源&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var imgURL = 'http://lyfing.qiniudn.com/external_links/pocker_cards_family.png';
var xhr = new XMLHttpRequest(); 
xhr.open(&quot;GET&quot;, imgURL, true);
xhr.responseType = &quot;blob&quot;;
xhr.onload = function(){
    var blob = xhr.response;
    var msg = ' Request URL = \n ' + imgURL;
    msg += '\n\n Get Response !';
    msg += '\n responseType = ' + blob.type;
    msg += '\n responseSize = ' + Math.round(blob.size / 1024) + 'KB';
    alert(msg);
};
xhr.send();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function getIMGRes(){
    var imgURL = 'http://lyfing.qiniudn.com/external_links/pocker_cards_family.png';
    var xhr = new XMLHttpRequest(); 
    xhr.open(&quot;GET&quot;, imgURL, true);
    xhr.responseType = &quot;blob&quot;;
    xhr.onload = function(){
        var blob = xhr.response;
        var msg = ' Request URL = \n ' + imgURL;
        msg += '\n\n Get Response !';
        msg += '\n responseType = ' + blob.type;
        msg += '\n responseSize = ' + Math.round(blob.size / 1024) + 'KB';
        alert(msg);
    };
    xhr.send();
};
&lt;/script&gt;

&lt;p&gt;&lt;input type=&quot;button&quot; onclick=&quot;getIMGRes();&quot; value=&quot;点击测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2) 将返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Blob&quot;&gt;Blob&lt;/a&gt;对象上传至服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 直接使用上一步获得的blob对象
var blob = xhr1.response;
// 我们可以直接使用FormData构建Form表单
var formData = new FormData();
// 获取文件类型(例如: blob.type = 'image/png')
var fileType = blob.type.split('/')[1]; 
// 将返回的blob对象直接当作文件上传，并设置上传文件名为 test001.fileType
formData.append('file', blob, 'test001.' + fileType);

var xhr2 = new XMLHttpRequest();

xhr2.upload.onprogress = function(event){
    ...
    $msg.html('正在上传 ( ' + percent + '% )');
}

xhr2.onload = function(){
    if ( !confirm('上传完成！即将跳转至上传结果页...') ) return;
    // 返回结果是一段纯文本，我们用正则取出本次上传的信息链接
    var url = xhr2.response.match(/http:\/\/[^\s]+/)[0];
    window.open(url);
}

xhr2.open('POST', 'http://posttestserver.com/post.php?dir=example', true);
xhr2.send(formData);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function upload(){
    var imgURL = 'http://lyfing.qiniudn.com/external_links/pocker_cards_family.png';
    var xhr1 = new XMLHttpRequest();
    xhr1.open(&quot;GET&quot;, imgURL, true);
    xhr1.responseType = &quot;blob&quot;;
    xhr1.onload = function(){
        var blob = xhr1.response;
        var formData = new FormData();
        var fileType = blob.type.split('/')[1];
        formData.append('file', blob, 'test001.' + fileType);

        var xhr = new XMLHttpRequest();
        
        xhr.upload.onprogress = function(event){
            var $msg2 = $('#part2Msg');
            var percent = Math.floor(event.position / event.totalSize * 100);
            $msg2.html('正在上传 ( ' + percent + '% )');
        }

        xhr.onload = function(){
            if ( !confirm('上传完成！即将跳转至上传结果页...') ) return;
            var url = xhr.response.match(/http:\/\/[^\s]+/)[0];
            window.open(url);
        }
        
        xhr.open('POST', 'http://posttestserver.com/post.php?dir=example', true);
        xhr.send(formData);        
    };
    xhr1.send(); 
}
&lt;/script&gt;

&lt;p&gt;&lt;input type=&quot;button&quot; onclick=&quot;upload();&quot; value=&quot;点击测试&quot; /&gt; &lt;span id=&quot;part2Msg&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;用到的一些对象&quot;&gt;用到的一些&lt;code class=&quot;highlighter-rouge&quot;&gt;对象&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;上面我们用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;FormData&lt;/code&gt;对象(&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/FormData&quot;&gt;详情&lt;/a&gt;)，它是一个模拟了HTML中的Form表单的实体，你可以直接使用它来构建&lt;code class=&quot;highlighter-rouge&quot;&gt;key/value pair&lt;/code&gt;，其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;可以是&lt;code class=&quot;highlighter-rouge&quot;&gt;文件&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Blob&lt;/code&gt;或者纯&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;。下面做一个简单的使用示例（Chrome、Firefox可随便使用，IE10+才可使用)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建Form表单对象formData，可在构造函数中传入一个HTML表单对象htmlForm
// 它的键值对会被添加到formData中
var formData = new FormData();
// 添加一个键值对
formData.append('userID', '112233');
// 添加一个文件对象
var file = document.getElementByID('fileField');
formData.append('file1', file);
// 添加一个Blob对象，它将被视为文件上传
formData.append('file2', blob);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;Blob&lt;/code&gt;对象，它是一个类似于&lt;code class=&quot;highlighter-rouge&quot;&gt;文件&lt;/code&gt;的结构体，事实上&lt;code class=&quot;highlighter-rouge&quot;&gt;文件&lt;/code&gt;接口正是在它的基础上做的扩展。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Blob&quot;&gt;更多关于Blob&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&quot;&gt;跨站请求HTTP资源&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Blob&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Blob&lt;/code&gt;&lt;/a&gt;对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/FormData&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FormData&lt;/code&gt;&lt;/a&gt;对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例中用到的文件上传服务：http://posttestserver.com/post.php?dir=example&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例中用到的图片：&lt;img src=&quot;http://lyfing.qiniudn.com/external_links/pocker_cards_family.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Tech" /><category term="Javascript" /><category term="Chrome-Extension" /><summary type="html">最近在为公司开发一个海淘的Chrome扩展，扩展的需求之一是：获取当前页面中的某张图片，并将其上传至公司的服务器保存。 当时的第一思路是： 获取图片的URL，然后把URL提交给服务器，让服务器进行下载操作 如果服务器访问图片资源时被拒绝，就需要让用户手动下载该图片，然后手动上传至我们的服务器 不过在后来的实践中发现，其实可以直接通过发起XHR请求并指定其返回类型的方式来获取浏览器返回的raw数据(Blob)，然后将这些raw数据当作文件上传至服务器。 在这里首先要说明一点是的：这种将XHR的响应内容当作文件上传的思路，通常是需要跨站请求资源(Cross-site HTTP requests)的，所以除非是在允许跨站请求的运行环境中（如Chrome扩展内）运行这些JS，否则这种思路几乎不可用 ###思路 这种上传客户端资源的解决方案最先来自这里upload-a-file-in-a-google-chrome-extension。基本思路是：当使用XHR向某个URL发起请求时（如请求某个image、css、js文件资源）我们可以设定它的返回类型（responseType）；当我们把返回类型设置为blob时，我们便可以直接把返回的raw数据当作”文件”来上传到服务器，以此来实现客户端访问资源的上传。 ###怎么做 1) 通过XHR请求一个图片资源 var imgURL = 'http://lyfing.qiniudn.com/external_links/pocker_cards_family.png'; var xhr = new XMLHttpRequest(); xhr.open(&quot;GET&quot;, imgURL, true); xhr.responseType = &quot;blob&quot;; xhr.onload = function(){ var blob = xhr.response; var msg = ' Request URL = \n ' + imgURL; msg += '\n\n Get Response !'; msg += '\n responseType = ' + blob.type; msg += '\n responseSize = ' + Math.round(blob.size / 1024) + 'KB'; alert(msg); }; xhr.send(); 2) 将返回的Blob对象上传至服务器 // 直接使用上一步获得的blob对象 var blob = xhr1.response; // 我们可以直接使用FormData构建Form表单 var formData = new FormData(); // 获取文件类型(例如: blob.type = 'image/png') var fileType = blob.type.split('/')[1]; // 将返回的blob对象直接当作文件上传，并设置上传文件名为 test001.fileType formData.append('file', blob, 'test001.' + fileType); var xhr2 = new XMLHttpRequest(); xhr2.upload.onprogress = function(event){ ... $msg.html('正在上传 ( ' + percent + '% )'); } xhr2.onload = function(){ if ( !confirm('上传完成！即将跳转至上传结果页...') ) return; // 返回结果是一段纯文本，我们用正则取出本次上传的信息链接 var url = xhr2.response.match(/http:\/\/[^\s]+/)[0]; window.open(url); } xhr2.open('POST', 'http://posttestserver.com/post.php?dir=example', true); xhr2.send(formData);   用到的一些对象 上面我们用到了FormData对象(详情)，它是一个模拟了HTML中的Form表单的实体，你可以直接使用它来构建key/value pair，其中的value可以是文件、Blob或者纯String。下面做一个简单的使用示例（Chrome、Firefox可随便使用，IE10+才可使用) // 创建Form表单对象formData，可在构造函数中传入一个HTML表单对象htmlForm // 它的键值对会被添加到formData中 var formData = new FormData(); // 添加一个键值对 formData.append('userID', '112233'); // 添加一个文件对象 var file = document.getElementByID('fileField'); formData.append('file1', file); // 添加一个Blob对象，它将被视为文件上传 formData.append('file2', blob); 关于Blob对象，它是一个类似于文件的结构体，事实上文件接口正是在它的基础上做的扩展。更多关于Blob 备注： 跨站请求HTTP资源 Blob对象 FormData对象 示例中用到的文件上传服务：http://posttestserver.com/post.php?dir=example 示例中用到的图片：</summary></entry><entry><title type="html">Python爬虫 实现从糗百上多线程抓取内容</title><link href="http://localhost:4000/2014/01/12/Python-a-web-spider-for-fetching-qiubai-articles.html" rel="alternate" type="text/html" title="Python爬虫 实现从糗百上多线程抓取内容" /><published>2014-01-12T00:00:00+08:00</published><updated>2014-01-12T00:00:00+08:00</updated><id>http://localhost:4000/2014/01/12/Python-a-web-spider-for-fetching-qiubai-articles</id><content type="html" xml:base="http://localhost:4000/2014/01/12/Python-a-web-spider-for-fetching-qiubai-articles.html">&lt;p&gt;最近参加一家公司的远程笔试，其中的一道题目是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写一个简单的爬虫，把糗事百科今天被顶超过5000的帖子爬出来，注意考虑性能和图片显示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当时一看很感兴趣，因为看到这道题目后思路很清晰，而且我大学时周围好友都爱看糗百，所以做点有关他们喜欢的产品的信息抓取还是挺有趣的。&lt;/p&gt;

&lt;p&gt;好的，闲话就到这里，下面进入正题。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;1-思路&quot;&gt;1. 思路&lt;/h2&gt;

&lt;h3 id=&quot;11-单线程-or-多线程&quot;&gt;1.1 单线程 or 多线程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;单线程&lt;/strong&gt;按序逐一抓取。这种思路下的实现方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获取糗百所有可供抓取的页面URL，然后把他们放到一个列表里&lt;/li&gt;
  &lt;li&gt;从列表中取走一条页面URL，将该URL指向页面中的所有糗百文章解析出来&lt;/li&gt;
  &lt;li&gt;如果文章有附图，则下载至指定目录&lt;/li&gt;
  &lt;li&gt;将第2步获得的若干糗百文章追加至一个xml文件中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;点评：单线程无法充分利用机器的CPU资源和带宽，性能低下，不予考虑&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多线程&lt;/strong&gt;乱序抓取。这种思路下的实现方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建两个&lt;a href=&quot;http://docs.python.org/2/library/queue.html&quot;&gt;同步队列&lt;/a&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;page_q&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pic_q&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;page_q&lt;/code&gt;存放页面URL，&lt;code class=&quot;highlighter-rouge&quot;&gt;pic_q&lt;/code&gt;存放图片URL&lt;/li&gt;
  &lt;li&gt;获取糗百所有可供抓取页面的URL，将这些URL添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;page_q&lt;/code&gt;队列&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开辟多条&lt;strong&gt;抓取解析页面文章的线程&lt;/strong&gt;，每条线程的具体工作是：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;page_q&lt;/code&gt;队列取走一条URL，解析其指向的页面中的糗百文章&lt;/li&gt;
      &lt;li&gt;将这些文章内容追加到xml文件中(同步访问)&lt;/li&gt;
      &lt;li&gt;如果文章有附图，则将该附图的链接URL放入&lt;code class=&quot;highlighter-rouge&quot;&gt;pic_q&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开辟多条&lt;strong&gt;下载图片的线程&lt;/strong&gt;，每条线程的具体工作是：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;pic_q&lt;/code&gt;队列取走一条图片URL，将其命名为&lt;code class=&quot;highlighter-rouge&quot;&gt;idxxxxx.jpg&lt;/code&gt;并下载到指定目录&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;点评：可以充分利用CPU资源及带宽，选择该条思路进行&lt;/p&gt;

&lt;h3 id=&quot;12-如何提取页面内容&quot;&gt;1.2 如何提取页面内容&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;思路1：通过正则表达式匹配，然后提取有用信息&lt;/li&gt;
  &lt;li&gt;思路2：通过第三方HTML内容提取工具提取有用信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;点评：思路2具有更高的扩展性、容错性，选择思路2&lt;/p&gt;

&lt;h2 id=&quot;2-实现&quot;&gt;2. 实现&lt;/h2&gt;

&lt;h3 id=&quot;21-多线程实体&quot;&gt;2.1 多线程实体&lt;/h3&gt;

&lt;p&gt;本文设计了两个多线程类，他们都继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;threading.Thread&lt;/code&gt;，这两个类是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class QiubaiReader(threading.Thread)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;class PicDownloader(threading.Thread)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类&lt;code class=&quot;highlighter-rouge&quot;&gt;QiubaiReader&lt;/code&gt;要做的工作和本文第1部分 &lt;strong&gt;1.1&lt;/strong&gt; » &lt;strong&gt;多线程&lt;/strong&gt; » &lt;strong&gt;抓取解析页面文章的线程&lt;/strong&gt;内容一致，以下是它的执行逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;&quot;&quot; 类 QiubaiReader 说明
糗事百科内容的消费者，也是糗事百科文章图片的生产者
消费者：从 pageQueue 里读取一个页面URL，解析该页面所有糗百文章，并将这些文章存储到xml文件中；
生产者：在解析页面时，如果某篇文章附带图片，则把该图片的URL放入 picQueue ,等待图片类的消费者来处理.
&quot;&quot;&quot;
runFlag = 1                                                    #停止线程的开关

def __init__(self, pageQueue, picQueue, pathDict):
    ...

def fetchContent(self, pageUrl):
    &quot;&quot;&quot;
    每一条糗百，我们需要取出其中的三条信息：
    1. 该条糗百的ID
    2. 该条糗百的正文
    3. 该条糗百的图片链接(可能为空，非空则等待下载)
    爬取糗百的步骤是：
    1. 获得该条糗百的整个大&amp;lt;div /&amp;gt;块，我们声明 div_dad 变量代表这个大&amp;lt;div /&amp;gt;块
    2. 通过查找当前投票数的&amp;lt;div /&amp;gt;相关值来判断是否继续，如果投票数大于5000，则继续
    3. 在大&amp;lt;div /&amp;gt;块的首行，截取该条糗百的文章ID号（每条糗百都是一篇文章，通过文章ID可以获取文章和图片的链接）
    4. 在大div块中，找出带有糗百正文的&amp;lt;div /&amp;gt;块
    5. 将上面提到的三条信息写入xml文件
    &quot;&quot;&quot;
    ...

def writeContent(self, list):
    &quot;&quot;&quot;
    将list中包含的糗百文章格式化并一次性插入到xml文件中
    list中包含有某个页面的所有糗百文章（一般是20条）
    list结构为：
    [
        {   'id':       qiuID1,
            'content':  qiuBaiText,
            'picURL':   picURL },
        ...
    ]
    &quot;&quot;&quot;
    ...

def run(self):
    while not self.pageQueue.empty() and self.__class__.runFlag &amp;gt; 0:
        #糗百页面消费者
        pageUrl = self.pageQueue.get()
        qiuBaiList, picDictList = self.fetchContent(pageUrl)
        if len(qiuBaiList) &amp;gt;= 1:
            self.writeContent(qiuBaiList)
        #糗百图片生产者
        if len(picDictList) &amp;gt;= 1:
            for item in picDictList: self.picQueue.put(item)

    #如果两个队列都为空，则线程退出，并通知图片下载线程也退出
    if self.pageQueue.empty() and self.picQueue.empty():
        ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;类&lt;code class=&quot;highlighter-rouge&quot;&gt;PicDownloader&lt;/code&gt;要做的工作和本文第1部分 &lt;strong&gt;1.1&lt;/strong&gt; » &lt;strong&gt;多线程&lt;/strong&gt; » &lt;strong&gt;下载图片的线程&lt;/strong&gt;内容一致，以下是它的执行逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 类 PicDownloader 说明
runFlag = 1                                                            #线程停止开关

def __init__(self, queue, pathDict):
    ...
def downloadPic(self, picDict):
    ...
def run(self):
    while self.__class__.runFlag &amp;gt; 0:
        while not self.queue.empty():
            picDict = self.queue.get()
            self.downloadPic(picDict)
        time.sleep(1)                                                  #如果图片URL队列为空，则等待一秒
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22-线程安全队列&quot;&gt;2.2 线程安全队列&lt;/h3&gt;

&lt;p&gt;本文涉及到的两个队列&lt;code class=&quot;highlighter-rouge&quot;&gt;page_q&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pic_q&lt;/code&gt;，一个用来存取页面URL，另一个用来存取图片URL，两队列都面临着多线程同步存取的问题，而这则是所有的”生产者-消费者问题”必须解决的问题。&lt;/p&gt;

&lt;p&gt;幸运的是，我们用的是Python！&lt;/p&gt;

&lt;p&gt;Python已经为我们提供了一个线程安全队列：&lt;a href=&quot;http://docs.python.org/2/library/queue.html&quot;&gt;Queue&lt;/a&gt;，它为多个”生产者-消费者”提供了安全同步队列。引用官方的一句话便是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt; module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;的创建、使用也极为轻便  &lt;br /&gt;
创建&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import Queue
queue = Queue.Queue()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;item_1 = queue.get()     # queue.get() =&amp;gt; 从队列中移除一个item并返回该item
queue.put(item_2)        # queue.put() =&amp;gt; 往队列中添加一个item
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;Queue&lt;/code&gt;更高要求的操作与使用，请查看&lt;a href=&quot;http://docs.python.org/2/library/queue.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;23-html内容提取&quot;&gt;2.3 HTML内容提取&lt;/h3&gt;

&lt;p&gt;该部分内容，其实是对类&lt;code class=&quot;highlighter-rouge&quot;&gt;QiubaiReader&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;fetchContent(self, pageUrl)&lt;/code&gt;方法的解读。从HTML中获取内容时，我们需要借助第三方开源工具&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;BeautifulSoup&lt;/a&gt;(看最下方应用程序信息)&lt;/p&gt;

&lt;p&gt;为了便于升级改动，我们为类&lt;code class=&quot;highlighter-rouge&quot;&gt;QiubaiReader&lt;/code&gt;声明一个类成员变量&lt;code class=&quot;highlighter-rouge&quot;&gt;argsDict&lt;/code&gt;，用来统一糗事百科HTML页面源码中的一些关键性的标记及属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;argsDict = {
        'pageEncoding'  : 'utf-8',                                 #糗百html的编码格式
        'dadClassAttr'  : 'block untagged mb15 bs2',               #某条糗百整个大&amp;lt;div /&amp;gt;块的class属性
        'contClassAttr' : 'content',                               #某条糗百的正文所在&amp;lt;div /&amp;gt;块的class属性
        'picClassAttr'  : 'thumb',                                 #包含图片的&amp;lt;div /&amp;gt;块的class属性
        'voteClassAttr' : 'bar',                                   #包含投票数的&amp;lt;div /&amp;gt;块的class属性
        #包含糗百ID的那一行的id号前的前缀，例如：'qiushi_tag_55611097'
        'idLinePreStr'  : 'qiushi_tag_',                           
        #某条糗百只有点赞数超过该值，才进行收录。题目要求该值为5000，本人感觉偏高，故将其改成了2000
        'validCountNum' : 2000,                                    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;糗百每一个页面会包含20条糗百文章，读者可以&lt;a href=&quot;https://code.csdn.net/snippets/156535/master/qiubai_content/raw&quot;&gt;点此查看&lt;/a&gt;其中某条糗百文章的HTML源码及其标记结构。&lt;/p&gt;

&lt;p&gt;我们会发现糗百文章的HTML标记结构如下（我们姑且把如下&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div /&amp;gt;&lt;/code&gt;块称作&lt;code class=&quot;highlighter-rouge&quot;&gt;文章的&amp;lt;div /&amp;gt;&lt;/code&gt;块吧）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;block untagged mb15 bs2&quot; id='qiushi_tag_idxxxxxx'&amp;gt;
    &amp;lt;div class=&quot;content&quot; title=&quot;2014-01-14 16:33:29&quot;&amp;gt;
        糗百正文
    &amp;lt;/div&amp;gt;
    &amp;lt;!--除非文章配有图片，否则下面这个div不会出现--&amp;gt;
    &amp;lt;div class=&quot;thumb&quot;&amp;gt;
        &amp;lt;a href=&quot;/article/url...&quot; target=&quot;_blank&quot; onclick=&quot;some js&quot;&amp;gt;
            &amp;lt;img src=&quot;http://the/pic/URL&quot; alt=&quot;图片描述&quot; /&amp;gt;
        &amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
...
一个页面中会有20个上述结构出现，也就是20条糗百文章
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;以下的任务是，解析给定页面中的所有糗百文章，获取它们的点赞数、ID、正文以及图片链接（如果有的话）。这些解析工作需要借助&lt;code class=&quot;highlighter-rouge&quot;&gt;BeautifulSoup&lt;/code&gt;工具来完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step 1:&lt;/strong&gt;我们首先引入&lt;code class=&quot;highlighter-rouge&quot;&gt;BeautifulSoup&lt;/code&gt;，并实例化一个可操作的HTML结构体：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import urllib2
from bs4 import BeautifulSoup
#获取给定页面pageURL的HTML源码
pageCont = urllib2.urlopen(pageURL).read().decode(self.argsDict['pageEncoding'])
#将HTML源码传递给BeautifulSoup，实例化一个它的对象
soup = BeautifulSoup(pageCont)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;step 2:&lt;/strong&gt; 获得给定页面的所有20个上述的&lt;code class=&quot;highlighter-rouge&quot;&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块&lt;/p&gt;

&lt;p&gt;HTML是标记性语言，即使其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记(tag)出现了很多次，而且分布杂乱，但我们可以根据一个&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记的多个属性来唯一确定某类/某个标记。
例如&lt;code class=&quot;highlighter-rouge&quot;&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块的属性是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;block untagged mb15 bs2&quot; id='qiushi_tag_idxxxxxx' &amp;gt;&amp;lt;/div&amp;gt;
即：
class = &quot;block untagged mb15 bs2&quot;
id = &quot;qiushi_tag_idxxxxxx&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块的&lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt;属性不确定，但它的&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;属性是确定且唯一的，我们就使用它的&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;属性来找到这20个&lt;code class=&quot;highlighter-rouge&quot;&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块，并把它们保存到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;articles_div_list = soup.find_all('div', attrs={'class': 'block untagged mb15 bs2'})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;step 3:&lt;/strong&gt;接下来，我们遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;articles_div_list&lt;/code&gt;，并从中解析出我们需要的糗百信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for div_article in articles_div_list:
    ...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;step 3.1 获得点赞数（&lt;a href=&quot;https://code.csdn.net/snippets/156687/master/div_mark_vote/raw&quot;&gt;点此查看&lt;/a&gt;点赞内容所在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div_vote = div_article.find('div', attrs={'class': 'bar'})  #用给定的属性键值对（class='bar')查找某个标记（tag）
upCount = div_vote.a.get_text()                      #通过 标记.字标记.get_text() 方法获得字标记的text
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;step 3.2 获得ID（&lt;a href=&quot;https://code.csdn.net/snippets/156695/master/div_mark_id/raw&quot;&gt;点此查看&lt;/a&gt;ID内容所在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;idLine = div_article.attrs['id']  #想要获得某个标记（tag）的属性，可以直接查字典一样，此处key为某个属性的name
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;step 3.3 获得正文（&lt;a href=&quot;https://code.csdn.net/snippets/156709/master/div_mark_cont/raw&quot;&gt;点此查看&lt;/a&gt;正文内容所在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div_cont = div_article.find('div', attrs={'class': 'content'})
qiubai_cont = div_cont.get_text()                #通过标记的 get_text() 方法获得该标记的text
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;step 3.4 获得配图的URL（如果有的话。&lt;a href=&quot;https://code.csdn.net/snippets/156693/master/div_mark_pic_url/raw&quot;&gt;点此查看&lt;/a&gt;配图URL内容所在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div_pic = div_article.find('div', attrs={'class': 'thumb'})
if div_pic:
    #想要获得某个标记（tag）的子标记的子标记...的属性，可以直接通过 .(英文句点) 索引至该标记，然后像查字典一样查找即可
    picURL = div_pic.a.img['src']
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24-存储内容&quot;&gt;2.4 存储内容&lt;/h3&gt;

&lt;p&gt;因为糗百内容要存储到xml文档中，我们在这里还要使用Python自带的操作XML的包：&lt;code class=&quot;highlighter-rouge&quot;&gt;xml.etree.ElementTree&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step 1：&lt;/strong&gt;我们首先创建一个用于存储糗百的xml文档：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fo = open('qiubai.xml', 'w')
fo.write('&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;\n&amp;lt;ROOT&amp;gt;&amp;lt;/ROOT&amp;gt;')
fo.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时的xml文件看起来应该是这个样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;ROOT&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ROOT&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;step 2：&lt;/strong&gt;给&lt;code class=&quot;highlighter-rouge&quot;&gt;qiubai.xml&lt;/code&gt;添加一条糗百内容&lt;/p&gt;

&lt;p&gt;step 2.1：获得&lt;code class=&quot;highlighter-rouge&quot;&gt;qiubai.xml&lt;/code&gt;文档的根节点&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import xml.etree.ElementTree as ET
tree = ET.parse('qiubai.xml')       #也可以给 parse() 传递文档路径
root = tree.getroot()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;step 2.2：为根节点&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;添加一个子节点&lt;code class=&quot;highlighter-rouge&quot;&gt;QiuBai&lt;/code&gt;，并设置该子节点的各个属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;qiubai = ET.SubElement(root, 'QiuBai')
qiubai.set('id', 'idxxxxxx')
qiubai.set('picURL', 'http://here/is/pic/url.jpg')
qiubai.text = '此处为糗百正文...'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;step 2.3：将添加了新内容的&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;保存到文档&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tree = ET.ElementTree(root)
tree.write('qiubai.xml', encoding='utf-8', xml_declaration=True)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;此时的xml文档看起来应该是这样子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;ROOT&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;QiuBai&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'idxxxxxx'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;picURL=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'http://here/is/pic/url.jpg'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        此处为糗百正文...
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/QiuBai&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ROOT&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;注意事项：如果你使用的是UTF-8格式保存xml文档，那你需要注意：xml文档规范并不支持所有的UTF-8支持的字符，也就是说有些UTF-8支持的字符在xml文档中是不受支持的，如果你坚持写入，则在再次读取xml文档是会出错。&lt;/p&gt;

&lt;p&gt;关于过滤xml不支持字符的内容，请参看源码 &lt;code class=&quot;highlighter-rouge&quot;&gt;QiubaiReader.py&lt;/code&gt; » &lt;code class=&quot;highlighter-rouge&quot;&gt;def replaceHellWord(text)&lt;/code&gt;方法&lt;/p&gt;

&lt;h2 id=&quot;3-源代码&quot;&gt;3. 源代码&lt;/h2&gt;

&lt;p&gt;到&lt;a href=&quot;https://github.com/HelloLyfing/Tiny_Projects/tree/master/WebSpider&quot;&gt;这里&lt;/a&gt;查看源码，或者直接&lt;a href=&quot;https://github.com/HelloLyfing/Tiny_Projects/raw/master/WebSpider/web_spider.tar&quot;&gt;点我&lt;/a&gt;下载源码。&lt;/p&gt;

&lt;p&gt;应用程序信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本程序在Window7平台下开发完成并测试通过；在CentOS 6.3下测试通过&lt;/li&gt;
  &lt;li&gt;Python &lt;code class=&quot;highlighter-rouge&quot;&gt;2.7.5 [MSC v.1500 64 bit (AMD64)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;xml.etree.ElementTree &lt;code class=&quot;highlighter-rouge&quot;&gt;1.3.0&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;键入 &lt;code class=&quot;highlighter-rouge&quot;&gt;import xml.etree.ElementTree&lt;/code&gt;； &lt;code class=&quot;highlighter-rouge&quot;&gt;ElementTree.VERSION&lt;/code&gt; 查看&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Beautiful Soup &lt;code class=&quot;highlighter-rouge&quot;&gt;4.3.2&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;键入 &lt;code class=&quot;highlighter-rouge&quot;&gt;import bs4&lt;/code&gt;；&lt;code class=&quot;highlighter-rouge&quot;&gt;bs4.__version__&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/bs4/download/4.3/&quot;&gt;bs4下载链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Tech" /><category term="Python" /><category term="多线程" /><category term="爬虫" /><category term="糗事百科" /><category term="BeautifulSoup" /><summary type="html">最近参加一家公司的远程笔试，其中的一道题目是： 写一个简单的爬虫，把糗事百科今天被顶超过5000的帖子爬出来，注意考虑性能和图片显示。 当时一看很感兴趣，因为看到这道题目后思路很清晰，而且我大学时周围好友都爱看糗百，所以做点有关他们喜欢的产品的信息抓取还是挺有趣的。 好的，闲话就到这里，下面进入正题。 1. 思路 1.1 单线程 or 多线程 单线程按序逐一抓取。这种思路下的实现方式是： 获取糗百所有可供抓取的页面URL，然后把他们放到一个列表里 从列表中取走一条页面URL，将该URL指向页面中的所有糗百文章解析出来 如果文章有附图，则下载至指定目录 将第2步获得的若干糗百文章追加至一个xml文件中 点评：单线程无法充分利用机器的CPU资源和带宽，性能低下，不予考虑 多线程乱序抓取。这种思路下的实现方式是： 创建两个同步队列page_q和pic_q，page_q存放页面URL，pic_q存放图片URL 获取糗百所有可供抓取页面的URL，将这些URL添加到page_q队列 开辟多条抓取解析页面文章的线程，每条线程的具体工作是： 从page_q队列取走一条URL，解析其指向的页面中的糗百文章 将这些文章内容追加到xml文件中(同步访问) 如果文章有附图，则将该附图的链接URL放入pic_q 开辟多条下载图片的线程，每条线程的具体工作是： 从pic_q队列取走一条图片URL，将其命名为idxxxxx.jpg并下载到指定目录 点评：可以充分利用CPU资源及带宽，选择该条思路进行 1.2 如何提取页面内容 思路1：通过正则表达式匹配，然后提取有用信息 思路2：通过第三方HTML内容提取工具提取有用信息 点评：思路2具有更高的扩展性、容错性，选择思路2 2. 实现 2.1 多线程实体 本文设计了两个多线程类，他们都继承自threading.Thread，这两个类是： class QiubaiReader(threading.Thread) class PicDownloader(threading.Thread) 类QiubaiReader要做的工作和本文第1部分 1.1 » 多线程 » 抓取解析页面文章的线程内容一致，以下是它的执行逻辑： &quot;&quot;&quot; 类 QiubaiReader 说明 糗事百科内容的消费者，也是糗事百科文章图片的生产者 消费者：从 pageQueue 里读取一个页面URL，解析该页面所有糗百文章，并将这些文章存储到xml文件中； 生产者：在解析页面时，如果某篇文章附带图片，则把该图片的URL放入 picQueue ,等待图片类的消费者来处理. &quot;&quot;&quot; runFlag = 1 #停止线程的开关 def __init__(self, pageQueue, picQueue, pathDict): ... def fetchContent(self, pageUrl): &quot;&quot;&quot; 每一条糗百，我们需要取出其中的三条信息： 1. 该条糗百的ID 2. 该条糗百的正文 3. 该条糗百的图片链接(可能为空，非空则等待下载) 爬取糗百的步骤是： 1. 获得该条糗百的整个大&amp;lt;div /&amp;gt;块，我们声明 div_dad 变量代表这个大&amp;lt;div /&amp;gt;块 2. 通过查找当前投票数的&amp;lt;div /&amp;gt;相关值来判断是否继续，如果投票数大于5000，则继续 3. 在大&amp;lt;div /&amp;gt;块的首行，截取该条糗百的文章ID号（每条糗百都是一篇文章，通过文章ID可以获取文章和图片的链接） 4. 在大div块中，找出带有糗百正文的&amp;lt;div /&amp;gt;块 5. 将上面提到的三条信息写入xml文件 &quot;&quot;&quot; ... def writeContent(self, list): &quot;&quot;&quot; 将list中包含的糗百文章格式化并一次性插入到xml文件中 list中包含有某个页面的所有糗百文章（一般是20条） list结构为： [ { 'id': qiuID1, 'content': qiuBaiText, 'picURL': picURL }, ... ] &quot;&quot;&quot; ... def run(self): while not self.pageQueue.empty() and self.__class__.runFlag &amp;gt; 0: #糗百页面消费者 pageUrl = self.pageQueue.get() qiuBaiList, picDictList = self.fetchContent(pageUrl) if len(qiuBaiList) &amp;gt;= 1: self.writeContent(qiuBaiList) #糗百图片生产者 if len(picDictList) &amp;gt;= 1: for item in picDictList: self.picQueue.put(item) #如果两个队列都为空，则线程退出，并通知图片下载线程也退出 if self.pageQueue.empty() and self.picQueue.empty(): ... 类PicDownloader要做的工作和本文第1部分 1.1 » 多线程 » 下载图片的线程内容一致，以下是它的执行逻辑： # 类 PicDownloader 说明 runFlag = 1 #线程停止开关 def __init__(self, queue, pathDict): ... def downloadPic(self, picDict): ... def run(self): while self.__class__.runFlag &amp;gt; 0: while not self.queue.empty(): picDict = self.queue.get() self.downloadPic(picDict) time.sleep(1) #如果图片URL队列为空，则等待一秒 2.2 线程安全队列 本文涉及到的两个队列page_q和pic_q，一个用来存取页面URL，另一个用来存取图片URL，两队列都面临着多线程同步存取的问题，而这则是所有的”生产者-消费者问题”必须解决的问题。 幸运的是，我们用的是Python！ Python已经为我们提供了一个线程安全队列：Queue，它为多个”生产者-消费者”提供了安全同步队列。引用官方的一句话便是： The Queue module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads. 而且Queue的创建、使用也极为轻便 创建 import Queue queue = Queue.Queue() 使用 item_1 = queue.get() # queue.get() =&amp;gt; 从队列中移除一个item并返回该item queue.put(item_2) # queue.put() =&amp;gt; 往队列中添加一个item 对Queue更高要求的操作与使用，请查看官方文档。 2.3 HTML内容提取 该部分内容，其实是对类QiubaiReader中的fetchContent(self, pageUrl)方法的解读。从HTML中获取内容时，我们需要借助第三方开源工具BeautifulSoup(看最下方应用程序信息) 为了便于升级改动，我们为类QiubaiReader声明一个类成员变量argsDict，用来统一糗事百科HTML页面源码中的一些关键性的标记及属性 argsDict = { 'pageEncoding' : 'utf-8', #糗百html的编码格式 'dadClassAttr' : 'block untagged mb15 bs2', #某条糗百整个大&amp;lt;div /&amp;gt;块的class属性 'contClassAttr' : 'content', #某条糗百的正文所在&amp;lt;div /&amp;gt;块的class属性 'picClassAttr' : 'thumb', #包含图片的&amp;lt;div /&amp;gt;块的class属性 'voteClassAttr' : 'bar', #包含投票数的&amp;lt;div /&amp;gt;块的class属性 #包含糗百ID的那一行的id号前的前缀，例如：'qiushi_tag_55611097' 'idLinePreStr' : 'qiushi_tag_', #某条糗百只有点赞数超过该值，才进行收录。题目要求该值为5000，本人感觉偏高，故将其改成了2000 'validCountNum' : 2000, } 糗百每一个页面会包含20条糗百文章，读者可以点此查看其中某条糗百文章的HTML源码及其标记结构。 我们会发现糗百文章的HTML标记结构如下（我们姑且把如下&amp;lt;div /&amp;gt;块称作文章的&amp;lt;div /&amp;gt;块吧）： &amp;lt;div class=&quot;block untagged mb15 bs2&quot; id='qiushi_tag_idxxxxxx'&amp;gt; &amp;lt;div class=&quot;content&quot; title=&quot;2014-01-14 16:33:29&quot;&amp;gt; 糗百正文 &amp;lt;/div&amp;gt; &amp;lt;!--除非文章配有图片，否则下面这个div不会出现--&amp;gt; &amp;lt;div class=&quot;thumb&quot;&amp;gt; &amp;lt;a href=&quot;/article/url...&quot; target=&quot;_blank&quot; onclick=&quot;some js&quot;&amp;gt; &amp;lt;img src=&quot;http://the/pic/URL&quot; alt=&quot;图片描述&quot; /&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ... 一个页面中会有20个上述结构出现，也就是20条糗百文章 ... 以下的任务是，解析给定页面中的所有糗百文章，获取它们的点赞数、ID、正文以及图片链接（如果有的话）。这些解析工作需要借助BeautifulSoup工具来完成。 step 1:我们首先引入BeautifulSoup，并实例化一个可操作的HTML结构体： import urllib2 from bs4 import BeautifulSoup #获取给定页面pageURL的HTML源码 pageCont = urllib2.urlopen(pageURL).read().decode(self.argsDict['pageEncoding']) #将HTML源码传递给BeautifulSoup，实例化一个它的对象 soup = BeautifulSoup(pageCont) step 2: 获得给定页面的所有20个上述的文章&amp;lt;div /&amp;gt;块 HTML是标记性语言，即使其中的&amp;lt;div&amp;gt;标记(tag)出现了很多次，而且分布杂乱，但我们可以根据一个&amp;lt;div&amp;gt;标记的多个属性来唯一确定某类/某个标记。 例如文章&amp;lt;div /&amp;gt;块的属性是： &amp;lt;div class=&quot;block untagged mb15 bs2&quot; id='qiushi_tag_idxxxxxx' &amp;gt;&amp;lt;/div&amp;gt; 即： class = &quot;block untagged mb15 bs2&quot; id = &quot;qiushi_tag_idxxxxxx&quot; 文章&amp;lt;div /&amp;gt;块的id属性不确定，但它的class属性是确定且唯一的，我们就使用它的class属性来找到这20个文章&amp;lt;div /&amp;gt;块，并把它们保存到一个list中 articles_div_list = soup.find_all('div', attrs={'class': 'block untagged mb15 bs2'}) step 3:接下来，我们遍历articles_div_list，并从中解析出我们需要的糗百信息 for div_article in articles_div_list: ... step 3.1 获得点赞数（点此查看点赞内容所在&amp;lt;div&amp;gt;标记） div_vote = div_article.find('div', attrs={'class': 'bar'}) #用给定的属性键值对（class='bar')查找某个标记（tag） upCount = div_vote.a.get_text() #通过 标记.字标记.get_text() 方法获得字标记的text step 3.2 获得ID（点此查看ID内容所在&amp;lt;div&amp;gt;标记） idLine = div_article.attrs['id'] #想要获得某个标记（tag）的属性，可以直接查字典一样，此处key为某个属性的name step 3.3 获得正文（点此查看正文内容所在&amp;lt;div&amp;gt;标记） div_cont = div_article.find('div', attrs={'class': 'content'}) qiubai_cont = div_cont.get_text() #通过标记的 get_text() 方法获得该标记的text step 3.4 获得配图的URL（如果有的话。点此查看配图URL内容所在&amp;lt;div&amp;gt;标记） div_pic = div_article.find('div', attrs={'class': 'thumb'}) if div_pic: #想要获得某个标记（tag）的子标记的子标记...的属性，可以直接通过 .(英文句点) 索引至该标记，然后像查字典一样查找即可 picURL = div_pic.a.img['src'] 2.4 存储内容 因为糗百内容要存储到xml文档中，我们在这里还要使用Python自带的操作XML的包：xml.etree.ElementTree step 1：我们首先创建一个用于存储糗百的xml文档： fo = open('qiubai.xml', 'w') fo.write('&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;\n&amp;lt;ROOT&amp;gt;&amp;lt;/ROOT&amp;gt;') fo.close() 此时的xml文件看起来应该是这个样子： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;ROOT&amp;gt; &amp;lt;/ROOT&amp;gt; step 2：给qiubai.xml添加一条糗百内容 step 2.1：获得qiubai.xml文档的根节点 import xml.etree.ElementTree as ET tree = ET.parse('qiubai.xml') #也可以给 parse() 传递文档路径 root = tree.getroot() step 2.2：为根节点root添加一个子节点QiuBai，并设置该子节点的各个属性 qiubai = ET.SubElement(root, 'QiuBai') qiubai.set('id', 'idxxxxxx') qiubai.set('picURL', 'http://here/is/pic/url.jpg') qiubai.text = '此处为糗百正文...' step 2.3：将添加了新内容的root保存到文档 tree = ET.ElementTree(root) tree.write('qiubai.xml', encoding='utf-8', xml_declaration=True) 此时的xml文档看起来应该是这样子： &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt; &amp;lt;ROOT&amp;gt; &amp;lt;QiuBai id='idxxxxxx' picURL='http://here/is/pic/url.jpg'&amp;gt; 此处为糗百正文... &amp;lt;/QiuBai&amp;gt; &amp;lt;/ROOT&amp;gt; 注意事项：如果你使用的是UTF-8格式保存xml文档，那你需要注意：xml文档规范并不支持所有的UTF-8支持的字符，也就是说有些UTF-8支持的字符在xml文档中是不受支持的，如果你坚持写入，则在再次读取xml文档是会出错。 关于过滤xml不支持字符的内容，请参看源码 QiubaiReader.py » def replaceHellWord(text)方法 3. 源代码 到这里查看源码，或者直接点我下载源码。 应用程序信息： 本程序在Window7平台下开发完成并测试通过；在CentOS 6.3下测试通过 Python 2.7.5 [MSC v.1500 64 bit (AMD64)] xml.etree.ElementTree 1.3.0 键入 import xml.etree.ElementTree； ElementTree.VERSION 查看 Beautiful Soup 4.3.2 键入 import bs4；bs4.__version__ bs4下载链接</summary></entry></feed>