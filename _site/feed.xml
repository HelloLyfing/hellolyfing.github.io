<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
<title type="text">Lyfing.Loo's Blog</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http://localhost:4000/feed.xml" />
<link rel="alternate" type="text/html" href="http://localhost:4000" />
<updated>2014-06-30T10:32:15+08:00</updated>
<id>http://localhost:4000/</id>
<author>
  <name>Lyfing.Loo</name>
  <uri>http://localhost:4000/</uri>
  <email>hellolyfing@gmail.com</email>
</author>


<entry>
  <title type="html"><![CDATA[通过XHR上传浏览器缓存的图片资源]]></title>
  <link>http://localhost:4000/2014/06/28/upload-browser-cached-image-by-using-xhr.html</link>
  <id>http://localhost:4000/2014/06/28/upload-browser-cached-image-by-using-xhr</id>
  <published>2014-06-28T00:00:00+08:00</published>
  <updated>2014-06-28T00:00:00+08:00</updated>
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;最近在为公司开发一个&lt;a href=&quot;https://chrome.google.com/webstore/detail/obnbgneldjmmpgkbnnbiiinijmiclpaa&quot;&gt;海淘的Chrome扩展&lt;/a&gt;，扩展的需求之一是：获取当前页面中的某张图片，并将其上传至公司的服务器保存。&lt;/p&gt;

&lt;p&gt;当时的第一思路是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;获取图片的URL，然后把URL提交给服务器，让服务器进行下载操作&lt;/li&gt;
  &lt;li&gt;如果服务器访问图片资源时被拒绝，就需要让用户手动下载该图片，然后手动上传至我们的服务器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过在后来的实践中发现，其实可以直接通过发起&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt;请求的方式读取图片的缓存，然后将该缓存数据(图片资源)上传至服务器。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;em&gt;在这里首先要说明一点是的：这种将缓存数据当作文件上传的思路，通常是需要&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot;&gt;跨站请求资源&lt;/a&gt;(Cross-site HTTP requests)的，所以除非是在允许跨站请求的运行环境中（如Chrome扩展内）运行这些JS，否则这种思路几乎不可用&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;思路&lt;/h3&gt;
&lt;p&gt;这种直接通过发起&lt;code&gt;XHR&lt;/code&gt;请求来获取图片资源的思路，最先来自这里&lt;a href=&quot;http://stackoverflow.com/a/10002486/1241980&quot;&gt;upload-a-file-in-a-google-chrome-extension&lt;/a&gt;。基本思路是：浏览器对页面渲染时下载的文件(&lt;code&gt;image&lt;/code&gt;、&lt;code&gt;css&lt;/code&gt;、&lt;code&gt;js&lt;/code&gt;)都有缓存，此时可以手动发起一个对页面中某个文件的&lt;code&gt;XHR&lt;/code&gt;请求，浏览器会直接从本地缓存中取到数据(上述文件的&lt;a href=&quot;http://stackoverflow.com/a/4480318/1241980&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header一般都标识为可缓存)作为响应，我们则可以把这些数据当作”文件”来上传至服务器。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;怎么做&lt;/h3&gt;
&lt;p&gt;1) 通过XHR请求一个图片资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var imgURL = &#39;http://lyfing.qiniudn.com/external_links/pocker_cards_family.png&#39;;
var xhr = new XMLHttpRequest(); 
xhr.open(&quot;GET&quot;, imgURL, true);
xhr.responseType = &quot;blob&quot;;
xhr.onload = function(){
    var blob = xhr.response;
    var msg = &#39; Request URL = \n &#39; + imgURL;
    msg += &#39;\n\n Get Response !&#39;;
    msg += &#39;\n responseType = &#39; + blob.type;
    msg += &#39;\n responseSize = &#39; + Math.round(blob.size / 1024) + &#39;KB&#39;;
    alert(msg);
};
xhr.send();
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function getIMGRes(){
    var imgURL = &#39;http://lyfing.qiniudn.com/external_links/pocker_cards_family.png&#39;;
    var xhr = new XMLHttpRequest(); 
    xhr.open(&quot;GET&quot;, imgURL, true);
    xhr.responseType = &quot;blob&quot;;
    xhr.onload = function(){
        var blob = xhr.response;
        var msg = &#39; Request URL = \n &#39; + imgURL;
        msg += &#39;\n\n Get Response !&#39;;
        msg += &#39;\n responseType = &#39; + blob.type;
        msg += &#39;\n responseSize = &#39; + Math.round(blob.size / 1024) + &#39;KB&#39;;
        alert(msg);
    };
    xhr.send();
};
&lt;/script&gt;

&lt;p&gt;&lt;input type=&quot;button&quot; onclick=&quot;getIMGRes();&quot; value=&quot;点击测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2) 将返回的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Blob&quot;&gt;Blob&lt;/a&gt;对象上传至服务器&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 直接使用上一步获得的blob对象
var blob = xhr1.response;
// 我们可以直接使用FormData构建Form表单
var formData = new FormData();
// 获取文件类型(例如: blob.type = &#39;image/png&#39;)
var fileType = blob.type.split(&#39;/&#39;)[1]; 
// 
formData.append(&#39;file&#39;, blob, &#39;test001.&#39; + fileType);

var xhr2 = new XMLHttpRequest();

xhr2.upload.onprogress = function(event){
    ...
    $msg2.html(&#39;正在上传 ( &#39; + percent + &#39;% )&#39;);
}

xhr2.onload = function(){
    if ( !confirm(&#39;上传完成！即将跳转至上传结果页...&#39;) ) return;
    // 返回结果是一段纯文本，我们用正则取出本次上传的信息链接
    var url = xhr2.response.match(/http:\/\/[^\s]+/)[0];
    window.open(url);
}

xhr2.open(&#39;POST&#39;, &#39;http://posttestserver.com/post.php?dir=example&#39;, true);
xhr2.send(formData);
&lt;/code&gt;&lt;/pre&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
function upload(){
    var imgURL = &#39;http://lyfing.qiniudn.com/external_links/pocker_cards_family.png&#39;;
    var xhr1 = new XMLHttpRequest();
    xhr1.open(&quot;GET&quot;, imgURL, true);
    xhr1.responseType = &quot;blob&quot;;
    xhr1.onload = function(){
        var blob = xhr1.response;
        var formData = new FormData();
        var fileType = blob.type.split(&#39;/&#39;)[1];
        formData.append(&#39;file&#39;, blob, &#39;test001.&#39; + fileType);

        var xhr = new XMLHttpRequest();
        
        xhr.upload.onprogress = function(event){
            var $msg2 = $(&#39;#part2Msg&#39;);
            var percent = Math.floor(event.position / event.totalSize * 100);
            $msg2.html(&#39;正在上传 ( &#39; + percent + &#39;% )&#39;);
        }

        xhr.onload = function(){
            if ( !confirm(&#39;上传完成！即将跳转至上传结果页...&#39;) ) return;
            var url = xhr.response.match(/http:\/\/[^\s]+/)[0];
            window.open(url);
        }
        
        xhr.open(&#39;POST&#39;, &#39;http://posttestserver.com/post.php?dir=example&#39;, true);
        xhr.send(formData);        
    };
    xhr1.send(); 
}
&lt;/script&gt;

&lt;p&gt;&lt;input type=&quot;button&quot; onclick=&quot;upload();&quot; value=&quot;点击测试&quot; /&gt; &lt;span id=&quot;part2Msg&quot;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;用到的一些&lt;code&gt;对象&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;上面我们用到了&lt;code&gt;FormData&lt;/code&gt;对象(&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/FormData&quot;&gt;详情&lt;/a&gt;)，它是一个模拟了HTML中的Form表单的实体，你可以直接使用它来构建&lt;code&gt;key/value pair&lt;/code&gt;，其中的&lt;code&gt;value&lt;/code&gt;可以是&lt;code&gt;文件&lt;/code&gt;、&lt;code&gt;Blob&lt;/code&gt;或者纯&lt;code&gt;String&lt;/code&gt;。下面做一个简单的使用示例（Chrome、Firefox可随便使用，IE10+才可使用)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 创建Form表单对象formData，可在构造函数中传入一个HTML表单对象htmlForm
// 它的键值对会被添加到formData中
var formData = new FormData();
// 添加一个键值对
formData.append(&#39;userID&#39;, &#39;112233&#39;);
// 添加一个文件对象
var file = document.getElementByID(&#39;fileField&#39;);
formData.append(&#39;file1&#39;, file);
// 添加一个Blob对象，它将被视为文件上传
formData.append(&#39;file2&#39;, blob);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于&lt;code&gt;Blob&lt;/code&gt;对象，它是一个类似于&lt;code&gt;文件&lt;/code&gt;的结构体，事实上&lt;code&gt;文件&lt;/code&gt;接口正是在它的基础上做的扩展。&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Blob&quot;&gt;更多关于Blob&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest&quot;&gt;跨站请求HTTP资源&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Blob&quot;&gt;&lt;code&gt;Blob&lt;/code&gt;&lt;/a&gt;对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/FormData&quot;&gt;&lt;code&gt;FormData&lt;/code&gt;&lt;/a&gt;对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例中用到的文件上传服务：http://posttestserver.com/post.php?dir=example&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;示例中用到的图片：&lt;img src=&quot;http://lyfing.qiniudn.com/external_links/pocker_cards_family.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/06/28/upload-browser-cached-image-by-using-xhr.html&quot;&gt;通过XHR上传浏览器缓存的图片资源&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on June 28, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Python爬虫 实现从糗百上多线程抓取内容]]></title>
  <link>http://localhost:4000/2014/01/12/Python-a-web-spider-for-fetching-qiubai-articles.html</link>
  <id>http://localhost:4000/2014/01/12/Python-a-web-spider-for-fetching-qiubai-articles</id>
  <published>2014-01-12T00:00:00+08:00</published>
  <updated>2014-01-12T00:00:00+08:00</updated>
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;最近参加一家公司的远程笔试，其中的一道题目是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;写一个简单的爬虫，把糗事百科今天被顶超过5000的帖子爬出来，注意考虑性能和图片显示。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当时一看很感兴趣，因为看到这道题目后思路很清晰，而且我大学时周围好友都爱看糗百，所以做点有关他们喜欢的产品的信息抓取还是挺有趣的。&lt;/p&gt;

&lt;p&gt;好的，闲话就到这里，下面进入正题。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 思路&lt;/h2&gt;

&lt;h3 id=&quot;or-&quot;&gt;1.1 单线程 or 多线程&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;单线程&lt;/strong&gt;按序逐一抓取。这种思路下的实现方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获取糗百所有可供抓取的页面URL，然后把他们放到一个列表里&lt;/li&gt;
  &lt;li&gt;从列表中取走一条页面URL，将该URL指向页面中的所有糗百文章解析出来&lt;/li&gt;
  &lt;li&gt;如果文章有附图，则下载至指定目录&lt;/li&gt;
  &lt;li&gt;将第2步获得的若干糗百文章追加至一个xml文件中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;点评：单线程无法充分利用机器的CPU资源和带宽，性能低下，不予考虑&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多线程&lt;/strong&gt;乱序抓取。这种思路下的实现方式是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;创建两个&lt;a href=&quot;http://docs.python.org/2/library/queue.html&quot;&gt;同步队列&lt;/a&gt;&lt;code&gt;page_q&lt;/code&gt;和&lt;code&gt;pic_q&lt;/code&gt;，&lt;code&gt;page_q&lt;/code&gt;存放页面URL，&lt;code&gt;pic_q&lt;/code&gt;存放图片URL&lt;/li&gt;
  &lt;li&gt;获取糗百所有可供抓取页面的URL，将这些URL添加到&lt;code&gt;page_q&lt;/code&gt;队列&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开辟多条&lt;strong&gt;抓取解析页面文章的线程&lt;/strong&gt;，每条线程的具体工作是：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;从&lt;code&gt;page_q&lt;/code&gt;队列取走一条URL，解析其指向的页面中的糗百文章&lt;/li&gt;
      &lt;li&gt;将这些文章内容追加到xml文件中(同步访问)&lt;/li&gt;
      &lt;li&gt;如果文章有附图，则将该附图的链接URL放入&lt;code&gt;pic_q&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;开辟多条&lt;strong&gt;下载图片的线程&lt;/strong&gt;，每条线程的具体工作是：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;从&lt;code&gt;pic_q&lt;/code&gt;队列取走一条图片URL，将其命名为&lt;code&gt;idxxxxx.jpg&lt;/code&gt;并下载到指定目录 &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;点评：可以充分利用CPU资源及带宽，选择该条思路进行&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;1.2 如何提取页面内容&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;思路1：通过正则表达式匹配，然后提取有用信息&lt;/li&gt;
  &lt;li&gt;思路2：通过第三方HTML内容提取工具提取有用信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;点评：思路2具有更高的扩展性、容错性，选择思路2&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;2. 实现&lt;/h2&gt;

&lt;h3 id=&quot;section-3&quot;&gt;2.1 多线程实体&lt;/h3&gt;

&lt;p&gt;本文设计了两个多线程类，他们都继承自&lt;code&gt;threading.Thread&lt;/code&gt;，这两个类是：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;class QiubaiReader(threading.Thread)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;class PicDownloader(threading.Thread)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;类&lt;code&gt;QiubaiReader&lt;/code&gt;要做的工作和本文第1部分 &lt;strong&gt;1.1&lt;/strong&gt; » &lt;strong&gt;多线程&lt;/strong&gt; » &lt;strong&gt;抓取解析页面文章的线程&lt;/strong&gt;内容一致，以下是它的执行逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot;&quot;&quot; 类 QiubaiReader 说明
糗事百科内容的消费者，也是糗事百科文章图片的生产者
消费者：从 pageQueue 里读取一个页面URL，解析该页面所有糗百文章，并将这些文章存储到xml文件中；
生产者：在解析页面时，如果某篇文章附带图片，则把该图片的URL放入 picQueue ,等待图片类的消费者来处理.
&quot;&quot;&quot;
runFlag = 1                                                    #停止线程的开关

def __init__(self, pageQueue, picQueue, pathDict):
    ...

def fetchContent(self, pageUrl):
    &quot;&quot;&quot;
    每一条糗百，我们需要取出其中的三条信息：
    1. 该条糗百的ID
    2. 该条糗百的正文
    3. 该条糗百的图片链接(可能为空，非空则等待下载)
    爬取糗百的步骤是：
    1. 获得该条糗百的整个大&amp;lt;div /&amp;gt;块，我们声明 div_dad 变量代表这个大&amp;lt;div /&amp;gt;块
    2. 通过查找当前投票数的&amp;lt;div /&amp;gt;相关值来判断是否继续，如果投票数大于5000，则继续
    3. 在大&amp;lt;div /&amp;gt;块的首行，截取该条糗百的文章ID号（每条糗百都是一篇文章，通过文章ID可以获取文章和图片的链接）
    4. 在大div块中，找出带有糗百正文的&amp;lt;div /&amp;gt;块
    5. 将上面提到的三条信息写入xml文件
    &quot;&quot;&quot;
    ...

def writeContent(self, list):
    &quot;&quot;&quot;
    将list中包含的糗百文章格式化并一次性插入到xml文件中
    list中包含有某个页面的所有糗百文章（一般是20条）
    list结构为：
    [
        {   &#39;id&#39;:       qiuID1,
            &#39;content&#39;:  qiuBaiText,
            &#39;picURL&#39;:   picURL },
        ...
    ]
    &quot;&quot;&quot;
    ...

def run(self):
    while not self.pageQueue.empty() and self.__class__.runFlag &amp;gt; 0:
        #糗百页面消费者
        pageUrl = self.pageQueue.get()
        qiuBaiList, picDictList = self.fetchContent(pageUrl)
        if len(qiuBaiList) &amp;gt;= 1:
            self.writeContent(qiuBaiList)
        #糗百图片生产者
        if len(picDictList) &amp;gt;= 1:
            for item in picDictList: self.picQueue.put(item)

    #如果两个队列都为空，则线程退出，并通知图片下载线程也退出
    if self.pageQueue.empty() and self.picQueue.empty():
        ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类&lt;code&gt;PicDownloader&lt;/code&gt;要做的工作和本文第1部分 &lt;strong&gt;1.1&lt;/strong&gt; » &lt;strong&gt;多线程&lt;/strong&gt; » &lt;strong&gt;下载图片的线程&lt;/strong&gt;内容一致，以下是它的执行逻辑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 类 PicDownloader 说明
runFlag = 1                                                            #线程停止开关

def __init__(self, queue, pathDict):
    ...
def downloadPic(self, picDict):
    ...
def run(self):
    while self.__class__.runFlag &amp;gt; 0:
        while not self.queue.empty():
            picDict = self.queue.get()
            self.downloadPic(picDict)
        time.sleep(1)                                                  #如果图片URL队列为空，则等待一秒
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;2.2 线程安全队列&lt;/h3&gt;

&lt;p&gt;本文涉及到的两个队列&lt;code&gt;page_q&lt;/code&gt;和&lt;code&gt;pic_q&lt;/code&gt;，一个用来存取页面URL，另一个用来存取图片URL，两队列都面临着多线程同步存取的问题，而这则是所有的”生产者-消费者问题”必须解决的问题。&lt;/p&gt;

&lt;p&gt;幸运的是，我们用的是Python！  &lt;/p&gt;

&lt;p&gt;Python已经为我们提供了一个线程安全队列：&lt;a href=&quot;http://docs.python.org/2/library/queue.html&quot;&gt;Queue&lt;/a&gt;，它为多个”生产者-消费者”提供了安全同步队列。引用官方的一句话便是：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;code&gt;Queue&lt;/code&gt; module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而且&lt;code&gt;Queue&lt;/code&gt;的创建、使用也极为轻便  &lt;br /&gt;
创建&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Queue
queue = Queue.Queue()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;item_1 = queue.get()     # queue.get() =&amp;gt; 从队列中移除一个item并返回该item
queue.put(item_2)        # queue.put() =&amp;gt; 往队列中添加一个item
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对&lt;code&gt;Queue&lt;/code&gt;更高要求的操作与使用，请查看&lt;a href=&quot;http://docs.python.org/2/library/queue.html&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;html&quot;&gt;2.3 HTML内容提取&lt;/h3&gt;

&lt;p&gt;该部分内容，其实是对类&lt;code&gt;QiubaiReader&lt;/code&gt;中的&lt;code&gt;fetchContent(self, pageUrl)&lt;/code&gt;方法的解读。从HTML中获取内容时，我们需要借助第三方开源工具&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;BeautifulSoup&lt;/a&gt;(看最下方应用程序信息)&lt;/p&gt;

&lt;p&gt;为了便于升级改动，我们为类&lt;code&gt;QiubaiReader&lt;/code&gt;声明一个类成员变量&lt;code&gt;argsDict&lt;/code&gt;，用来统一糗事百科HTML页面源码中的一些关键性的标记及属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;argsDict = {
        &#39;pageEncoding&#39;  : &#39;utf-8&#39;,                                 #糗百html的编码格式
        &#39;dadClassAttr&#39;  : &#39;block untagged mb15 bs2&#39;,               #某条糗百整个大&amp;lt;div /&amp;gt;块的class属性
        &#39;contClassAttr&#39; : &#39;content&#39;,                               #某条糗百的正文所在&amp;lt;div /&amp;gt;块的class属性
        &#39;picClassAttr&#39;  : &#39;thumb&#39;,                                 #包含图片的&amp;lt;div /&amp;gt;块的class属性
        &#39;voteClassAttr&#39; : &#39;bar&#39;,                                   #包含投票数的&amp;lt;div /&amp;gt;块的class属性
        #包含糗百ID的那一行的id号前的前缀，例如：&#39;qiushi_tag_55611097&#39;
        &#39;idLinePreStr&#39;  : &#39;qiushi_tag_&#39;,                           
        #某条糗百只有点赞数超过该值，才进行收录。题目要求该值为5000，本人感觉偏高，故将其改成了2000
        &#39;validCountNum&#39; : 2000,                                    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;糗百每一个页面会包含20条糗百文章，读者可以&lt;a href=&quot;https://code.csdn.net/snippets/156535/master/qiubai_content/raw&quot;&gt;点此查看&lt;/a&gt;其中某条糗百文章的HTML源码及其标记结构。&lt;/p&gt;

&lt;p&gt;我们会发现糗百文章的HTML标记结构如下（我们姑且把如下&lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt;块称作&lt;code&gt;文章的&amp;lt;div /&amp;gt;&lt;/code&gt;块吧）：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;block untagged mb15 bs2&quot; id=&#39;qiushi_tag_idxxxxxx&#39;&amp;gt;
    &amp;lt;div class=&quot;content&quot; title=&quot;2014-01-14 16:33:29&quot;&amp;gt;
        糗百正文
    &amp;lt;/div&amp;gt;
    &amp;lt;!--除非文章配有图片，否则下面这个div不会出现--&amp;gt;
    &amp;lt;div class=&quot;thumb&quot;&amp;gt;
        &amp;lt;a href=&quot;/article/url...&quot; target=&quot;_blank&quot; onclick=&quot;some js&quot;&amp;gt;
            &amp;lt;img src=&quot;http://the/pic/URL&quot; alt=&quot;图片描述&quot; /&amp;gt;
        &amp;lt;/a&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
...
一个页面中会有20个上述结构出现，也就是20条糗百文章
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以下的任务是，解析给定页面中的所有糗百文章，获取它们的点赞数、ID、正文以及图片链接（如果有的话）。这些解析工作需要借助&lt;code&gt;BeautifulSoup&lt;/code&gt;工具来完成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step 1:&lt;/strong&gt;我们首先引入&lt;code&gt;BeautifulSoup&lt;/code&gt;，并实例化一个可操作的HTML结构体：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import urllib2
from bs4 import BeautifulSoup
#获取给定页面pageURL的HTML源码
pageCont = urllib2.urlopen(pageURL).read().decode(self.argsDict[&#39;pageEncoding&#39;])
#将HTML源码传递给BeautifulSoup，实例化一个它的对象
soup = BeautifulSoup(pageCont)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;step 2:&lt;/strong&gt; 获得给定页面的所有20个上述的&lt;code&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块&lt;/p&gt;

&lt;p&gt;HTML是标记性语言，即使其中的&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记(tag)出现了很多次，而且分布杂乱，但我们可以根据一个&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记的多个属性来唯一确定某类/某个标记。
例如&lt;code&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块的属性是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;block untagged mb15 bs2&quot; id=&#39;qiushi_tag_idxxxxxx&#39; &amp;gt;&amp;lt;/div&amp;gt;
即：
class = &quot;block untagged mb15 bs2&quot;
id = &quot;qiushi_tag_idxxxxxx&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块的&lt;code&gt;id&lt;/code&gt;属性不确定，但它的&lt;code&gt;class&lt;/code&gt;属性是确定且唯一的，我们就使用它的&lt;code&gt;class&lt;/code&gt;属性来找到这20个&lt;code&gt;文章&amp;lt;div /&amp;gt;&lt;/code&gt;块，并把它们保存到一个&lt;code&gt;list&lt;/code&gt;中&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;articles_div_list = soup.find_all(&#39;div&#39;, attrs={&#39;class&#39;: &#39;block untagged mb15 bs2&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;step 3:&lt;/strong&gt;接下来，我们遍历&lt;code&gt;articles_div_list&lt;/code&gt;，并从中解析出我们需要的糗百信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for div_article in articles_div_list:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;step 3.1 获得点赞数（&lt;a href=&quot;https://code.csdn.net/snippets/156687/master/div_mark_vote/raw&quot;&gt;点此查看&lt;/a&gt;点赞内容所在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div_vote = div_article.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;bar&#39;})  #用给定的属性键值对（class=&#39;bar&#39;)查找某个标记（tag）
upCount = div_vote.a.get_text()                      #通过 标记.字标记.get_text() 方法获得字标记的text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;step 3.2 获得ID（&lt;a href=&quot;https://code.csdn.net/snippets/156695/master/div_mark_id/raw&quot;&gt;点此查看&lt;/a&gt;ID内容所在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;idLine = div_article.attrs[&#39;id&#39;]  #想要获得某个标记（tag）的属性，可以直接查字典一样，此处key为某个属性的name
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;step 3.3 获得正文（&lt;a href=&quot;https://code.csdn.net/snippets/156709/master/div_mark_cont/raw&quot;&gt;点此查看&lt;/a&gt;正文内容所在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div_cont = div_article.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;content&#39;})
qiubai_cont = div_cont.get_text()                #通过标记的 get_text() 方法获得该标记的text
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;step 3.4 获得配图的URL（如果有的话。&lt;a href=&quot;https://code.csdn.net/snippets/156693/master/div_mark_pic_url/raw&quot;&gt;点此查看&lt;/a&gt;配图URL内容所在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;标记）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;div_pic = div_article.find(&#39;div&#39;, attrs={&#39;class&#39;: &#39;thumb&#39;})
if div_pic:
    #想要获得某个标记（tag）的子标记的子标记...的属性，可以直接通过 .(英文句点) 索引至该标记，然后像查字典一样查找即可
    picURL = div_pic.a.img[&#39;src&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;2.4 存储内容&lt;/h3&gt;

&lt;p&gt;因为糗百内容要存储到xml文档中，我们在这里还要使用Python自带的操作XML的包：&lt;code&gt;xml.etree.ElementTree&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step 1：&lt;/strong&gt;我们首先创建一个用于存储糗百的xml文档：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fo = open(&#39;qiubai.xml&#39;, &#39;w&#39;)
fo.write(&#39;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;\n&amp;lt;ROOT&amp;gt;&amp;lt;/ROOT&amp;gt;&#39;)
fo.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时的xml文件看起来应该是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;ROOT&amp;gt;
&amp;lt;/ROOT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;step 2：&lt;/strong&gt;给&lt;code&gt;qiubai.xml&lt;/code&gt;添加一条糗百内容&lt;/p&gt;

&lt;p&gt;step 2.1：获得&lt;code&gt;qiubai.xml&lt;/code&gt;文档的根节点&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import xml.etree.ElementTree as ET
tree = ET.parse(&#39;qiubai.xml&#39;)       #也可以给 parse() 传递文档路径
root = tree.getroot()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;step 2.2：为根节点&lt;code&gt;root&lt;/code&gt;添加一个子节点&lt;code&gt;QiuBai&lt;/code&gt;，并设置该子节点的各个属性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qiubai = ET.SubElement(root, &#39;QiuBai&#39;)
qiubai.set(&#39;id&#39;, &#39;idxxxxxx&#39;)
qiubai.set(&#39;picURL&#39;, &#39;http://here/is/pic/url.jpg&#39;)
qiubai.text = &#39;此处为糗百正文...&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;step 2.3：将添加了新内容的&lt;code&gt;root&lt;/code&gt;保存到文档&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tree = ET.ElementTree(root)
tree.write(&#39;qiubai.xml&#39;, encoding=&#39;utf-8&#39;, xml_declaration=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时的xml文档看起来应该是这样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;ROOT&amp;gt;
    &amp;lt;QiuBai id=&#39;idxxxxxx&#39; picURL=&#39;http://here/is/pic/url.jpg&#39;&amp;gt;
        此处为糗百正文...
    &amp;lt;/QiuBai&amp;gt;
&amp;lt;/ROOT&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意事项：如果你使用的是UTF-8格式保存xml文档，那你需要注意：xml文档规范并不支持所有的UTF-8支持的字符，也就是说有些UTF-8支持的字符在xml文档中是不受支持的，如果你坚持写入，则在再次读取xml文档是会出错。&lt;/p&gt;

&lt;p&gt;关于过滤xml不支持字符的内容，请参看源码 &lt;code&gt;QiubaiReader.py&lt;/code&gt; » &lt;code&gt;def replaceHellWord(text)&lt;/code&gt;方法&lt;/p&gt;

&lt;h2 id=&quot;section-6&quot;&gt;3. 源代码&lt;/h2&gt;

&lt;p&gt;到&lt;a href=&quot;https://github.com/HelloLyfing/Tiny_Projects/tree/master/WebSpider&quot;&gt;这里&lt;/a&gt;查看源码，或者直接&lt;a href=&quot;https://github.com/HelloLyfing/Tiny_Projects/raw/master/WebSpider/web_spider.tar&quot;&gt;点我&lt;/a&gt;下载源码。&lt;/p&gt;

&lt;p&gt;应用程序信息：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;本程序在Window7平台下开发完成并测试通过；在CentOS 6.3下测试通过&lt;/li&gt;
  &lt;li&gt;Python &lt;code&gt;2.7.5 [MSC v.1500 64 bit (AMD64)]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;xml.etree.ElementTree &lt;code&gt;1.3.0&lt;/code&gt; &lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;键入 &lt;code&gt;import xml.etree.ElementTree&lt;/code&gt;； &lt;code&gt;ElementTree.VERSION&lt;/code&gt; 查看&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Beautiful Soup &lt;code&gt;4.3.2&lt;/code&gt;                           &lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;键入 &lt;code&gt;import bs4&lt;/code&gt;；&lt;code&gt;bs4.__version__&lt;/code&gt; &lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/bs4/download/4.3/&quot;&gt;bs4下载链接&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/01/12/Python-a-web-spider-for-fetching-qiubai-articles.html&quot;&gt;Python爬虫 实现从糗百上多线程抓取内容&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on January 12, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[关于Python的编码、乱码以及Unicode的一些研究]]></title>
  <link>http://localhost:4000/2014/01/09/study-on-python-unicode-encoding-stuff.html</link>
  <id>http://localhost:4000/2014/01/09/study-on-python-unicode-encoding-stuff</id>
  <published>2014-01-09T00:00:00+08:00</published>
  <updated>2014-01-09T00:00:00+08:00</updated>
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;最近接触Python比较多，尤其是在命令行(Terminal)下进行的局部代码测试有很多。而个人编写的代码通常是以&lt;code&gt;UTF-8&lt;/code&gt;格式存储的，这在Linux下的Terminal上还好一些（它的编码默认的就是中文&lt;code&gt;UTF-8&lt;/code&gt;），要想打印包含中文字符的变量值，基本不会出现乱码情况。但如果是在Windowss下的cmd上进行测试，则相对就要痛苦一些，因为Windows中文环境下cmd的默认编码是&lt;code&gt;GBK&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以本人为了在测试时能正常打印出中文字符（经常Linux、Windows两边跑），对Python字符编码的情况还是颇下了些功夫的。下面就是我做的一些小研究，希望能对和我当初一样迷茫的读者起到些帮助作用。&lt;/p&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;ascii-python&quot;&gt;1. ASCII, Python默认的编码&lt;/h3&gt;

&lt;p&gt;在Python中，当源代码被读取进行语法校验时，会将源代码中的字符从声明的编码转换成&lt;code&gt;Unicode&lt;/code&gt;类型，等到语法校验通过后，再将这些字符转换回初始的编码。&lt;/p&gt;

&lt;p&gt;在Python环境下，源文件中如果没有声明编码，则将其编码设置为默认的&lt;code&gt;ASCII&lt;/code&gt;，这可以通过下面这段代码检验：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.getdefaultencoding()
&#39;ascii&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以在编写源代码文件&lt;code&gt;xxx.py&lt;/code&gt;时需要注意：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;如果源代码没有声明编码格式，则Python在语法校验期间(compilation)使用默认的ASCII编码&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;如果源代码没有声明编码格式，但却在源码中使用了非ASCII字符(Non-ASCII character)，则程序在编译期间抛出&lt;code&gt;SyntaxError&lt;/code&gt;异常，编译不被通过&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;如果源代码声明了Python不支持的编码格式，则程序将在编译期间抛出异常&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;em&gt;源代码文件编码的声明&lt;/em&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;查看如何在源代码中声明编码格式&lt;a href=&quot;http://www.python.org/peps/pep-0263.html&quot;&gt;PEP-0263&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;查看Python支持的&lt;a href=&quot;http://docs.python.org/2/library/codecs.html#standard-encodings&quot;&gt;编码格式&lt;/a&gt;&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;python&quot;&gt;2. 命令行与Python——乱码篇&lt;/h3&gt;
&lt;p&gt;在命令行下的Python Shell中进行小范围测试，或者在命令行中运行Python代码时，总会遇到各种各样的乱码问题。为了搞清楚乱码的原因，我们首先来看这样一个例子。&lt;/p&gt;

&lt;p&gt;例子：文件到底长什么样？&lt;/p&gt;

&lt;p&gt;首先, 在某目录(假设D:\Tem)下创建两个文本文件&lt;code&gt;1.ini&lt;/code&gt;、&lt;code&gt;2.ini&lt;/code&gt;，两个文件中都只写入下面这行内容。不同的是，&lt;code&gt;1.ini&lt;/code&gt;以UTF-8格式保存，&lt;code&gt;2.ini&lt;/code&gt;以GBK格式保存&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;我是Lyfing.Loo，来自中国 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着, 在命令行下，&lt;code&gt;cd&lt;/code&gt;至该目录，键入&lt;code&gt;Python&lt;/code&gt; 进入Python Shell, 读取两个文本文件中的内容，并打印出来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; str1 = open(&#39;1.ini&#39;,&#39;r&#39;).read()     
&amp;gt;&amp;gt;&amp;gt; str2 = open(&#39;2.ini&#39;,&#39;r&#39;).read()    
&amp;gt;&amp;gt;&amp;gt; str1    
&#39;\xef\xbb\xbf\xe6\x88\x91\xe6\x98\xafLyfing.Loo\n&#39;    
#以16进制形式查看1.ini(UTF-8)    
efbb bfe6 8891 e698 af4c 7966 696e 672e 4c6f 6f0d 0a    
&amp;gt;&amp;gt;&amp;gt; str2   
&#39;\xce\xd2\xca\xc7Lyfing.Loo\n&#39;     
#以16进制形式查看2.ini(GBK)    
ced2 cac7 4c79 6669 6e67 2e4c 6f6f 0d0a    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;其中&lt;code&gt;0d0a&lt;/code&gt;是换行符，0d——回车符号——”\r”，0a——换行符号——”\n”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;对比一下&lt;code&gt;str&lt;/code&gt;内容和16进制下查看到的相应文本中的内容，我们不难发现，Python在读取文件时，除了辨认出ASCII编码范围内的字符之外，例如L(4c)、g(67)和o(6f)等，其他非ASCII的字符一律仍按16进制(由&lt;code&gt;0&lt;/code&gt; &lt;code&gt;1&lt;/code&gt;二进制位组成)的原始编码储存，例如 我(efbbbf, utf-8)和我(ced2, gbk)。等到需要将变量值（字符串）打印到控制台，或者写入文件时，这一串原始编码便会原封不动地被提交给相应程序。&lt;/p&gt;

&lt;p&gt;仍是上面的例子，当我们想要打印&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;的值时，我们看看会发生什么：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print str1
锘挎垜鏄疞yfing.Loo
&amp;gt;&amp;gt;&amp;gt; print str2
我是Lyfing.Loo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到，&lt;code&gt;str1&lt;/code&gt;出现了乱码，而&lt;code&gt;str2&lt;/code&gt;则正常打印出了中文字符。这是为什么呢？还是上面那句话：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;等到需要将变量值（字符串）打印到控制台，或者写入文件时，这一串原始编码便会原封不动地被提交给相应程序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当需要打印&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;的值时，Python并不做任何编码转换的处理，它只是原封不动地将原始编码提交给了控制台，由相应的控制台（Windows下的cmd/Linux下的Terminal/SSH远程连接工具等）来进行打印处理。&lt;/p&gt;

&lt;p&gt;所以如果在Linux下的Terminal上打印&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;的话，应该就是&lt;code&gt;str1&lt;/code&gt;正常打印，&lt;code&gt;str2&lt;/code&gt;出现乱码了，因为Terminal的编码一般是UTF-8的。&lt;/p&gt;

&lt;p&gt;那如果想要实现&lt;strong&gt;多平台下表现一致&lt;/strong&gt;的特性的话，比如说保证&lt;code&gt;class&lt;/code&gt;的doc在多平台下打印出的效果一致或者写入效果一致（不会乱码）的话，我们该怎么做？下面引出了本篇内容的重点。&lt;/p&gt;

&lt;h3 id=&quot;unicodepython&quot;&gt;3. Unicode，Python的好伙伴儿&lt;/h3&gt;
&lt;p&gt;一门热门起来的编程语言，首先要满足的需求之一就是，对不同国家和地区所用字符的友好支持。Python很好的做到了这一点，至少，在它正式引入Unicode编码以后是这样。&lt;/p&gt;

&lt;p&gt;我们都知道Python是一门世界通用的编程语言，如果它的源代码文件中出现的都是ASCII支持的字符，那Python会以ASCII编码的格式处理程序。不过，一旦源代码中出现了ASCII不支持的字符，它该怎么办？我用一张图来回答你吧&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lyfing.qiniudn.com/blog/2014-01-09/unicode-in-python.png&quot; alt=&quot;&quot; /&gt;
(图片来源：http://nltk.googlecode.com/svn/trunk/doc/book/ch03.html)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;也就是说，所有超出ASCII范围的字符的处理工作，无论在输入之前，或者输出之后是什么编码格式的，它们在Python的执行内存中，都被统一转换(decode)为Unicode格式来进行程序处理。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;还是上节末尾那个例子，如何保证&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;在各个平台下都能正常打印呢，这里的办法是：将&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;转换成&lt;code&gt;Unicode&lt;/code&gt;类型。&lt;/p&gt;

&lt;h4 id=&quot;unicodestr1str2&quot;&gt;3.1 什么是&lt;code&gt;Unicode&lt;/code&gt;类型？那&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;又是什么类型的呢？&lt;/h4&gt;

&lt;p&gt;我们先看看&lt;code&gt;str1&lt;/code&gt;&lt;code&gt;str2&lt;/code&gt;的类型&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; print type(str1), type(str2)
&amp;lt;type &#39;str&#39;&amp;gt; &amp;lt;type &#39;str&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面可以看出，&lt;code&gt;str1、2&lt;/code&gt;是&lt;code&gt;str&lt;/code&gt;类型的，也就是通常意义下的字符串类型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt;类型则是Python内建的一种用来“一统江湖”的字符类型(type)。 &lt;/p&gt;

&lt;p&gt;既然已经有了用来容纳字符的类型——&lt;code&gt;str&lt;/code&gt;——为何还要添加一种&lt;code&gt;Unicode&lt;/code&gt;字符类型呢？要回答这个问题，我们先来想想如下几个现实中可能会遇到的情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在某个class的&lt;code&gt;doc&lt;/code&gt;中，需要同时用到多个国家的字符和符号来描述class的功用。试想如果此时再用单一的、相对狭隘的编码配合&lt;code&gt;str&lt;/code&gt;来表述，可能出现不可预期的错误。这是因为字符所处的字符集和编码不一致，同一串16进制码(code points)在不同的字符集中可能表示不同的字符，更何况，同一个源代码文件中只可以定义一种编码格式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;xml文件的解析(parse)问题，xml文件中可能包含不同国家和区域的字符和符号，此时如果使用仅适用于某个区域的字符编码，可能出现无法识别某些字符而导致甚至抛异常或程序错误等等糟糕情况。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;于是，一统江湖、或者说差点就一统江湖的&lt;a href=&quot;http://zh.wikipedia.org/wiki/Unicode&quot;&gt;Unicode编码&lt;/a&gt;出现了。再接着，Python为了更加友好地支持各种国家/区域的字符，内建了新的字符容器&lt;code&gt;Unicode&lt;/code&gt;。于是上面两个问题以及近似的一类问题都可以迎刃而解了。&lt;/p&gt;

&lt;h4 id=&quot;unicodepython-1&quot;&gt;3.2 Unicode在Python中的使用&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;Unicode&lt;/code&gt;型的字符容器，在Python的具体应用中有着诸多优势。下面列举几个。&lt;/p&gt;

&lt;p&gt;例子：在源代码中定义&lt;code&gt;Unicode&lt;/code&gt;类型。&lt;br /&gt;
具体步骤，创建&lt;code&gt;test.py&lt;/code&gt;文件，在其中添加这样的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding:utf-8
def hello():
    str1 = u&#39;我是大坏蛋&#39;
    str2 = &#39;你是小淫魔&#39; 
    return (str1, str2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着在命令行&lt;code&gt;cd&lt;/code&gt;至&lt;code&gt;test.py&lt;/code&gt;所在目录，键入&lt;code&gt;python&lt;/code&gt;进入Python Shell，在Shell中输入以下内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; import test
&amp;gt;&amp;gt;&amp;gt; str1, str2 = test.hello()
&amp;gt;&amp;gt;&amp;gt; str1
u&#39;\u6211\u662f\u5927\u574f\u86cb&#39;
&amp;gt;&amp;gt;&amp;gt; str2
&#39;\xe6\x88\x91\xe6\x98\xaf\xe5\xb0\x8f\xe6\xb7\xab\xe9\xad\x94&#39;
&amp;gt;&amp;gt;&amp;gt; print str1
我是大坏蛋
&amp;gt;&amp;gt;&amp;gt; print str2
鎴戞槸灏忔帆榄
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们看到在&lt;code&gt;hello()&lt;/code&gt;定义时，&lt;code&gt;str1&lt;/code&gt;是&lt;code&gt;Unicode&lt;/code&gt;类型的，而&lt;code&gt;str2&lt;/code&gt;则是普通的’str’字符型。也许在这里还没看出&lt;code&gt;Unicode&lt;/code&gt;类型的优势。但是当需要打印变量内容时，二者的优劣便体现出来了：&lt;code&gt;Unicode&lt;/code&gt;类型的&lt;code&gt;str1&lt;/code&gt;无需进行特别编码便能正常打印出中文字符，但&lt;code&gt;str&lt;/code&gt;类型的&lt;code&gt;str2&lt;/code&gt;却出现了乱码情况。&lt;/p&gt;

&lt;p&gt;此处可以介绍&lt;code&gt;Unicode&lt;/code&gt;类型的很多优点了：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;声明简单 只需要在原字符前添加该类型标记&lt;code&gt;u&lt;/code&gt;即可，例如&lt;code&gt;s1 = u&#39;小伙伴儿&#39;&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;代码编译期间，自动从声明的原始编码转码至Unicode，并创建相应的&lt;code&gt;Unicode&lt;/code&gt;类型&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在需要打印(如&lt;code&gt;print&lt;/code&gt;）或者输入输出（如&lt;code&gt;read&lt;/code&gt;或&lt;code&gt;write&lt;/code&gt;）时，&lt;code&gt;Unicode&lt;/code&gt;类型用着尤其顺手。因为你只需要像操作ASCII一样打印和输入输出就行了，而无需关心编码、乱码问题。这是因为Python会帮&lt;code&gt;Unicode&lt;/code&gt;类型的字符做编码转码工作，而这也正是&lt;code&gt;Unicode&lt;/code&gt;类型的字符不会出现乱码的原因。Python工作内容如下：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;当需要输入中文字符时，Python会首先调取字符输入程序（命令行或者read函数）的编码格式，然后将输入的字符以该编码格式进行相应转换，即把原字符转码成&lt;code&gt;Unicode&lt;/code&gt;类型的字符。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;例如在Windows中的命令行下使用的Python Shell，其编码格式是&lt;code&gt;GBK&lt;/code&gt;，当你在shell中键入&lt;code&gt;string1 = u&#39;我是李寻欢&#39;&lt;/code&gt;时，会发生如下事件：&lt;/li&gt;
          &lt;li&gt;1, Python获取当前命令行编码（&lt;code&gt;sys.stdin.encoding&lt;/code&gt;），为cp936(即GBK)&lt;/li&gt;
          &lt;li&gt;2, 将输入的汉字&lt;code&gt;我是李寻欢&lt;/code&gt;按GBK编码转码成Unicode的形式，并据此创建&lt;code&gt;Unicode&lt;/code&gt;类型的字符串，赋值给&lt;code&gt;string1&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;当需要打印输出时，Python会首先调取字符输出程序（命令行或者输出函数）的编码格式，然后将该字符串编码成字符输出程序所用的编码（这样字符输出程序就不会因为认不出编码而出现乱码），接着字符输出程序将编码后的字符输出到目的地。该处理过程是字符输入程序（上一条）的逆过程，此处不再详细介绍这一过程&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;str-typeunicode-type&quot;&gt;3.3 如何将&lt;code&gt;str&lt;/code&gt; type转换成&lt;code&gt;Unicode&lt;/code&gt; type&lt;/h4&gt;

&lt;p&gt;这是本节最开始提出的那个问题：如何将&lt;code&gt;str&lt;/code&gt;类型的字符串&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;转换成&lt;code&gt;Unicode&lt;/code&gt;类型？
这也是下节要谈论的编码与解码的问题。&lt;/p&gt;

&lt;h3 id=&quot;encodedecode&quot;&gt;4. 编码（encode）与解码（decode）&lt;/h3&gt;

&lt;p&gt;如何将&lt;code&gt;str&lt;/code&gt;类型的字符串&lt;code&gt;str1&lt;/code&gt;和&lt;code&gt;str2&lt;/code&gt;转换成&lt;code&gt;Unicode&lt;/code&gt;类型？以及上一节最末提到关于的字符编码在GBK和Unicode之间的转换，涉及到的都是编码与解码的问题。统一来说就是&lt;/p&gt;

&lt;p&gt;从&lt;code&gt;Unicode&lt;/code&gt;类型到GBK或UTF-8等编码的转换，叫做&lt;strong&gt;编码(encode)&lt;/strong&gt;；而这一过程的逆过程，则叫做&lt;strong&gt;解码(decode)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一开始我老是搞不清楚到底从哪到哪是编码，从哪到哪是解码，后来用多了自然也就清楚了。相信初次接触这个概念的人也会有和我一样的困惑，下面用一张图来说明一下编码和解码的方向：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://lyfing.qiniudn.com/blog/2014-01-09/encode-decode.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于解码和编码的实现方法，网上已有很多，这里不再重述。下面引用一篇博客中的内容来做个总结：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串在Python内部的表示是Unicode编码。因此在做编码转换时，通常需要以Unicode作为中间编码，即先将其他编码的字符串解码(decode)成Unicode，再从Unicode编码(encode)成另一种编码。&lt;br /&gt;
 &lt;code&gt;decode&lt;/code&gt;的作用是将其他编码的字符串转换成Unicode编码，如&lt;code&gt;str1.decode(&#39;gb2312&#39;)&lt;/code&gt;，表示将gb2312编码的字符串&lt;code&gt;str1&lt;/code&gt;转换成Unicode编码；&lt;br /&gt;
 &lt;code&gt;encode&lt;/code&gt;的作用是将Unicode编码转换成其他编码的字符串，如&lt;code&gt;str2.encode(&#39;gb2312&#39;)&lt;/code&gt;，表示将Unicode编码的字符串&lt;code&gt;str2&lt;/code&gt;转换成gb2312编码   因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成Unicode，然后再encode成其他编码。（&lt;a href=&quot;http://blog.csdn.net/lxdcyh/article/details/4018054&quot;&gt;原文链接&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;遇到乱码问题，按上述思路分析一遍，再将乱码所在字符串按它的原始编码&lt;code&gt;decode&lt;/code&gt;成Unicode类型的，再使用Unicode类型的编码进行输入、输出即可解决乱码问题。&lt;/p&gt;

&lt;p&gt;ref:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.python.org/2/howto/unicode.html&quot;&gt;http://docs.python.org/2/howto/unicode.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2014/01/09/study-on-python-unicode-encoding-stuff.html&quot;&gt;关于Python的编码、乱码以及Unicode的一些研究&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on January 09, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Labwindows.Tutorial.Chapter 3.Part2]]></title>
  <link>http://localhost:4000/2013/10/20/Labwindows-tutorial-chapter3-part2.html</link>
  <id>http://localhost:4000/2013/10/20/Labwindows-tutorial-chapter3-part2</id>
  <published>2013-10-20T00:00:00+08:00</published>
  <updated>2013-10-20T00:00:00+08:00</updated>
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;h5 id=&quot;the-1st-part&quot;&gt;上接&lt;a href=&quot;http://lanfengming.com/blog/Labwindows-tutorial-chapter3-part1.html/&quot;&gt;第一节&lt;/a&gt;的内容，我们继续本章内容的下半部分。&lt;/h5&gt;

&lt;h3 id=&quot;createguimine-&quot;&gt;5. 编写 &lt;code&gt;createGUI_Mine()&lt;/code&gt; 函数的具体实现&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;createGUI_Mine()&lt;/code&gt;要完成的工作有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;创建一个主面板(即主窗口)&lt;/li&gt;
  &lt;li&gt;在主面板右侧创建一个Graph控件，用以显示Sine波形&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在主面板上创建两个按钮，并分别为他们编写回调函数以实现：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;“Show”按钮：点击后Graph控件上显示出Sine波形，点击后按钮名称变为”Clear”；再次点击该按钮，Graph控件上的Sine波形被清空，按钮名称变回”Show”&lt;/li&gt;
      &lt;li&gt;“Quit”按钮：点击后退出程序&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h4 id=&quot;section&quot;&gt;5.1 创建主面板&lt;/h4&gt;
&lt;p&gt;LabWindows/CVI提供了一系列可创建各种可视化界面的函数和API，创建面板(Panel)的函数当然也包含其中，但它具体是什么，又应该怎么用呢？我们试着从帮助文档中找寻答案。&lt;br /&gt;
打开帮助文档(在LabWindows/CVI的任意界面&lt;strong&gt;按F1快捷键&lt;/strong&gt;，或者从菜单栏 &lt;strong&gt;Help&lt;/strong&gt; &amp;gt;&amp;gt; &lt;strong&gt;Contents F1&lt;/strong&gt;打开)，在&lt;strong&gt;索引&lt;/strong&gt;标签栏下的搜索框中输入&lt;em&gt;Panel&lt;/em&gt;，在列出的一堆搜索结果中寻找 &lt;code&gt;panels (User Interface Editor)&lt;/code&gt; 项，再接着找它的子项 &lt;code&gt;programming with&lt;/code&gt;，双击打开它(&lt;strong&gt;如下图所示&lt;/strong&gt;)：  &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/6480dca9jw1e9w7ha8bigj20ke0gk458.jpg&quot; alt=&quot;F1-Content-Programming-with-Panels.png&quot; /&gt;  &lt;/p&gt;

&lt;div id=&quot;how-to-find-useage&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;PS：想要查找&lt;strong&gt;某个控件object的使用说明&lt;/strong&gt;，可以试着在帮助文档 &amp;gt;&amp;gt; &lt;strong&gt;索引&lt;/strong&gt;标签下的搜索框输入它的名称，在搜索结果中找到它的使用介绍项 &lt;code&gt;object_name (User Interface)&lt;/code&gt;及其子项，以查找相关帮助资料；想要查找&lt;strong&gt;某个具体函数的使用说明&lt;/strong&gt;，方法同上，一般搜索结果第一项便是&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;Programming with Panels&lt;/strong&gt;的帮助文档页面，我们看它的第二段话 &lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;NewPanel creates a new panel during program execution. NewPanel returns a handle that you use in subsequent User Interface Library functions to reference the panel. Use the first parameter of NewPanel to specify whether the panel is created as a top-level window or as a child of another (parent) window. You also specify the name, position, and size of the panel through parameters to NewPanel. Creating a new panel using NewPanel does not automatically display the panel. &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这次请自行读完上面的关于 &lt;code&gt;NewPanel()&lt;/code&gt; 函数的使用介绍，下面我们将直接使用它。如何使用？请在&lt;strong&gt;索引&lt;/strong&gt;标签栏下的搜索框中输入 &lt;code&gt;NewPanel&lt;/code&gt; 打开这个函数的帮助文档。&lt;br /&gt;
 简单介绍一下，&lt;code&gt;NewPanel()&lt;/code&gt; 函数可以创建一个主面板(&lt;em&gt;top-lever panel&lt;/em&gt;)，或一个子面板(&lt;em&gt;child panel&lt;/em&gt;)，这取决于你给它传入的参数。在这里我们要创建一个&lt;em&gt;主面板&lt;/em&gt;，它的各项参数如下：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;面板名称(panelTitle[])：用代码创建的图形界面&lt;/li&gt;
  &lt;li&gt;面板的位置及大小(单位:像素)：距屏幕顶部&lt;strong&gt;60&lt;/strong&gt;，距屏幕左边&lt;strong&gt;300&lt;/strong&gt;，高度&lt;strong&gt;300&lt;/strong&gt;,宽度&lt;strong&gt;600&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;现在，我们可以创建一个主面板了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 为了使创建的主面板居中显示，距屏幕顶部和左边的距离都被换成了系统内部的整型变量VAL_AUTO_CENTER
NewPanel(0, &quot;用代码创建的图形界面&quot;, VAL_AUTO_CENTER, VAL_AUTO_CENTER, 300, 600)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，现在我们整个的代码看起来应该是这个样子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include 
#include      
#include 

static int panelHandle;

int createGUI_Mine(void);

int main (int argc, char *argv[]){
    if (InitCVIRTE (0, argv, 0) == 0)
        return -1;  /* out of memory */
    if ((panelHandle = createGUI_Mine()) &amp;amp;lt; 0)
        return -1;
    DisplayPanel (panelHandle);
    RunUserInterface();
    DiscardPanel (panelHandle);
    return 0;
}

int createGUI_Mine(){
    int pHandle = NewPanel(0, &quot;用代码创建的图形界面&quot;, VAL_AUTO_CENTER, VAL_AUTO_CENTER, 600, 800);
    return pHandle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;div id=&quot;how-to-debug&quot;&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;OK，到了这一步，先让我们试运行一下上面的程序吧&lt;/strong&gt;。运行程序(Debug xxx.exe)的方法有三种：  &lt;/p&gt;

&lt;p&gt;1) 菜单栏 &lt;strong&gt;Run&lt;/strong&gt; &amp;gt;&amp;gt; &lt;strong&gt;Debug src.exe&lt;/strong&gt;
 2) 按快捷键组合 &lt;strong&gt;Shift&lt;/strong&gt; + &lt;strong&gt;F5&lt;/strong&gt;
 3) 鼠标点击如下按钮&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/6480dca9jw1e9w7i9m65sj20hb037mxp.jpg&quot; alt=&quot;Button-Debug-Project.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时会弹出一个错误框，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6480dca9jw1e9w7irfl81j20fh0eemz2.jpg&quot; alt=&quot;Error-Content-Missing.prototype.(Require.function....png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是因为在LabWindows/CVI中，所有自定义的函数都是需要预定义，也就是得在 &lt;code&gt;main()&lt;/code&gt; 函数之前声明原型(prototype)的。&lt;br /&gt;
这好办，只需要把这两个&lt;strong&gt;自定义函数的&lt;em&gt;原型声明&lt;/em&gt;添加到 &lt;code&gt;main()&lt;/code&gt; 函数之前&lt;/strong&gt;就可以了。&lt;strong&gt;但问题是，如何声明原型？&lt;/strong&gt;这里最简单的方法是，随便到帮助文档中找一个工程样例(sample)，看看里面的自定义函数的原型声明的句式便可。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PS：工程样例（sample）是LabWindows/CVI提供的用来演示如何使用某个控件或函数的可直接编译、运行的程序。&lt;strong&gt;工程样例（sample）是快速入门LabWindows/CVI的编程格式及方法的大好捷径，一有机会就打开查看，有百利而无一害。&lt;/strong&gt;如何打开一个工程样例？以 &lt;code&gt;NewPanel()&lt;/code&gt; 函数为例，当你在帮助文档中查找到 &lt;code&gt;NewPanel()&lt;/code&gt; 函数的文档介绍页后，跳到这个页面的最底部，一般会附上若干工程样例，只需用鼠标单击”Open example”前的图标（如下图所示）便可打开这个叫做”userint\buildui.cws”的工程样例。&lt;/em&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6480dca9jw1e9w7j7i5p8j20jk0au0uh.jpg&quot; alt=&quot;NI_Help_How-To-Use-Project-Example.png&quot; /&gt;  &lt;/p&gt;

&lt;p&gt;在打开的”buildui.cws”工程样例中，我们点击&lt;strong&gt;buildui.c&lt;/strong&gt;文件，找到&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/*------------------------------------------------*/
/* Internal function prototypes                   */
/*------------------------------------------------*/ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;区域，根据这个区域下方的自定义函数的原型声明的方法，我们可以看出，对自定义函数的原型声明其实很简单，只需要把这个函数在左大括号——&lt;strong&gt;{&lt;/strong&gt;——之前的内容复制到这里，并在结尾添加行结束标志分号——&lt;strong&gt;；&lt;/strong&gt;——即可。不过需要注意的一点是，无参数的函数，在原型声明时需要它在接收参数的括号&lt;strong&gt;()&lt;/strong&gt;中加入 &lt;code&gt;void&lt;/code&gt; 关键字。具体到本例中，对自定义函数的原型声明句子如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int createGUI_Mine(void);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;好了，把如上内容添加到main()函数的前面，然后再次试运行这个程序，这时会弹出我们刚刚用代码创建的那个图形界面，它目前还只是一个只有标题栏的空白面板(Panel)。效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6480dca9jw1e9w7jq97gjj20h409e3yo.jpg&quot; alt=&quot;Demo-用代码创建的图形界面.png&quot; /&gt;  &lt;/p&gt;

&lt;div id=&quot;how-to-exit-debug-forcely&quot;&gt;&lt;/div&gt;
&lt;p&gt;由于还没设置退出选项，所以这个程序无法正常退出。我们可以到启动它的LabWindows/CVI中关闭它：跳转到LabWindows/CVI界面，点击菜单栏 &lt;strong&gt;Running&lt;/strong&gt; &amp;gt;&amp;gt; &lt;strong&gt;Terminate Execution&lt;/strong&gt;即可（或点击工具栏的&lt;strong&gt;stop&lt;/strong&gt;按钮）。&lt;/p&gt;

&lt;h4 id=&quot;graphsine&quot;&gt;5.2 在主面板右侧创建一个Graph控件，用以显示Sine波形&lt;/h4&gt;
&lt;p&gt;在创建Graph控件前，请先想一下这两个问题：  &lt;/p&gt;

&lt;p&gt;a. Graph控件是依附于哪个实体之上的，它的载体是什么？&lt;br /&gt;
 b. Graph控件的创建工作应该被放在哪个部分？&lt;strong&gt;main()&lt;/strong&gt;函数中、&lt;strong&gt;createGUI_Mine()&lt;/strong&gt;函数中，或者其他地方？&lt;/p&gt;

&lt;p&gt;是不是这样的:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;问题a：像其他的应用软件一样，控制类、显示类的控件都应该至少依附于一个面板(窗口)之上，也就是说这些控件得有个&lt;strong&gt;载体&lt;/strong&gt;。在本章中，Graph控件及其他两个按钮控件(有待创建)都是依附于我们上一步创建的主面板(主界面基本元素)之上的。  &lt;/li&gt;
  &lt;li&gt;问题b：光从名字我们便可以看出，&lt;code&gt;createGUI_Mine()&lt;/code&gt; 函数就是用来完成创建图形界面元素的工作的，所以Graph控件的创建应该被安排到这里。  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;PS：在这里讲&lt;strong&gt;载体&lt;/strong&gt;的概念，是为了之后创建Graph控件时更易理解传入&lt;code&gt;pHandle&lt;/code&gt;的原因，就是因为所有的控件都需要一个载体(如面板)&lt;/em&gt;  &lt;/p&gt;

&lt;p&gt;接下来的问题，Graph控件应该如何创建呢？不知道你发现没，这个问题跟我们上一小节的关于”如何创建一个面板(panel)”的问题非常相似，所以，请你首先试着自己花时间去帮助文档中查找答案(到帮助文档中查找答案的习惯对日后的独立开发有极大帮助，请务必亲试)。  &lt;/p&gt;

&lt;p&gt;在帮助文档页，&lt;strong&gt;索引&lt;/strong&gt;标签栏下的搜索框中输入&lt;em&gt;Graph&lt;/em&gt;，如上一小节查找创建Panel时一样，在搜索结果中我们会找到如下部分的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;graph controls (user interface)
   attribute
   events
   fuctions
   operating
   programming with  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们尝试从&lt;em&gt;programming with&lt;/em&gt;这个页面查找新建graph控件的方法，结果没什么收获。但你看到了，graph control(Graph控件)有一个&lt;em&gt;functions&lt;/em&gt;页面，这里面列出了跟本控件有关的所有函数，我们点进去看看。&lt;br /&gt;
我们要找到的是创建控件的函数，所以函数名应该会带有&lt;em&gt;New&lt;/em&gt;字样，对函数列表逐一查找，便会发现 &lt;code&gt;NewCtrl()&lt;/code&gt; 这个函数。对了！就是用它来创建Graph控件的。打开这个函数的帮助页(如何&lt;a href=&quot;#how-to-find-useage&quot;&gt;打开?&lt;/a&gt;)，你会发现，这个函数不光能用来创建Graph控件，它还可以创建LabWindows/CVI提供的其他所有控件(&lt;a href=&quot;http://zone.ni.com/reference/en-XX/help/370051V-01/cvi/uiref/cvioperating_controls/&quot;&gt;点此查看&lt;/a&gt;控件支持列表)。  &lt;/p&gt;

&lt;p&gt;关于&lt;code&gt;NewCtrl()&lt;/code&gt;函数的用法请自信查看帮助文档。我们这里要创建一个Graph控件，进入 &lt;code&gt;NewCtrl()&lt;/code&gt; 函数帮助页，把第二行的函数结构复制下来：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int NewCtrl (int panelHandle, int controlStyle, char controlLabel[], int controlTop, int controlLeft);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把它插入到 &lt;code&gt;createGUI_Mine()&lt;/code&gt; 函数的第二行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int createGUI_Mine(){
    int pHandle = NewPanel(0, &quot;用代码创建的图形界面&quot;, VAL_AUTO_CENTER, VAL_AUTO_CENTER, 600, 800);
    int NewCtrl (int panelHandle, int controlStyle, char controlLabel[], int controlTop, int controlLeft);        
    return pHandle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;NewCtrl()&lt;/code&gt;创建好Graph控件后，会返回这个Graph控件的资源句柄(handle)，我们创建一个int型变量&lt;code&gt;graphHdl&lt;/code&gt;来接收返回值；&lt;/li&gt;
  &lt;li&gt;参数方面，int型的&lt;em&gt;panelHandle&lt;/em&gt;就用上一步生成的面板资源句柄(pHandle)赋值，即用上一步创建的面板做它的”载体”；&lt;/li&gt;
  &lt;li&gt;int型的&lt;em&gt;controlStyle&lt;/em&gt;：欲创建的控件类型，通过查函数的使用帮助可知，要想创建Graph控件，此处应填 &lt;em&gt;CTRL_GRAPH&lt;/em&gt;；&lt;/li&gt;
  &lt;li&gt;char型的&lt;em&gt;controlLabel[]&lt;/em&gt;：Graph的标签，相当于控件标题，此处使用”Created-Graph”；&lt;/li&gt;
  &lt;li&gt;int型的&lt;em&gt;controlTop&lt;/em&gt;及&lt;em&gt;controlLeft&lt;/em&gt;：该控件相对于它的&lt;strong&gt;载体&lt;/strong&gt;的位置，&lt;em&gt;top&lt;/em&gt;给个&lt;em&gt;30&lt;/em&gt;，&lt;em&gt;left&lt;/em&gt;给个&lt;em&gt;250&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;PS：在编程领域，当需要确定一个矩形框的位置时，我们一般只需要指定它左上角那个点相对于它载体的位置即可，然后再分别给这个矩形框赋予长度和高度值。由于左上角位置已确定，长度、高度也已确定，这个矩形框的大小，及它相对于自身载体的位置便唯一确定了。这就好比在一面墙上画一个矩形，先确定它离墙的顶端和左端的距离（即它左上角点的位置），再已知长度、高度的话，从该点出发依次画出长和高，这个矩形在墙上的最终形状及位置便可以确定下来了。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;于是&lt;code&gt;createGUI_Mine()&lt;/code&gt;函数修改为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int createGUI_Mine(){
    int pHandle = NewPanel(0, &quot;用代码创建的图形界面&quot;, VAL_AUTO_CENTER, VAL_AUTO_CENTER, 600, 800);
    int graphHdl = NewCtrl(pHandle, CTRL_GRAPH, &quot;Created-Graph&quot;, 30, 250);     
    return pHandle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试运行一下程序(&lt;a href=&quot;#how-to-debug&quot;&gt;how?&lt;/a&gt;)，我们可以看到之前空空如也的面板上已经多出来一个graph了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/6480dca9jw1e9w7k54b76j20h009ct9e.jpg&quot; alt=&quot;Demo-添加了graph控件后的图形界面.png&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;showquit&quot;&gt;5.3 在主面板上创建两个按钮：&lt;em&gt;show&lt;/em&gt;、&lt;em&gt;quit&lt;/em&gt;并分别为他们编写回调函数以发挥各自功能&lt;/h4&gt;

&lt;h5 id=&quot;section-1&quot;&gt;5.3.1. 创建按钮&lt;/h5&gt;

&lt;p&gt;请读者想一想，应该用什么函数来创建这两个按钮呢？我给你个提示：按钮属于控件范畴~  &lt;/p&gt;

&lt;p&gt;没错，就是使用&lt;code&gt;NewCtrl()&lt;/code&gt;函数来创建以上两个按钮！创建工作将被而且应该被安排到&lt;code&gt;createGUI_Mine()&lt;/code&gt;函数中，我们把它安排到Graph控件的创建之后。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;show&lt;/strong&gt;按钮的图形参数，即填入&lt;code&gt;NewCtrl()&lt;/code&gt;函数的参数列表：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;panelHandle&lt;/em&gt; = &lt;em&gt;pHandle&lt;/em&gt;，即把本函数第一句创建好的面板作为按钮的”载体”；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;controlStyle&lt;/em&gt; = &lt;em&gt;CTRL_SQUARE_COMMAND_BUTTON&lt;/em&gt;，即方形命令按钮，这个值通过查函数的使用方法可得；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;controlLabel[]&lt;/em&gt; = &lt;em&gt;“show”&lt;/em&gt;，即按钮上显示的文字；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;controlTop&lt;/em&gt; = &lt;em&gt;80&lt;/em&gt; ， &lt;em&gt;controlLeft&lt;/em&gt; = &lt;em&gt;50&lt;/em&gt;，即按钮相对于自己”载体”的上端和左端的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;quit&lt;/strong&gt;按钮的图形参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;panelHandle&lt;/em&gt; = &lt;em&gt;pHandle&lt;/em&gt;，即把本函数第一句创建好的面板作为按钮的”载体”；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;controlStyle&lt;/em&gt; = &lt;em&gt;CTRL_SQUARE_COMMAND_BUTTON&lt;/em&gt;，即方形命令按钮，这个值通过查函数的使用方法可得；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;controlLabel[]&lt;/em&gt; = &lt;em&gt;“quit”&lt;/em&gt;，即按钮上显示的文字；&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;controlTop&lt;/em&gt; = &lt;em&gt;140&lt;/em&gt; ， &lt;em&gt;controlLeft&lt;/em&gt; = &lt;em&gt;50&lt;/em&gt;，即按钮相对于自己”载体”的上端和左端的位置&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们分别用整形变量 &lt;em&gt;showBtn&lt;/em&gt;及&lt;em&gt;quitBtn&lt;/em&gt;来接收创建按钮后返回的资源句柄，于是&lt;code&gt;createGUI_Mine()&lt;/code&gt;函数更新为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int createGUI_Mine(){
    int pHandle = NewPanel(0, &quot;用代码创建的图形界面&quot;, VAL_AUTO_CENTER, VAL_AUTO_CENTER, 300, 600);
    int graphHdl = NewCtrl(pHandle, CTRL_GRAPH, &quot;Created-Graph&quot;, 30, 250);
    int showBtn = NewCtrl(pHandle, CTRL_SQUARE_COMMAND_BUTTON, &quot;Show&quot;, 80, 50);
    int quitBtn = NewCtrl(pHandle, CTRL_SQUARE_COMMAND_BUTTON, &quot;Quit&quot;, 140, 50);
    return pHandle;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试运行一下程序，添加了两个按钮的界面如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/6480dca9jw1e9w7kikah0j20h009ejs5.jpg&quot; alt=&quot;Demo-添加了show-quit-按钮后的图形界面.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到目前为止，我们已经完成了所有界面元素的创建工作。&lt;/p&gt;

&lt;h5 id=&quot;section-2&quot;&gt;5.3.2 为两个按钮编写回调函数&lt;/h5&gt;

&lt;p&gt;&lt;em&gt;PS：请读者首先到 帮助文档 &amp;gt;&amp;gt; 索引 标签栏 下的搜索框中输入&lt;code&gt;callback functions&lt;/code&gt;然后回车以打开关于回调函数的使用说明页面，请大致浏览一下该页面内容。我在这里简单说一下，回调函数(callback functions)是你绑定到某个特定用户界面元素(比如面板、按钮、Graph控件)上，用以响应发生在该元素上的所有用户事件的函数。例如，你可以给&lt;/em&gt;按钮A&lt;em&gt;绑定一个回调函数，并在该回调函数中编写所有可能发生的事件的应对策略，如&lt;/em&gt;按下按钮时做动作1&lt;em&gt;、&lt;/em&gt;按钮抬起时做动作2&lt;em&gt;、&lt;/em&gt;单击按钮时做动作3&lt;em&gt;、&lt;/em&gt;双击按钮时…&lt;em&gt;一旦任意一个事件在该元素上发生，LabWindows/CVI便开始调用(执行)这个回调函数，预先设定好的动作便会被触发。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;如何编写回调函数？在上面提到的那个帮助文档页(即&lt;em&gt;Using Callback Functions to Respond to User Interface Events&lt;/em&gt;页面)，我们可以看到三个回调函数的使用样例代码，他们分别是&lt;em&gt;面板&lt;/em&gt;、&lt;em&gt;控件&lt;/em&gt;以及&lt;em&gt;菜单栏&lt;/em&gt;这三种用户界面元素的回调函数使用样例。请读者想一下，上述三种样例，哪一个可以为我们所用？  &lt;/p&gt;

&lt;p&gt;当然还是&lt;em&gt;控件&lt;/em&gt;的那个样例(&lt;em&gt;ControlResponse&lt;/em&gt;)。我们把下面的样例完整地拷贝到我们的&lt;em&gt;src.c&lt;/em&gt;主程序中，将其放到&lt;code&gt;createGUI_Mine()&lt;/code&gt;函数的下面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int CVICALLBACK ControlResponse (int handle, int control, int event, void *callbackdata, int eventdata1, int eventdata2){
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在要做的对这个样例进行DIY改造。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将函数名&lt;code&gt;ControlResponse&lt;/code&gt;改为更具体的&lt;code&gt;ButtonsResponse&lt;/code&gt;（此改动可有可无）；&lt;/li&gt;
  &lt;li&gt;去除一些无关内容&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;精简后，两个按钮的回调函数变为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int CVICALLBACK ButtonsResponse(int handle, int control, int event, 
            void *callbackdata, int eventdata1, int eventdata2){
    if (control == showBtn) { //如果事件发生在show按钮上
        switch (event) {
            case EVENT_RIGHT_CLICK :
                //右击按钮时作出的响应
                break;
            case EVENT_COMMIT :
                //单击按钮时作出的响应
                break;
        }
    }
    
    if (control == quitBtn) { //如果事件发生在quit按钮上
        switch (event) {
            case EVENT_COMMIT :
                //单击按钮时作出的响应
                break;
        }
    }
    return(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当有&lt;a href=&quot;http://zone.ni.com/reference/en-XX/help/370051V-01/cvi/uiref/cvievents_overview/&quot;&gt;用户事件&lt;/a&gt;发生在按钮上，LabWindows/CVI便会调用上面的回调函数，并在调用时将该控件的载体(&lt;em&gt;handle&lt;/em&gt;)、控件资源句柄(即资源id-&lt;em&gt;control&lt;/em&gt;)、发生的事件id(&lt;em&gt;event&lt;/em&gt;)等信息作为参数传入该回调函数。&lt;/p&gt;

&lt;p&gt;我们看到上面的回调函数用到了变量&lt;em&gt;showBtn&lt;/em&gt;和&lt;em&gt;quitBtn&lt;/em&gt;，不过这两个变量是在&lt;code&gt;createGUI_Mine()&lt;/code&gt;函数中创建的（局部变量）。为了能全局引用这两个变量，我们需要在&lt;em&gt;函数原型声明&lt;/em&gt;部分的上方声明这两个全局变量。鉴于Graph控件也需要全局引用，所以我们在&lt;em&gt;函数原型声明&lt;/em&gt;部分的上方添加这样的声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
/* 全局变量声明 */
static int panelHandle;
int graphHdl, showBtn, quitBtn; 

/* 函数原型声明 */
int createGUI_Mine(void);

/* main()函数 */
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在创建Graph控件以及两个Button按钮的地方(即&lt;code&gt;createGUI_Mine()&lt;/code&gt;函数内)，去掉变量名&lt;em&gt;graphHdl&lt;/em&gt;、&lt;em&gt;showBtn&lt;/em&gt;和&lt;em&gt;quitBtn&lt;/em&gt;前面的&lt;em&gt;int&lt;/em&gt;即可。&lt;/p&gt;

&lt;p&gt;我们来编写&lt;strong&gt;当事件发生在&lt;/strong&gt;&lt;em&gt;showBtn&lt;/em&gt;&lt;strong&gt;按钮上时的事件响应&lt;/strong&gt;：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (control == showBtn) { //如果事件发生在show按钮上
    switch (event) {
        case EVENT_COMMIT :
            //准备一个temp数组，用来存放按钮上要显示的&quot;show&quot;或&quot;stop&quot;字符串
            char temp[8]=&quot;&quot; ; GetCtrlAttribute(panelHandle, showBtn, ATTR_LABEL_TEXT, temp);
            //清空graph上的内容，准备画图
            DeleteGraphPlot(panelHandle, graphHdl, -1, VAL_IMMEDIATE_DRAW);
            if (strcmp(temp, &quot;Show&quot;) == 0 ){ //如果按钮显示的是&quot;Show&quot;的话
                //准备波形数组
                double waveData[100], amp, phase, cycles;
                int n;
                n = 100;
                amp = 90.0;
                phase = 0.0;
                cycles = 1.5;
                SinePattern(n, amp, phase, cycles, waveData);
                //将波形数组填充到graph图表上
                PlotY(panelHandle, graphHdl, waveData, n, VAL_DOUBLE, VAL_THIN_LINE, 
                      VAL_EMPTY_SQUARE, VAL_SOLID, VAL_CONNECTED_POINTS , VAL_YELLOW);
                SetCtrlAttribute(panelHandle, showBtn, ATTR_LABEL_TEXT, &quot;Clear&quot;);
            }
            else{ //如果按钮显示的是&quot;Clear&quot;的话
                SetCtrlAttribute(panelHandle, showBtn, ATTR_LABEL_TEXT, &quot;Show&quot;);
            }
            break; 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接着编写&lt;strong&gt;当事件发生在&lt;/strong&gt;&lt;em&gt;quitBtn&lt;/em&gt;&lt;strong&gt;按钮上时的事件响应&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (control == quitBtn) { //如果事件发生在quit按钮上
    switch (event) {
        case EVENT_COMMIT :
            //单击按钮时作出的响应
            QuitUserInterface(0);
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于我们的回调函数&lt;code&gt;ButtonsResponse()&lt;/code&gt;也是自定义函数，所以需要添加&lt;strong&gt;函数原型声明&lt;/strong&gt;，读者还记得&lt;strong&gt;在哪里&lt;/strong&gt;以及&lt;strong&gt;如何添加&lt;/strong&gt;函数原型声明吗？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;...
/* 函数原型声明 */
int createGUI_Mine(void);
int CVICALLBACK ButtonsResponse(int, int, int, void, int, int);
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;5.3.3 最后一步，为按钮指派(安装)回调函数。&lt;/h5&gt;

&lt;p&gt;也许读者会有疑问：我们不是已经写好回调函数了吗？怎么还要指派(安装)回调函数？事实是：我们虽然已经写好了回调函数，但这个函数和具体控件之间仍是没有任何联系的。指派(安装)回调函数便是为两者建立关联的过程。&lt;/p&gt;

&lt;p&gt;为某个控件指派(安装)回调函数用的是&lt;code&gt;InstallCtrlCallback()&lt;/code&gt;这个函数，它的函数结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;InstallCtrlCallback (int panelHandle, int controlID, CtrlCallbackPtr eventFunction, void *callbackData);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在使用时，你需要传入控件所属载体的资源句柄(&lt;em&gt;panelHandle&lt;/em&gt;)、控件本身的资源句柄(&lt;em&gt;controlID&lt;/em&gt;)、控件欲绑定的回调函数(&lt;em&gt;eventFunction&lt;/em&gt;)以及在调用该回调函数时欲传给该函数的数据( &lt;em&gt;*callbackData&lt;/em&gt;)。特别注意的是，回调函数&lt;em&gt;eventFunction&lt;/em&gt;的类型是&lt;em&gt;CtrlcallbackPtr&lt;/em&gt;的，这一类型的函数，都必须遵循以下的函数声明结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int CVICALLBACK CallbackFunctionName (int panelHandle, int controlID, int event, void *callbackData, int eventData1, int eventData2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这也就是为什么我们的&lt;code&gt;ButtonsResponse()&lt;/code&gt;函数的前面会有一个全大写的&lt;code&gt;CVICALLBACK&lt;/code&gt;标志了。&lt;/p&gt;

&lt;p&gt;为&lt;strong&gt;show&lt;/strong&gt;、&lt;strong&gt;quit&lt;/strong&gt;按钮指派(安装)回调函数将在&lt;code&gt;createGUI_Mine()&lt;/code&gt;函数中完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;InstallCtrlCallback(pHandle, showBtn, ButtonsResponse, 0);
InstallCtrlCallback(pHandle, quitBtn, ButtonsResponse, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，所有工作已经完成，快快试运行一下你的程序吧！&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;程序源码&lt;a href=&quot;https://github.com/HelloLyfing/LabWindows-CVI-Tutorial-For-Newbie-By.Lyfing&quot;&gt;托管在Github&lt;/a&gt;上，请自行前往查看。&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2013/10/20/Labwindows-tutorial-chapter3-part2.html&quot;&gt;Labwindows.Tutorial.Chapter 3.Part2&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on October 20, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Labwindows.Tutorial.Chapter 3.Part1]]></title>
  <link>http://localhost:4000/2013/10/10/Labwindows-tutorial-chapter3-part1.html</link>
  <id>http://localhost:4000/2013/10/10/Labwindows-tutorial-chapter3-part1</id>
  <published>2013-10-10T00:00:00+08:00</published>
  <updated>2013-10-10T00:00:00+08:00</updated>
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;a href=&quot;http://lanfengming.com/Labwindows-tutorial-chapter2.html/&quot;&gt;上一篇&lt;/a&gt;中我们讲了如何&lt;strong&gt;使用界面编辑器&lt;/strong&gt;创建一个Graph控件，并通过绑定代码在它上面显示Sine波和Cosine波。&lt;/p&gt;

&lt;p&gt;本篇虽然仍要创建Graph，不过所有的图形创建工作都将由&lt;strong&gt;代码&lt;/strong&gt;完成。也就是说，从头到尾，你无需再借助界面编辑器来完成创建控件、设置属性、绑定回调函数等工作，上述内容都将在一个&lt;strong&gt;.c&lt;/strong&gt;文件中由代码来实现。&lt;/p&gt;

&lt;p&gt;而且说实在的，授人以鱼不如授人以渔。这个系列教程不可能从零开始详尽介绍各个控件、内建函数的使用方法，一来确实内容太多，无力一一详述；二来这些东西本就在&lt;strong&gt;官方文档&lt;/strong&gt;中有足够详尽的使用说明，自己再来赘述反倒没有意义。&lt;strong&gt;此系列教程更多的意义在于&lt;/strong&gt;：在引导新手慢慢上手、熟悉Labwindows开发环境的同时，教会新手自己查阅帮助文档解决问题，最终达到新手可以自己查找帮助文档解决问题的目的。我想教会人用字典比每个字手把手教更有意义，对吧？因此从本篇开始会侧重介绍帮助文档的使用。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;本篇任务：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用代码在主面板上创建一个Graph控件；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;显示波形按钮&lt;/strong&gt;、&lt;strong&gt;清除波形按钮&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;开始尝试从帮助文档中寻找解决问题的答案或方案&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6480dca9jw1e9t2bslcygj20gv096my7.jpg&quot; alt=&quot;最终效果图.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;new-project&quot;&gt;1. New Project(新建工程)&lt;/h4&gt;

&lt;p&gt;如何新建工程？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;打开LabWindows/CVI程序后，如果弹出如下页面(启动页)。则通过选择&lt;strong&gt;New&lt;/strong&gt;版块的&lt;strong&gt;Project&lt;/strong&gt;选项即可新建工程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/6480dca9jw1e9t2cxnz38j20l60f5acy.jpg&quot; alt=&quot;Startup-page.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果打开程序后直接看到的是程序主界面，则直接通过菜单栏 &lt;strong&gt;File&lt;/strong&gt; » &lt;strong&gt;New&lt;/strong&gt; » &lt;strong&gt;Project(*.prj)&lt;/strong&gt; 即可新建工程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在之后弹出的&lt;strong&gt;New Project Options&lt;/strong&gt;对话框中，保留系统默认选项，直接点击&lt;strong&gt;OK&lt;/strong&gt;即可&lt;/p&gt;

&lt;h4 id=&quot;new-source-filec&quot;&gt;2. New Source File(新建.c代码源文件)&lt;/h4&gt;

&lt;p&gt;通过菜单栏依次选择 &lt;strong&gt;File&lt;/strong&gt; » &lt;strong&gt;New&lt;/strong&gt; » &lt;strong&gt;Source(*.c)&lt;/strong&gt; 即可新建代码源文件&lt;/p&gt;

&lt;p&gt;此时需要保存一下我们新建的工程，通过菜单栏依次选择&lt;strong&gt;File&lt;/strong&gt; » &lt;strong&gt;Add Untitled1.c to project&lt;/strong&gt;(添加代码源文件到工程中)，此时会弹出如下对话框(LabWindows/CVI Message)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/6480dca9jw1e9t2e135jpj20bz04iq3d.jpg&quot; alt=&quot;You-must-name-.c-file-name-before-using-it.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对话框内容为：代码源文件只有在命名后才可以被添加到Project中，所以你需要首先给代码源文件命名并选择其存储位置，我们把它保存在任意位置的&lt;strong&gt;project3&lt;/strong&gt;文件夹下，并将其命名为 &lt;em&gt;src3.c&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;此时新建工程及其系列文件(源代码文件、用户界面文件、配置文件等)都将被自动命名为 &lt;em&gt;src.后缀&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;cmain&quot;&gt;3. 在.c代码文件中添加main()函数&lt;/h4&gt;

&lt;p&gt;我们知道LabWindows/CVI使用的c语言作为编程语言，而c语言中的&lt;code&gt;main()&lt;/code&gt;函数则是整个程序的入口，所以我们首先为源代码文件添加&lt;code&gt;main()&lt;/code&gt;函数&lt;em&gt;(下面的&lt;code&gt;main()&lt;/code&gt;函数代码由系统根据用户界面文件(&lt;strong&gt;.uir&lt;/strong&gt;)自动生成，算是LabWindows/CVI程序的&lt;code&gt;main()&lt;/code&gt;函数的原始框架，最好把它复制到源代码文件中，不推荐手敲。下面会详细解释这个main()函数的默认运行机制)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;cvirte.h&amp;gt;     
#include &amp;lt;userint.h&amp;gt;
#include &quot;src.h&quot;

static int panelHandle;

int main (int argc, char *argv[]){
    if (InitCVIRTE (0, argv, 0) == 0)
        return -1;  /* out of memory */
    if ((panelHandle = LoadPanel (0, &quot;src.uir&quot;, PANEL)) &amp;lt; 0)
        return -1;
    DisplayPanel (panelHandle);
    RunUserInterface ();
    DiscardPanel (panelHandle);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关于上面的&lt;code&gt;main()&lt;/code&gt;函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;cvirte.h&amp;gt;     
#include &amp;lt;userint.h&amp;gt;
#include &quot;src.h&quot;
# 上面的include语句是引入系统所需的一些内置函数，  
# 稍懂C语言的应该不会对此陌生

# panelHandle是整个程序的灵魂支柱，
# 它持有着系统/程序主面板(如果程序有图形化界面的话)
# 在系统内存中的**句柄**，意即编程人员需要通过这个句柄
# 来与主面板进行交互
static int panelHandle;

# 传说中的main()函数
int main (int argc, char *argv[]){
    # 系统初始化
    if (InitCVIRTE (0, argv, 0) == 0)
        return -1;  /* out of memory */
    # LoadPanel是LabWindows/CVI的自带函数(以后简称&quot;Lab自带函数&quot;)
    # 它的作用是什么呢？请把光标放到LoadPanel这个函数名的任意位置，然后按F1，
    # 接着会弹出 NI LabWindows/CVI Help 面板(如下图所示)，
    # 面板左面是索引选项，面板右面便是我们的LoadPanel()函数的详细使用说明
    # 看着一大堆英文是不是觉得有些头大？但我强烈推荐你硬着头皮看下去，因为
    # 这个函数很重要，而且关于它的使用帮助包含了很多LabWindows/CVI程序的构建机理
    # 也许刚开始你会觉得看的云里雾里，但只要每次接触新函数时花功夫看上一会，
    # 一星期后你就会感觉编写程序似有&quot;游刃有余&quot;之感了，而到此时，你已经几乎可以
    # 不借助外界帮助(用搜索引擎、官方BBS论坛查找信息)独立完成大部分的编程工作了
    if ((panelHandle = LoadPanel (0, &quot;src.uir&quot;, PANEL)) &amp;lt; 0)
        return -1;
    DisplayPanel (panelHandle);
    RunUserInterface ();
    DiscardPanel (panelHandle);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;话虽如此，还是简单介绍一下main()函数的运行流程吧：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先使用&lt;code&gt;InitCVIRTE (0, argv, 0)&lt;/code&gt;函数进行系统初始化；&lt;/li&gt;
  &lt;li&gt;接着开始&lt;strong&gt;选择&lt;/strong&gt;并&lt;strong&gt;载入&lt;/strong&gt;图形界面(主面板)文件，准备显示图形。这一步的一种通用做法是：&lt;code&gt;panelHandle = LoadPanel (0, &quot;src.uir&quot;, PANEL))&lt;/code&gt; ，即用 &lt;code&gt;LoadPanel()&lt;/code&gt; Lab自带函数载入你之前已经创建好的图形界面描述文件(&lt;strong&gt;.uir&lt;/strong&gt;文件或&lt;strong&gt;.tui&lt;/strong&gt;文件，看看本系列教程中上两章所创建的工程，其中都带有&lt;strong&gt;.uir&lt;/strong&gt;图形界面描述文件)，并在载入后将该面板资源在系统内存中的&lt;strong&gt;句柄&lt;/strong&gt;(handle)交给(赋值给)我们之前创建的全局变量 &lt;code&gt;panelHandle&lt;/code&gt; 。但是本章教程中并没创建图形界面描述文件，因为我们是要用纯代码实现创建图形控件并使其发挥一定功用。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DisplayPanel (panelHandle)&lt;/code&gt; 上一步，我们载入图形界面描述文件，并获得了其在系统内存中的句柄(即 &lt;code&gt;panelHandle&lt;/code&gt; )，这一步便是将这个图形界面显示出来。使用 &lt;code&gt;DisplayPanel()&lt;/code&gt; 函数可以完成此项工作&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;RunUserInterface()&lt;/code&gt; 将开始运行图形界面，并将捕获到的用户事件(events)分发给回调函数。我们来看看 &lt;code&gt;RunUserInterface&lt;/code&gt; 的使用说明。在 &lt;code&gt;RunUserInterface&lt;/code&gt; 上按F1(或在打开的&lt;strong&gt;NI LabWindows/CVI Help&lt;/strong&gt;面板的左侧，点击&lt;strong&gt;索引(N)&lt;/strong&gt;标签，然后在搜索框中输入 &lt;code&gt;RunUserInterface&lt;/code&gt; 后回车。在&lt;strong&gt;用途&lt;/strong&gt;(Purpose)部分，我们看到这样一段话：&lt;em&gt;RunUserInterface does not return until you call QuitUserInterface from within a callback function. RunUserInterface returns the value that you pass to QuitUserInterface.&lt;/em&gt; 也就是说 &lt;code&gt;RunUserInterface()&lt;/code&gt; 一旦执行，它不会立即返回(return)，所以跟在它后面的代码也就不会立即执行。那么这个函数何时才会返回呢？&lt;strong&gt;直到你主动在某个&lt;code&gt;回调函数&lt;/code&gt;中调用 &lt;code&gt;QuitUserInterface()&lt;/code&gt; 函数&lt;/strong&gt;， &lt;code&gt;RunUserInterface()&lt;/code&gt; 才会返回，而且它的返回值是你传入 &lt;code&gt;QuitUserInterface()&lt;/code&gt; 的参数。PS：&lt;code&gt;QuitUserInterface()&lt;/code&gt; 一般出现在&lt;strong&gt;系统退出按钮&lt;/strong&gt;或&lt;strong&gt;主面板右上角的”x”关闭按钮&lt;/strong&gt;的回调函数中。&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;DiscardPanel (panelHandle)&lt;/code&gt; 载入到系统内存中的图形界面资源，必须在系统退出前被清理掉，以防止程序给PC内存留下太多垃圾。&lt;code&gt;DiscardPanel (panelHandle)&lt;/code&gt; 便是做此项工作的，按F1查看它的使用说明，它的用途(Purpose)部分写到：&lt;em&gt;Removes a panel and any of its child panels from memory and clears them from the screen if visible.You must call DiscardPanel from the thread in which you create the panel.&lt;/em&gt; 即：&lt;em&gt;将一个面板(panel)及其所有的子面板(child panel,面板可以有父子关系)从内存中移除；如果它们正显示在屏幕上，则清除这些图像。而且你必须在创建面板的线程中(多线程范畴)调用&lt;code&gt;DiscardPanel()&lt;/code&gt;&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;return 0&lt;/code&gt; 退出 &lt;code&gt;main()&lt;/code&gt; 函数，程序运行结束。 &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;LabWindows/CVI程序的main()函数的运行机制基本如此。当然只要不颠倒上述几个部分的顺序的话，你可以在 &lt;code&gt;main()&lt;/code&gt; 函数的任意位置添加任意有逻辑的代码。下一节我们将从修改上述 &lt;code&gt;main()&lt;/code&gt; 函数着手，编写本章内容需要的 &lt;code&gt;main()&lt;/code&gt; 函数。&lt;/p&gt;

&lt;h4 id=&quot;main&quot;&gt;4. 开始编写main()函数&lt;/h4&gt;

&lt;p&gt;上一节我们只是从其他地方复制了一份LabWindows/CVI程序的 &lt;code&gt;main()&lt;/code&gt; 函数框架，但它并不能满足我们的需求，我们需要在此基础上修改它。&lt;/p&gt;

&lt;p&gt;4.1 第一步不改动原框架，使用 &lt;code&gt;InitCVIRTE()&lt;/code&gt; 函数进行系统初始化&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if ( InitCVIRTE(0, argv, 0) == 0 ) 
    return -1;  /* out of memory */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.2 原框架的第二步是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;panelHandle = LoadPanel (0, &quot;src.uir&quot;, PANEL))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即&lt;em&gt;使用Lab自带函数 &lt;code&gt;LoadPanel()&lt;/code&gt; 载入用户之前创建的图形界面描述文件(&lt;strong&gt;.uir&lt;/strong&gt;/&lt;strong&gt;.tui&lt;/strong&gt;)&lt;/em&gt;，但我们要自己用代码创建图形界面的，&lt;strong&gt;所以这一步的内容改为&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;panelHandle = createGUI_Mine() # GUI = Graphic User Interface
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;createGUI_Mine()&lt;/code&gt; 是我们自己编写的函数，它的作用是创建一个面板，并将创建好的面板资源的句柄(handle)返回(return)。为了与Lab系统自带函数区别开来，我们在函数名之后添加了 &lt;code&gt;_Mine&lt;/code&gt; 标记（&lt;em&gt;其实这个标记可有可无&lt;/em&gt;）。&lt;/p&gt;

&lt;p&gt;4.3 剩余部分跟源框架保持一致：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DisplayPanel (panelHandle);
RunUserInterface ();
DiscardPanel (panelHandle);
return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;createguimine-&quot;&gt;5. 编写 &lt;code&gt;createGUI_Mine()&lt;/code&gt; 函数的具体实现&lt;/h4&gt;
&lt;p&gt;第5部分内容将在&lt;a href=&quot;http://lanfengming.com/blog/Labwindows-tutorial-chapter3-part2.html/&quot;&gt;下一篇中继续&lt;/a&gt;&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2013/10/10/Labwindows-tutorial-chapter3-part1.html&quot;&gt;Labwindows.Tutorial.Chapter 3.Part1&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on October 10, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[在线切割剪辑MP3手机铃声利器！]]></title>
  <link>http://localhost:4000/2013/07/18/make-your-own-phone-ringstones.html</link>
  <id>http://localhost:4000/2013/07/18/make-your-own-phone-ringstones</id>
  <published>2013-07-18T05:00:00+08:00</published>
  <updated>2013-07-18T05:00:00+08:00</updated>
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;这年头，能刹那间打动你的音乐真的不多了。
好不容易遇到一首触动自己的音乐，怎么能放过拿它做手机铃声或晨起闹钟或各种短铃声的机会呢？
——-
你平常会用哪些稀奇古怪，难用、效果又差的软件剪辑音乐呢？
去百度、Google里搜一下，好嘛，一堆，还不知道好不好用，效果怎么样，还得下载，还得学着怎么用，还得忍受下到傻逼软件或流浪软件的愤怒…好嘛…&lt;br /&gt;
欢迎跟我来到21世纪~~~&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;吐槽结束，干货分享开始！&lt;br /&gt;
&lt;!--more--&gt;
如题所著，这款音乐剪辑工具无需下载，是直接在线使用的。它的&lt;strong&gt;特点如下&lt;/strong&gt;： &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;仅支持&lt;strong&gt;MP3格式&lt;/strong&gt;的音乐(其他格式未做测试)  &lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;无损切割&lt;/strong&gt;(192kbps的处理完还是192k，320k的处理完还是320k) &lt;/li&gt;
  &lt;li&gt;时间线微调可以精确到——&lt;strong&gt;0.2s&lt;/strong&gt;！ &lt;/li&gt;
  &lt;li&gt;支持音乐的开始&lt;strong&gt;渐入&lt;/strong&gt;，结束&lt;strong&gt;渐出&lt;/strong&gt;效果&lt;/li&gt;
  &lt;li&gt;支持&lt;strong&gt;MP3、AMR、WAV、AAC以及iPhone铃声&lt;/strong&gt;等多种&lt;strong&gt;导出格式&lt;/strong&gt;  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;高手请直接前往在线工具网址&lt;a href=&quot;http://cut-mp3.com&quot; target=&quot;_blank&quot;&gt;cut-mp3.com&lt;/a&gt;体验试用。&lt;br /&gt;
不知道怎么用、或者想知道详尽用法的人跟着往下看。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;1) 打开网址：&lt;a href=&quot;http://cut-mp3.com&quot; target=&quot;_blank&quot;&gt;cut-mp3.com&lt;/a&gt;  &lt;/p&gt;

&lt;p&gt;2) 稍等片刻，工具载入完成后出现如下画面，点&lt;strong&gt;Open file&lt;/strong&gt;上传本地音乐
&lt;img src=&quot;http://ww3.sinaimg.cn/large/6480dca9jw1e6piqioanmj20ee07dgmd.jpg&quot; alt=&quot;&quot; /&gt;  &lt;/p&gt;

&lt;p&gt;3)接着进入音乐剪切环节，各按钮功能及释义如下图所示：
&lt;img src=&quot;http://ww3.sinaimg.cn/large/6480dca9jw1e6pit90dxgj21fz0fb0yd.jpg&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
(可&lt;a href=&quot;http://ww3.sinaimg.cn/large/6480dca9jw1e6pit90dxgj21fz0fb0yd.jpg&quot; target=&quot;_blank&quot;&gt;点击大图查看&lt;/a&gt;详细内容)  &lt;/p&gt;

&lt;p&gt;4) 设置开始位置：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用鼠标拖动&lt;strong&gt;开始标志线&lt;/strong&gt;到自己大致满意的位置&lt;/li&gt;
  &lt;li&gt;通过键盘左右箭头对&lt;strong&gt;标志线位置&lt;/strong&gt;进行&lt;strong&gt;微调&lt;/strong&gt;，空格键控制&lt;strong&gt;开始/暂停&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;通过点击”&lt;strong&gt;Fade in&lt;/strong&gt;“按钮，来&lt;strong&gt;开启/关闭音乐渐入效果&lt;/strong&gt;(亮为开，暗为关)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5) 设置结束位置：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用鼠标拖动&lt;strong&gt;结束标志线&lt;/strong&gt;到自己大致满意的位置&lt;/li&gt;
  &lt;li&gt;通过键盘左右箭头对&lt;strong&gt;标志线位置&lt;/strong&gt;进行&lt;strong&gt;微调&lt;/strong&gt;，空格键控制&lt;strong&gt;开始/暂停&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;通过点击”&lt;strong&gt;Fade out&lt;/strong&gt;“按钮，来&lt;strong&gt;开启/关闭音乐渐出效果&lt;/strong&gt;(亮为开，暗为关)  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6) 选择保存格式：&lt;br /&gt;
可分别选择  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MP3格式&lt;/li&gt;
  &lt;li&gt;iPhone铃声格式&lt;/li&gt;
  &lt;li&gt;从&lt;strong&gt;More&lt;/strong&gt;上拉菜单中选择 » AMR、WAV、AAC格式  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;7) 开始切割：&lt;br /&gt;
点击工具右下方 &lt;strong&gt;Cut&lt;/strong&gt; 按钮开始切割，此时进度条会显示切割进度，如果进度很慢或者等了半天都没反应，可以点击工具标题栏的 &lt;strong&gt;2 Cut&lt;/strong&gt; 标签重新进行剪切，或者刷新页面后重试(注意刷新后不会保存你的剪切设置!) &lt;br /&gt;
&lt;img src=&quot;http://ww2.sinaimg.cn/large/6480dca9jw1e6pixv5y3wj20sg08gmys.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8) 等待片刻，点击 &lt;strong&gt;Downlaod&lt;/strong&gt; 按钮即可下载剪切后的音乐！&lt;br /&gt;
&lt;img src=&quot;http://ww2.sinaimg.cn/large/6480dca9jw1e6piwnaxe4j20lz0dujtj.jpg&quot; alt=&quot;&quot; /&gt;  &lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&quot;https://soundcloud.com/lyfing/call-me-maybe-clip&quot; target=&quot;_blank&quot;&gt;点此试听&lt;/a&gt;我剪辑的《Call Me Maybe》(进去后&lt;strong&gt;点击频谱带任意位置&lt;/strong&gt;开始播放，点此可&lt;a href=&quot;http://dl.vmall.com/c0yde7tkwq&quot; target=&quot;_blank&quot;&gt;下载剪辑文件&lt;/a&gt;)  &lt;/p&gt;

&lt;p&gt;原文件参数：&lt;code&gt; MP3 ; 320kbps ; 44100Hz ; 3:14 &lt;/code&gt;  &lt;br /&gt;
剪切后参数：&lt;code&gt; MP3 ; 320kbps ; 44100Hz ; 0:33 ; 有渐入、渐出效果 &lt;/code&gt;&lt;/p&gt;

  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2013/07/18/make-your-own-phone-ringstones.html&quot;&gt;在线切割剪辑MP3手机铃声利器！&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on July 18, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Labwindows.Tutorial.Chapter 2]]></title>
  <link>http://localhost:4000/2013/07/10/Labwindows-tutorial-chapter2.html</link>
  <id>http://localhost:4000/2013/07/10/Labwindows-tutorial-chapter2</id>
  <updated>2013-07-18 5:00T00:00:00-00:00</updated>
  <published>2013-07-10T00:00:00+08:00</published>
  
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;导语：本篇文章将向大家演示如何在&lt;strong&gt;主Panel上&lt;/strong&gt;创建一个&lt;strong&gt;Graph控件&lt;/strong&gt;(Object)和两个&lt;strong&gt;按钮&lt;/strong&gt;，并为这两个按钮绑定事件回调函数：  &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;点下&lt;strong&gt;按钮1&lt;/strong&gt;，Graph控件显示Sine波形；  &lt;/li&gt;
  &lt;li&gt;点下&lt;strong&gt;按钮2&lt;/strong&gt;，Graph控件显示Cosine波形。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;效果如下图所示：  &lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/6480dca9tw1e66pudgy7aj20ej0l6abp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;LabWindows/CVI为开发者提供了三种类型的图表控件，在界面编辑器下，他们的创建方式为：&lt;br /&gt;
在主面板上右击，在弹出的控件列表中，依次选择&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Graph&lt;/strong&gt; » &lt;strong&gt;Graph&lt;/strong&gt; 即可在主面板上新建一个Graph &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Graph&lt;/strong&gt; » &lt;strong&gt;Strip Chart&lt;/strong&gt; 即可在主面板上新建一个Strip Chart &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Graph&lt;/strong&gt; » &lt;strong&gt;Digital Graph&lt;/strong&gt; 即可在主面板上新建一个Digital Graph &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里简单&lt;strong&gt;介绍一下&lt;/strong&gt; LabWindows/CVI提供的&lt;strong&gt;三种Graph图表&lt;/strong&gt;的功能和特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Graph：一般用于显示一个或多个&lt;strong&gt;静态&lt;/strong&gt;图表。图表可由&lt;strong&gt;一个曲线&lt;/strong&gt;、 &lt;strong&gt;一个点&lt;/strong&gt;、 &lt;strong&gt;一个几何形状&lt;/strong&gt;、 &lt;strong&gt;一张图片&lt;/strong&gt;或 &lt;strong&gt;一个字符串&lt;/strong&gt;组成 &lt;/li&gt;
  &lt;li&gt;Strip Chart：一般用于&lt;strong&gt;动态显示实时数据&lt;/strong&gt;，它可同时显示一路或多路信号。例如我的毕设是信号采集系统，采集到的信号都是实时变化的，这时候用Strip Chart是最好的选择 &lt;/li&gt;
  &lt;li&gt;Digital Graph：顾名思义，它用于显示&lt;strong&gt;数字信号&lt;/strong&gt;，显示内容其实就是一系列的&lt;strong&gt;方波&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;虽然上面介绍了三种图表控件，但鉴于本教程只为帮助初学者入门，所以此处只简单介绍三个图表控件中&lt;strong&gt;Graph控件&lt;/strong&gt;的使用方法，至于其他两个图表控件的使用方法，可在掌握Graph用法后自行查找资料(官方的帮助文档及在线论坛)进行学习。&lt;/p&gt;

&lt;p&gt;OK,here we go !&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;1) 打开LabWindows/CVI，新建一个&lt;strong&gt;.uir&lt;/strong&gt;文件；&lt;/p&gt;

&lt;p&gt;2) 双击创建出来的面板，在面板的&lt;strong&gt;属性编辑框&lt;/strong&gt;里，设置主面板的标题(Panel title:)为：&lt;em&gt;Using Graph Demo&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;3) 在面板上创建三个按钮(Command Button，创建方法见第一篇教程HelloWorld)&lt;br /&gt;
双击&lt;strong&gt;第一个&lt;/strong&gt;按钮，在弹出的按钮&lt;strong&gt;属性编辑框&lt;/strong&gt;里，把&lt;strong&gt;Callback function&lt;/strong&gt;的值设为 &lt;em&gt;showSineWave&lt;/em&gt; | 把&lt;strong&gt;Label&lt;/strong&gt;的值设为 &lt;em&gt;Sine&lt;/em&gt;&lt;br /&gt;
之后点击OK(确定)回到主面板&lt;br /&gt;
按上述方法，设置&lt;strong&gt;第二个&lt;/strong&gt;按钮的&lt;strong&gt;Callback function&lt;/strong&gt;的值为 &lt;em&gt;showCosineWave&lt;/em&gt; | &lt;strong&gt;Label&lt;/strong&gt;的值为 &lt;em&gt;Cosine&lt;/em&gt;&lt;br /&gt;
接着设置&lt;strong&gt;第三个&lt;/strong&gt;按钮的&lt;strong&gt;Callback function&lt;/strong&gt;的值为 &lt;em&gt;quitSystem&lt;/em&gt; | &lt;strong&gt;Label&lt;/strong&gt;的值为 &lt;em&gt;Quit&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;4) 在面板上创建一个Graph控件。具体方法是：对着面板右击，在弹出的控件列表里，依次选择&lt;strong&gt;Graph&lt;/strong&gt; » &lt;strong&gt;Graph&lt;/strong&gt;(读者可用鼠标随意调整按钮和图表的位置及大小)&lt;br /&gt;
目前为止，我们做出来的东西效果如下图所示&lt;br /&gt;
&lt;img src=&quot;http://ww2.sinaimg.cn/large/6480dca9tw1e66pscg411j20ec0a7wfb.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5) 双击新建的Graph控件，在弹出的Graph&lt;strong&gt;属性编辑框&lt;/strong&gt;里，在&lt;strong&gt;Label Appearance&lt;/strong&gt;区域，设置&lt;strong&gt;Label&lt;/strong&gt;的值为 &lt;em&gt;Graph Demo&lt;/em&gt;&lt;br /&gt;
之后点击OK(确定)回到主面板&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;好的，我们所有的界面编辑工作已经完成了，接下来，我们要做的就是编写程序，实现文章开头说到的那些功能了&lt;/p&gt;

&lt;p&gt;1) 生成源代码文件，即&lt;strong&gt;.c&lt;/strong&gt;文件&lt;br /&gt;
操作步骤：依次点击系统菜单栏 &lt;strong&gt;Code&lt;/strong&gt; » &lt;strong&gt;Generate&lt;/strong&gt; » &lt;strong&gt;All code&lt;/strong&gt;&lt;br /&gt;
操作图示：&lt;br /&gt;
&lt;img src=&quot;http://ww1.sinaimg.cn/large/6480dca9tw1e66pyn5o90j20cf09f75c.jpg&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
此时&lt;strong&gt;系统提示&lt;/strong&gt;需要首先保存&lt;strong&gt;.uir&lt;/strong&gt;文件，将&lt;strong&gt;.uir&lt;/strong&gt;文件命名为 &lt;em&gt;2-Using-Graph-Demo.uir&lt;/em&gt;，接着新建文件夹&lt;strong&gt;2&lt;/strong&gt;，把该&lt;strong&gt;.uir&lt;/strong&gt;文件保存到新建的文件夹下&lt;br /&gt;
(PS:为什么要新建文件夹并把.uir文件保存到这里？因为之后的&lt;strong&gt;.c&lt;/strong&gt;代码文件以及包含此工程信息的&lt;strong&gt;所有文件&lt;/strong&gt;后续都会保存到这个文件夹下，便于我们进行工程管理，也不会使电脑硬盘显得太乱)&lt;/p&gt;

&lt;p&gt;2) 接下来，系统又会提示需要指定一个&lt;strong&gt;.c&lt;/strong&gt;的源文件，依次点&lt;strong&gt;Yes&lt;/strong&gt;、 &lt;strong&gt;OK&lt;/strong&gt;新建&lt;strong&gt;.c&lt;/strong&gt;文件&lt;/p&gt;

&lt;p&gt;3) 此时会弹出&lt;strong&gt;Generate All Code&lt;/strong&gt;窗口，各项设置及意义如下图所示(可右键查看大图)，之后点击&lt;strong&gt;OK&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;http://ww3.sinaimg.cn/large/6480dca9tw1e66qc4donfj20d20ep0uz.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4) 在弹出的&lt;strong&gt;New Project Options&lt;/strong&gt;窗口&lt;br /&gt;
将&lt;strong&gt;Project Location&lt;/strong&gt;设置为 &lt;em&gt;Create Project in Current Workspace&lt;/em&gt;&lt;br /&gt;
在&lt;strong&gt;Transfer Project Options&lt;/strong&gt;区域，把四个复选框都勾选上(默认就是全部勾选)&lt;br /&gt;
之后点击&lt;strong&gt;OK&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;5) 好吧，我们的源代码文件终于出现了。现贴出所有代码并注释:  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;cvirte.h&amp;gt;;
#include &amp;lt;userint.h&amp;gt;;
#include &quot;2-Using-Graph-Demo.h&quot;;

/* panelHandle是主面板的Handle
就相当于一个&quot;对象索引&quot;;
我们知道，主面板、按钮、图表控件等等界面元素，在系统内存中都是以
一个内存块的形式存在的（在C++、Java里就是&quot;对象&quot;的概念）
当我们需要使用这些对象时，就是通过这个&amp;amp;quot;索引&amp;amp;quot;来指向这些对象的 */
static int panelHandle;

/* main函数入口，也是系统总入口 */
int main (int argc, char *argv[]) {
    if (InitCVIRTE (0, argv, 0) == 0)
        return -1;    /* out of memory */
    // LoadPanel()函数是LabWindows/CVI提供的系统函数
    // 如果想查看某个函数的介绍及参数等详情，可以把光标放到该函数上，然后按&quot;F1&quot;，
    // 这将会打开帮助文档中该函数的详细介绍
    if ((panelHandle = LoadPanel(0, &quot;2-Using-Graph-Demo.uir&quot;, PANEL)) &amp;lt;= 0)
        return -1;
    // LoadPanel()之后，需要DisplayPanel()函数来真正把载入的面板数据显示出来
    DisplayPanel (panelHandle);
    RunUserInterface ();
    DiscardPanel (panelHandle);
    return 0;
}

/* Sine按钮的回调函数
event事件包含了所有用户产生的事件，
如键盘事件，鼠标事件(左键单双击、右键单双击等等)，获得焦点、失去焦点事件等等 */
int CVICALLBACK showSineWave (int panel, int control, int event,
        void *callbackData, int eventData1, int eventData2) {
    switch (event) {
        case EVENT_COMMIT:

            break;
    }
    return 0;
}  
/* Cosine按钮的回调函数 */
int CVICALLBACK showCosineWave (int panel, int control, int event,
        void *callbackData, int eventData1, int eventData2) {
    switch (event) {
        case EVENT_COMMIT:

            break;
    }
    return 0;
}  
/* Quit按钮的回调函数 */
int CVICALLBACK quitSystem (int panel, int control, int event,
        void *callbackData, int eventData1, int eventData2) {
    switch (event) {
        case EVENT_COMMIT:
            //退出用户界面(退出按钮)
            QuitUserInterface (0);
            break;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;6) 编写&lt;strong&gt;Sine&lt;/strong&gt;按钮的回调函数&lt;br /&gt;
函数实现为：点击&lt;strong&gt;Sine&lt;/strong&gt;按钮后，清空Graph控件上的所有图表内容，然后使用系统提供的&lt;em&gt;SinePattern()&lt;/em&gt;函数生成一组Sine曲线的Y坐标值，最后通过描出Y坐标值来在Graph图表上汇出一个&lt;strong&gt;Sine&lt;/strong&gt;曲线&lt;br /&gt;
下面贴上该回调函数具体代码并注释：  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int CVICALLBACK showSineWave (int panel, int control, int event,
        void *callbackData, int eventData1, int eventData2) {
    switch(event){
        //case是各种用户事件，到此查看所有事件列表
        // http://t.cn/zQ7jw42
        case EVENT_COMMIT:
            //删除Graph上的某个或所有图像(Plot),可把光标放置到函数名上，按F1查看帮助
            DeleteGraphPlot(panelHandle, PANEL_GRAPH, -1, VAL_IMMEDIATE_DRAW);
            //waveData[]数组用来保存SinePattern函数生成的100个Y坐标值
            double waveData[100], amp, phase, cycles;
            int n;
            n = 100;
            amp = 90.0;
            phase = 0.0;
            cycles = 1.5;
            //该步将生成100个Sine函数的Y坐标点，并将这些值保存到waveData数组里
            SinePattern(n, amp, phase, cycles, waveData);
            //该步把Y坐标值绘制到Graph图表控件中去
            PlotY(panelHandle, PANEL_GRAPH, waveData, n, VAL_DOUBLE, VAL_THIN_LINE, 
                  VAL_EMPTY_SQUARE, VAL_SOLID, VAL_CONNECTED_POINTS , VAL_YELLOW);
            break;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7) 编写&lt;strong&gt;Cosine&lt;/strong&gt;按钮的回调函数并注释  &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;int CVICALLBACK showCosineWave(int panel, int control, int event,
        void *callbackData, int eventData1, int eventData2) {
    switch (event){
        case EVENT_COMMIT:
            DeleteGraphPlot(panelHandle, PANEL_GRAPH, -1, VAL_IMMEDIATE_DRAW);
            
            double waveData[100], amp, phase, cycles;
            int n;
            n = 100;
            amp = 90.0;
            //和Sine函数不同，此处相位应为90(度)
            phase = 90.0;
            cycles = 1.5;
            SinePattern(n, amp, phase, cycles, waveData);
            
            PlotY(panelHandle, PANEL_GRAPH, waveData, n, VAL_DOUBLE, VAL_THIN_LINE, 
                  VAL_EMPTY_SQUARE, VAL_SOLID, VAL_CONNECTED_POINTS , VAL_YELLOW);
            break;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;好的，至此两个按钮的回调函数都已经完成。下面需要开始&lt;strong&gt;试运行(Debug程序)&lt;/strong&gt;&lt;br /&gt;
有两种方法&lt;strong&gt;试运行&lt;/strong&gt;程序&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过工具栏的&lt;strong&gt;红色播放按钮&lt;/strong&gt;试运行&lt;/li&gt;
  &lt;li&gt;通过菜单栏的&lt;strong&gt;Run&lt;/strong&gt; » &lt;strong&gt;Debug 2-Using-Graph-Demo.exe&lt;/strong&gt;选项来试运行程序&lt;br /&gt;
具体操作如下图所示：&lt;br /&gt;
&lt;img src=&quot;http://ww2.sinaimg.cn/large/6480dca9tw1e66qebhm8wj20b009ojsh.jpg&quot; alt=&quot;&quot; /&gt; &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行结果:&lt;br /&gt;
&lt;img src=&quot;http://ww3.sinaimg.cn/large/6480dca9tw1e66pudgy7aj20ej0l6abp.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;程序源码&lt;a href=&quot;https://github.com/HelloLyfing/LabWindows-CVI-Tutorial-For-Newbie-By.Lyfing&quot;&gt;托管在Github&lt;/a&gt;上，请自行前往查看。&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2013/07/10/Labwindows-tutorial-chapter2.html&quot;&gt;Labwindows.Tutorial.Chapter 2&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on July 10, 2013.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Labwindows.Tutorial.Chapter 1]]></title>
  <link>http://localhost:4000/2013/06/28/Labwindows-tutorial-chapter1.html</link>
  <id>http://localhost:4000/2013/06/28/Labwindows-tutorial-chapter1</id>
  <updated>2013-06-28T00:00:00-00:00</updated>
  <published>2013-06-28T00:00:00+08:00</published>
  
  <author>
    <name>Lyfing.Loo</name>
    <uri>http://localhost:4000</uri>
    <email>hellolyfing@gmail.com</email>
  </author>
  <content type="html">&lt;p&gt;&lt;em&gt;前言：LabWindows/CVI是一款功能强大的集成了图形化界面编辑器以及对各种硬件通信协议支持的集成开发环境，它使用ANSI标准的C语言作为主要的编程语言。&lt;/em&gt; &lt;/p&gt;

&lt;p&gt;编写该系列教程的原因：自己大学的毕设题目选的就是&lt;a href=&quot;https://github.com/HelloLyfing/Signal_Monitor_System_Based_On_LabWindows-CVI&quot;&gt;基于LabWindows/CVI的信号监测系统开发&lt;/a&gt;，自己当时的状态是： &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;对C语言基本不了解，不会用  &lt;/li&gt;
  &lt;li&gt;对LabWindows/CVI完全不了解 &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当时很想看一看中文的博客有没有相关的基础教程，这样一来自己也好尽快上手系统开发工作，谷歌百度后发现这些内容寥寥无几，无奈自己只好从看官方的英文帮助文档开始，一路摸索着完成了毕设项目的开发。但在查阅官方帮助文档的过程中我才发现，&lt;strong&gt;对学习、使用LabWindows/CVI真正有帮助的&lt;/strong&gt;其实就是&lt;strong&gt;阅读帮助文档&lt;/strong&gt;。虽然它是英文写成，却实在丰富全面，很多函数的使用方法说明下方都会附有样例工程，让你可以进一步了解如何使用这些函数，所以英文基础好的童鞋还是多看看官方帮助文档吧。  &lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;好了，闲话少说，我们今天就开始LabWindows/CVI的第一个工程：  &lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;&lt;strong&gt;Hello World.&lt;/strong&gt;  &lt;/p&gt;

&lt;p&gt;具体内容：&lt;br /&gt;
创建一个主面板（在LabWindows/CVI内部，Panel和Windows系统的窗口概念相当），在主面板上放置一个按钮，点击按钮，弹出消息”Hello world”.效果如下所示：&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094523406&quot; alt=&quot;&quot; /&gt;  &lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;具体步骤&lt;/h3&gt;

&lt;p&gt;1, 在LabWindows/CVI的开始界面，选择 Project » New project，创建一个新工程&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094251656&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2, 通过File » New » User Interface(*.uir)… 新建用户界面源文件文件&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094312921&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;3, 系统会自动创建一个”Untitled Panel”,在该Panel(面板)的任意位置双击，打开&lt;strong&gt;面板属性设置&lt;/strong&gt;窗口  &lt;/p&gt;

&lt;p&gt;4, 如图所示操作，把&lt;strong&gt;Panel Title&lt;/strong&gt;改成&lt;strong&gt;Hello World&lt;/strong&gt;. 然后_回车_或_点击确定_回到主Panel&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094326671&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5, 在主Panel任意位置右击，在弹出的&lt;strong&gt;控件列表&lt;/strong&gt;里选择 Command Button » Square Command Button.&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094338281&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;6, 主Panel上会出现一个&lt;strong&gt;OK&lt;/strong&gt;按钮，双击该按钮打开&lt;strong&gt;按钮属性设置&lt;/strong&gt;窗口。在&lt;strong&gt;Callback function：&lt;/strong&gt;一栏填写”OK_Btn_Callback”(即Ok按钮的回调函数)。然后_回车_或_点击确定_回到主Panel&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620093039000&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;7, 用同样的方法再创建一个按钮(按钮可以通过Windows的”复制-粘贴”快捷键快速创建)，双击该按钮打开&lt;strong&gt;按钮属性设置&lt;/strong&gt;窗口，按顺序依次设置”Label”及”Callback function”的值。然后_回车_或_点击确定_回到主Panel&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094426234&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;8, 在系统菜单栏，依次选择Code » Generate » All Code…来创建&lt;strong&gt;控件对应的执行代码文件(.c)&lt;/strong&gt; &lt;br /&gt;
之后，在弹出的窗口依次点击&lt;strong&gt;Yes&lt;/strong&gt; &lt;strong&gt;Ok&lt;/strong&gt;&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094436953&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094409890&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094418312&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;9, 按图示内容设置配置目标C文件的内容&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094452156&quot; alt=&quot;&quot; /&gt; &lt;/p&gt;

&lt;p&gt;10, 在弹出的&lt;strong&gt;New Project Option&lt;/strong&gt;菜单点击&lt;strong&gt;OK&lt;/strong&gt;.&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094459453&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;11, 之后会弹出&lt;strong&gt;HelloWorld.c&lt;/strong&gt;文件的编辑界面。将光标定位到&lt;code&gt;OK_Btn_Callback()&lt;/code&gt;函数,在&lt;code&gt;switch(event)&lt;/code&gt;语句的&lt;code&gt;case EVENT_COMMIT&lt;/code&gt;和&lt;code&gt;break;&lt;/code&gt;之间添加代码，内容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch (event) {
	case EVENT_COMMIT:  
		char title[30] = &quot;I&#39;m the title!&quot;;  
		char msg[100] = &quot;Hello World !&quot;;  
		MessagePopup(title, msg);  
		break;  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130620094512031&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;好了，一切准备工作都已就绪，我们试运行一下这个程序，点击如图所示的&lt;strong&gt;Debug Project&lt;/strong&gt;按钮，运行程序吧！&lt;br /&gt;
&lt;img src=&quot;http://img.blog.csdn.net/20130620094358046&quot; alt=&quot;&quot; /&gt; &lt;/p&gt;

&lt;p&gt;效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://img.blog.csdn.net/20130620094523406&quot; alt=&quot;&quot; /&gt;  &lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;程序源码&lt;a href=&quot;https://github.com/HelloLyfing/LabWindows-CVI-Tutorial-For-Newbie-By.Lyfing&quot;&gt;托管在Github&lt;/a&gt;上，请自行前往查看。&lt;/p&gt;


  &lt;p&gt;&lt;a href=&quot;http://localhost:4000/2013/06/28/Labwindows-tutorial-chapter1.html&quot;&gt;Labwindows.Tutorial.Chapter 1&lt;/a&gt; was originally published by Lyfing.Loo at &lt;a href=&quot;http://localhost:4000&quot;&gt;Lyfing.Loo's Blog&lt;/a&gt; on June 28, 2013.&lt;/p&gt;</content>
</entry>

</feed>
