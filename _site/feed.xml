<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-07-30T09:57:11+08:00</updated><id>http://localhost:4000/</id><title type="html">蓝枫铭的技术博客</title><subtitle>立志成长为一名优秀架构师:)</subtitle><entry><title type="html">Java并发编程之：Java内存模型</title><link href="http://localhost:4000/2018/07/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" rel="alternate" type="text/html" title="Java并发编程之：Java内存模型" /><published>2018-07-30T00:00:00+08:00</published><updated>2018-07-30T00:00:00+08:00</updated><id>http://localhost:4000/2018/07/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B:Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B</id><content type="html" xml:base="http://localhost:4000/2018/07/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html">&lt;p&gt;The Java memory model specifies how the Java virtual machine works with the computer’s memory (RAM). The Java virtual machine is a model of a whole computer so this model naturally includes a memory model - AKA the Java memory model.&lt;/p&gt;

&lt;p&gt;It is very important to understand the Java memory model if you want to design correctly behaving concurrent programs. The Java memory model specifies how and when different threads can see values written to shared variables by other threads, and how to synchronize access to shared variables when necessary.&lt;/p&gt;

&lt;p&gt;The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5. This version of the Java memory model is still in use in Java 8.&lt;/p&gt;

&lt;p&gt;前言：Java内存模型详细说明了Java虚拟机(以下将使用JVM这个术语)是如何与计算机的内存(RAM)进行交互的。JVM是一个完整计算机的模型，所以该模型也包含了内存模块，也就是我们熟知的Java内存模型。&lt;/p&gt;

&lt;p&gt;想要设计出符合预期的并发程序，了解Java的内存模型是非常重要的。Java内存模型详细描述了不同的线程如何以及何时可以看见被其他线程写入的共享变量，以及在需要时如何同步使用共享变量。&lt;/p&gt;

&lt;p&gt;Java内存模型在一开始是不够完善的，不过它在Java 1.5中被改进了。Java8依然在使用这一改进版本的内存模型。&lt;/p&gt;

&lt;h1 id=&quot;一一窥java内存模型的内部&quot;&gt;一、一窥Java内存模型的内部&lt;/h1&gt;

&lt;p&gt;The Java memory model used internally in the JVM divides memory between thread stacks and the heap. This diagram illustrates the Java memory model from a logic perspective:&lt;/p&gt;

&lt;p&gt;JVM中的Java内存模型将内存分为线程栈(thread stacks)和堆(heap)。下图从逻辑角度演示了Java的内存模型：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_concurrency/java-memory-model-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Each thread running in the Java virtual machine has its own thread stack. The thread stack contains information about what methods the thread has called to reach the current point of execution. I will refer to this as the “call stack”. As the thread executes its code, the call stack changes.&lt;/p&gt;

&lt;p&gt;The thread stack also contains all local variables for each method being executed (all methods on the call stack). A thread can only access it’s own thread stack. Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code, the two threads will still create the local variables of that code in each their own thread stack. Thus, each thread has its own version of each local variable.&lt;/p&gt;

&lt;p&gt;All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads. One thread may pass a copy of a pritimive variable to another thread, but it cannot share the primitive local variable itself.&lt;/p&gt;

&lt;p&gt;The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.). It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.&lt;/p&gt;

&lt;p&gt;Here is a diagram illustrating the call stack and local variables stored on the thread stacks, and objects stored on the heap:&lt;/p&gt;

&lt;p&gt;在JVM中运行的每个线程都有自己的线程栈。线程栈包含的信息为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/java_concurrency/java-memory-model-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本篇文章翻译自：http://tutorials.jenkov.com/java-concurrency/java-memory-model.html&lt;/p&gt;</content><author><name></name></author><summary type="html">The Java memory model specifies how the Java virtual machine works with the computer’s memory (RAM). The Java virtual machine is a model of a whole computer so this model naturally includes a memory model - AKA the Java memory model.</summary></entry><entry><title type="html">Memcached核心技术初探</title><link href="http://localhost:4000/2018/06/29/Memcached%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2.html" rel="alternate" type="text/html" title="Memcached核心技术初探" /><published>2018-06-29T00:00:00+08:00</published><updated>2018-06-29T00:00:00+08:00</updated><id>http://localhost:4000/2018/06/29/Memcached%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2</id><content type="html" xml:base="http://localhost:4000/2018/06/29/Memcached%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%88%9D%E6%8E%A2.html">&lt;h1 id=&quot;1-memcached概述&quot;&gt;1 Memcached概述&lt;/h1&gt;
&lt;h2 id=&quot;11-memcached是什么&quot;&gt;1.1 Memcached是什么&lt;/h2&gt;
&lt;p&gt;Memcached是一个高性能、分布式的内存缓存系统，它通过在内存中缓存数据和对象来减少数据库的读取次数，从而提升动态数据库驱动型网站的访问体验。&lt;/p&gt;

&lt;p&gt;Memcached本质上是一个基于String类型的键/值对的缓存系统。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1.png?raw=true&quot; alt=&quot;---1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;12-memcached的特性&quot;&gt;1.2 Memcached的特性&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;支持文本和二进制两种通信协议&lt;/em&gt;&lt;/strong&gt;
文本协议(&lt;code class=&quot;highlighter-rouge&quot;&gt;ASCII Protocol&lt;/code&gt;)是Memcached一开始使用的协议，它简单可靠，我们可以通过telnet工具试用一下该协议：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;telnet 127.0.0.1 11211
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.

# 客户端set命令
set testkey 0 60 5
hello

# 服务端响应内容
STORED

# 客户端get命令
get testkey

# 服务端响应内容
VALUE testkey 0 5
hello
END
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了提升客户端命令解析的速度，提高数据内容的可扩展性，Memcached在v1.3之后引入了Binary协议(&lt;code class=&quot;highlighter-rouge&quot;&gt;Binary Protocol&lt;/code&gt;)。对这种协议感兴趣的可自行了解一下，此处不再细说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;基于Libevent处理请求&lt;/em&gt;&lt;/strong&gt;
Libevent是一个提供异步事件回调的C程序。它支持&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev/poll&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;kqueue(2)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;POSIX select(2)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Windows IOCP&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;poll(2)&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;epoll(4)&lt;/code&gt; 以及 &lt;code class=&quot;highlighter-rouge&quot;&gt;Solaris event ports&lt;/code&gt;等各系统的调用，并对外提供了一套统一的API，使其在Server端跨平台的高并发应用场景中拥有独特优势。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;使用内存作为唯一存储介质&lt;/em&gt;&lt;/strong&gt;
是的，Memcached是一个只关注于缓存的系统，它不支持缓存的持久化，一切数据都只在RAM中存储。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Key与Value长度有上限&lt;/em&gt;&lt;/strong&gt;
Key长度不能超过250个字节，Value长度则不能超过1MB.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;存储超限时使用LRU策略淘汰数据&lt;/em&gt;&lt;/strong&gt;
LRU(Least recently used)淘汰算法是实现简单、应用最为广泛的淘汰算法之一，后面我们会详细讨论它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;实现逻辑：一半在服务端，一半在客户端&lt;/em&gt;&lt;/strong&gt;
比如Memcached分布式的实现，就是依靠客户端对Key的Hash散列实现的
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-1.png?raw=true&quot; alt=&quot;---1-1&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-memcached的内存模型&quot;&gt;2 Memcached的内存模型&lt;/h1&gt;
&lt;p&gt;下图是Memcached内存中的数据结构概览。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-8.png?raw=true&quot; alt=&quot;---1-8&quot; /&gt;
其中slab-class用来管理slab, 每个slab都是固定大小1MB的，但slab中真正用于存储数据(item)的chunk，它的尺寸在同一slab中是相等的。图中的item-hash-table用于存储key-item的映射关系。&lt;/p&gt;

&lt;p&gt;那么slab到底是什么呢？Memcached在数据存储时为减少申请、释放内存产生的系统调用的次数（以提高效率）和释放内存产生的碎片， 每次向系统申请内存时会直接申请一个slab page size(1M)大小的内存空间，并将其分配给特定slab。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-2.png?raw=true&quot; alt=&quot;---1-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;该slab则会将内存空间切分为size相同的块(chunk)
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-3.png?raw=true&quot; alt=&quot;---1-3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个缓存的item，最终会落到和自己长度最接近的slab chunk中(item size &amp;lt;= trunk size)
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-7.png?raw=true&quot; alt=&quot;---1-7&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个slab大小都为1MB，为支持各种长度的item存储，多个slab在初始化其内部chunk时会按照增长因子(&lt;code class=&quot;highlighter-rouge&quot;&gt;factor&lt;/code&gt;，可配置)依次递增，从而达到存储各种尺寸item的目的。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-6.png?raw=true&quot; alt=&quot;---1-6&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-memcached的数据结构&quot;&gt;3 Memcached的数据结构&lt;/h1&gt;
&lt;p&gt;Memcached内部数据结构的核心是：LRU策略的缓存实现。这通常是由HashMap + LRU队列共同完成的。二者的关联关系如下图所示：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-9.png?raw=true&quot; alt=&quot;---1-9&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由于在执行每一次的set/get等命令时需要变更HashMap和LRU队列的顺序，在高并发场景下为保护数据的一致性，就必须对这两个数据结构进行加锁操作。当然了，加锁必然会带来并发性能的急剧下降。&lt;/p&gt;

&lt;p&gt;我们来看一下一次客户端请求Memcached的完整工作流：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-11.png?raw=true&quot; alt=&quot;---1-11&quot; /&gt;
从上图可以看出对HashMap和LRU队列进行的操作加了全局锁，在高并发场景下，这种全局锁肯定是不可接受的，我们将试着提出一些优化的思路。不过在这之前，我们先简单了解一下这两种数据结构。&lt;/p&gt;

&lt;p&gt;HashMap的结构图如下所示：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-10.png?raw=true&quot; alt=&quot;---1-10&quot; /&gt;
我们知道根据一致性哈希算法，给定一个key，它一定会落到HashMap(Table)中的某个Bucket中，多个落到同一Bucket中的key会被放入单向链表中去。&lt;/p&gt;

&lt;p&gt;已知这个数据结构后我们会发现，给定单个key-item后，只需要完成对特定Bucket的锁定即可，无需锁定全局HashMap，这种锁便是分区锁。事实上Java语言中的ConcurrentHashMap就是通过这种锁实现的高并发操作。加锁的结构示意图如下：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-12.png?raw=true&quot; alt=&quot;---1-12&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来我们再了解一下LRU队列。LRU是一种淘汰机制，当给定空间不足时以最近最少使用为指标淘汰数据。其在操作系统内存管理、Innodb缓存管理中都有应用。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-13.png?raw=true&quot; alt=&quot;---1-13&quot; /&gt;
LRU的实现通常都是一个双向的链表，在不加锁的情况下对链表进行高并发操作容易造成各种问题（比如空指针），如下图所示。但加上全局锁则会对性能造成影响。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-14.png?raw=true&quot; alt=&quot;---1-14&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对LRU的高并发操作的优化是一个持续的话题，本篇不再细讲，感兴趣的同学可以自行了解下。&lt;/p&gt;

&lt;p&gt;通过对HashMap和LRU这两种核心数据结构进行分区锁/无锁的优化后，一次请求的流程图将变为下图所示的样子：
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-19.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;4-memcached的网络模型&quot;&gt;4 Memcached的网络模型&lt;/h1&gt;
&lt;p&gt;为了支持高并发连接和跨平台部署，Memcached使用了Libevent来进行网络连接管理。&lt;/p&gt;

&lt;p&gt;Libevent是一个提供异步事件回调的C程序。它支持 /dev/poll, kqueue(2), POSIX select(2), Windows IOCP, poll(2), epoll(4) 以及 Solaris event ports等各系统的调用，并对外提供了一套统一的API，使其在跨平台的高并发应用场景拥有独特优势。&lt;/p&gt;

&lt;p&gt;说到select/poll，以及epoll/kqueue，就不得不说下他们的历史。从上世纪80年代开始，由于只有select和poll同步阻塞式的系统调用，Server端对客户端高并发网络连接的支持只能通过创建更多线程(池)或更强劲的机器性能实现。select和poll本质上相差不多，他们的时间复杂度都是O(n).
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-15.png?raw=true&quot; alt=&quot;---1-15&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不过当Unix系统引入了epoll和kqueue等系统调用后，Server端对高并发网络连接的支持困境得到了极大优化。二者的时间复杂度都是O(1)!
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-16.png?raw=true&quot; alt=&quot;---1-16&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Libevent正是上面所述的系统调用的集大成者，它封装个底层操作系统的系统调用函数并对开发者提供了统一的API，也难怪它被广泛地应用在跨平台的高并发场景。
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-17.png?raw=true&quot; alt=&quot;---1-17&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;5-memcached-vs-redis&quot;&gt;5 Memcached vs Redis&lt;/h1&gt;
&lt;p&gt;谈到Memcached的对比，就不得不拿老对手Redis来进行一番比较。以下是二者的对比
&lt;img src=&quot;https://github.com/HelloLyfing/hellolyfing.github.io/blob/master/images/cache/Memcached---1-18.png?raw=true&quot; alt=&quot;---1-18&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从对比中可以看出，Redis在不断迭代中已经成长为一个更全能的存储DB，缓存服务只是它功能的一部分(虽然仍是主要部分)；Memcached则始终关注String缓存这一功能，并且借由开源工具弥补了自己在集群、备份、主从等方面的短板。&lt;/p&gt;

&lt;p&gt;二者并没有完全的孰优孰劣的情况，在实战中应根据实际场景具体问题具体分析，毕竟最合适的才是最好的。&lt;/p&gt;</content><author><name></name></author><category term="Tech" /><summary type="html">1 Memcached概述 1.1 Memcached是什么 Memcached是一个高性能、分布式的内存缓存系统，它通过在内存中缓存数据和对象来减少数据库的读取次数，从而提升动态数据库驱动型网站的访问体验。</summary></entry><entry><title type="html">Bughole(虫洞)工具:预发断点调试PHP利器</title><link href="http://localhost:4000/2018/04/25/Bughole(%E8%99%AB%E6%B4%9E)%E5%B7%A5%E5%85%B7-%E9%A2%84%E5%8F%91%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95PHP%E5%88%A9%E5%99%A8.html" rel="alternate" type="text/html" title="Bughole(虫洞)工具:预发断点调试PHP利器" /><published>2018-04-25T00:00:00+08:00</published><updated>2018-04-25T00:00:00+08:00</updated><id>http://localhost:4000/2018/04/25/Bughole(%E8%99%AB%E6%B4%9E)%E5%B7%A5%E5%85%B7:%E9%A2%84%E5%8F%91%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95PHP%E5%88%A9%E5%99%A8</id><content type="html" xml:base="http://localhost:4000/2018/04/25/Bughole(%E8%99%AB%E6%B4%9E)%E5%B7%A5%E5%85%B7-%E9%A2%84%E5%8F%91%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95PHP%E5%88%A9%E5%99%A8.html">&lt;div class=&quot;wiki-content&quot;&gt;
                           &lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-true&quot;&gt;&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-效果图&quot;&gt;效果图&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-试用&quot;&gt;试用&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-debug获取评价列表API- BeibeiItemRateGet&quot;&gt;debug: 获取评价列表API -&amp;nbsp;BeibeiItemRateGet&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-debugProductTestTask任务product-module &quot;&gt;debug: ProductTestTask任务(product-module)&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-实战&quot;&gt;实战&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-实战1：debug任意URL&quot;&gt;实战1：debug任意URL&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-实战2：debugPHP任务（同上方debugProductTestTask）&quot;&gt;实战2：debug PHP任务（同上方debug ProductTestTask）&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.3&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-遇到问题要反馈？&quot;&gt;遇到问题要反馈？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;4&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-预发布如何部署&quot;&gt;预发布如何部署&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;5&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-Bughole原理&quot;&gt;Bughole原理&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;5.1&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-工程结构图&quot;&gt;工程结构图&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;5.2&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-时序图&quot;&gt;时序图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;6&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-安全考虑&quot;&gt;安全考虑&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;7&lt;/span&gt; &lt;a href=&quot;#Bughole虫洞工具：预发断点调试PHP利器-项目源码&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;/h2&gt;&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-效果图&quot;&gt;效果图&lt;/h2&gt;&lt;p&gt;Bughole工具实现了PHPStorm中&lt;span&gt;95%以上&lt;/span&gt;的debug功能。借助该工具在预发布调试：PHP的业务代码、API甚至任务脚本，都将变得极为方便！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;900&quot; src=&quot;http://wx1.sinaimg.cn/large/6480dca9ly9fr2nh08b2kj218g0s6tog.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-试用&quot;&gt;试用&lt;/h2&gt;&lt;p&gt;Bughole整套工具在预发9已经部署完备，以下步骤将分别演示：1）debug获取评价列表的API；2）debug PHP
任务&lt;/p&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-debug获取评价列表API-&amp;nbsp;BeibeiItemRateGet&quot;&gt;debug: 获取评价列表API -&amp;nbsp;BeibeiItemRateGet&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;打开bughole UI：&lt;a href=&quot;&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;#(暂不对外开放)&lt;/a&gt;&amp;nbsp;，&lt;strong&gt;并且确认自己已经连上了预发9&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;添加断点。在断点模块，点击“Add”按钮，新增断点信息(可通过类似方式不断增加断点)&lt;/li&gt;&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;文件路径：***/***/api/BeibeiItemRateGet.php&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;断点行号：26&lt;br /&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;填好断点信息，点击确定&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;点击“建立连接”按钮。则服务端agent开始监听Xdebug的拦截信息&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;在新标签页访问：&lt;/span&gt;&lt;/span&gt;&lt;a href=&quot;http://sapi.beibei.com/item/rate/0-27221145-1-10-1.html?preview=1&amp;amp;XDEBUG_SESSION_START=1&quot; style=&quot;font-size: 10.0pt;&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://sapi.beibei.com/item/rate/0-27221145-1-10-1.html?preview=1&amp;amp;XDEBUG_SESSION_START=1&lt;/a&gt;&amp;nbsp;。这个访问也必须是预发9的！此时Xdebug会尝试拦截这个访问，具体表现为：页面hanging转圈不返回&lt;/li&gt;&lt;li&gt;回到bughole UI，点击页面顶端的“点我测试”按钮。如果一切正常，你将看到如下图所示信息，这表明Xdebug已经正确开始了&lt;/li&gt;&lt;li&gt;试试StepOver命令，StepInto命令，StepOut命令？当然你也可以使用RunToLine命令。&lt;br /&gt;想查看当前Context的变量信息，就在右侧的Context面板查找吧。右下方还有调用栈信息&lt;br /&gt;最后，&lt;strong&gt;一定要记得点击“Stop”按钮停止debug&lt;/strong&gt;&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;500&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9ly9fr2osazim8j20z00oogyl.jpg&quot; /&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-debugProductTestTask任务product-module&amp;nbsp;&quot;&gt;debug: ProductTestTask任务(product-module)&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;打开bughole UI：&lt;a href=&quot;#&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;#（暂不对外开放）&lt;/a&gt;&amp;nbsp;，&lt;strong&gt;并且确认自己已经连上了预发9&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;添加断点。在断点模块，点击“Add”按钮，新增断点信息(可通过类似方式不断增加断点)&lt;/li&gt;&lt;ol&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;文件路径：***/***/src/task/ProductTestTask.php&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span class=&quot;input-group-addon&quot; style=&quot;color: rgb(85,85,85);&quot;&gt;断点行号：17&lt;br /&gt;&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(85,85,85);&quot;&gt;填好断点信息，点击确定&lt;/span&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;点击“建立连接”按钮。则服务端agent开始监听Xdebug的拦截信息&lt;/li&gt;&lt;li&gt;&lt;p&gt;在预发9机器上依次执行：&lt;/p&gt;
    &lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_722052&quot; class=&quot;syntaxhighlighter nogutter  bash&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# 切换到root用户&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;bash functions&quot;&gt;sudo&lt;/code&gt; &lt;code class=&quot;bash functions&quot;&gt;su&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# 为root用户设置环境变量(设置后Xdebug会主动拦截PHP脚本的运行)&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;bash functions&quot;&gt;export&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;XDEBUG_CONFIG=&lt;/code&gt;&lt;code class=&quot;bash string&quot;&gt;&quot;idekey=bughole&quot;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;bash comments&quot;&gt;# 执行任务（切记不要加sudo）&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;bash functions&quot;&gt;bash&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;/task/task_admin&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.sh start --module=product ProductTestTask&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/li&gt;&lt;li&gt;回到bughole UI，点击页面顶端的“点我测试”按钮。如果一切正常，你将看到如上图所示信息，这表明Xdebug已经正确开始了&lt;/li&gt;&lt;li&gt;&lt;span&gt;试试StepOver命令，StepInto命令，StepOut命令？当然你也可以使用RunToLine命令。&lt;/span&gt;&lt;br /&gt;&lt;span&gt;想查看当前Context的变量信息，就在右侧的Context面板查找吧。右下方还有调用栈信息&lt;/span&gt;&lt;br /&gt;&lt;span&gt;最后，&lt;/span&gt;&lt;strong&gt;一定要记得点击“Stop”按钮停止debug&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;说明：debug模式同一时间只允许一个人进行debug，如果有其他人也在debug，则可能出现错乱情况。&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;解决办法：1）避免同时使用debug；2）如果debug已经不正常，尝试重启：kill这个任务（python bughole/agent.py);重新运行:&amp;nbsp;python /tmp/tiny-scripts/bughole/agent.py (无需sudo)&lt;/span&gt;&lt;/p&gt;&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-实战&quot;&gt;实战&lt;/h2&gt;&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-实战1：debug任意URL&quot;&gt;实战1：debug任意URL&lt;/h3&gt;&lt;p&gt;详细步骤，请参考：debug获取评价列表API。&lt;/p&gt;&lt;p&gt;上方步骤4中触发Xdebug启动拦截的关键在于：URL后面要增加一个query（GET、POST皆可）:&amp;nbsp;&lt;u&gt;XDEBUG_SESSION_START=1&lt;/u&gt; 即可触发调试模式&lt;/p&gt;&lt;p&gt;&amp;nbsp;&lt;/p&gt;&lt;p&gt;当然，很多API接口会&lt;u&gt;对请求参数中的sign做安全校验&lt;/u&gt;，意即URL的GET参数不能随意增删，否则会报错：sign校验失败。遇到这种情况，可以通过在&lt;u&gt;Cookie中添加参数触发Xdebug启动&lt;/u&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;情况1：&lt;/strong&gt;如果你在Chrome浏览器中，可以通过Cookie管理工具为当前API域名添加Cookie:&amp;nbsp;XDEBUG_SESSION = 1, HX-BETA = 9；或者直接在网页console中输入: document.cookie = 'HX-BETA=9; XDEBUG_SESSION=1;'&amp;nbsp; &amp;nbsp;然后接着上述步骤4的指示继续即可&lt;/p&gt;&lt;p&gt;&lt;strong&gt;情况2：&lt;/strong&gt;如果你在Charlse中，可以通过Rewrite工具为API添加Cookie，然后接着上述步骤4的指示继续即可&lt;/p&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-实战2：debugPHP任务（同上方debugProductTestTask）&quot;&gt;实战2：debug PHP任务（同上方debug ProductTestTask）&lt;/h3&gt;&lt;p&gt;步骤参考debug ProductTestTask任务。&lt;span&gt;触发Xdebug启动拦截的关键在于：当前用户的环境变量中设置了:&amp;nbsp;&lt;u&gt;XDEBUG_CONFIG=idekey=bughole&lt;/u&gt;&amp;nbsp;这个变量（使用env命令可以查看当前用户空间的变量）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;由于通过sudo export命令设置环境变量会失败，所以需要切换到root用户运行任务脚本。&lt;/p&gt;&lt;p&gt;注意：&lt;span&gt;多进程的任务(worker_num &amp;gt;= 2)在debug时会出现异常，解决办法：debug时将worker_num设为1，debug完成后再改回原值。&lt;/span&gt;&lt;/p&gt;&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-遇到问题要反馈？&quot;&gt;遇到问题要反馈？&lt;/h3&gt;&lt;p&gt;遇到使用问题，烦请联系我qq: 379396993, 我会尽快帮忙查看问题&lt;/p&gt;&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-预发布如何部署&quot;&gt;预发布如何部署&lt;/h2&gt;&lt;p&gt;1）拉取agent代码。注意将 GitLab用户名 替换为自己的用户名&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_530619&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;cd /tmp&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;git clone http:&lt;/code&gt;&lt;code class=&quot;java comments&quot;&gt;//GitLab用户名@git.husor.com/dongxu.lu/tiny-scripts.git&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;2）安装Xdebug（如果已安装请跳过本步）&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_392489&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# 查看是否安装Xdebug，如果已安装请跳过本步&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;/opt/php-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7.1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/bin/php -m |grep Xdebug&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# copy编译好的扩展至PHP指定目录&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;cp /tmp/tiny-scripts/bughole/xdebug.so /opt/php-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7.1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/lib/php/extensions/no-debug-non-zts-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;20160303&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# 新建文件: /opt/php-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7.1&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;9&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;/etc/conf.d/xdebug.ini , 内容如下&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;zend_extension = xdebug.so&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_enable = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_connect_back = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_host = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;127.0&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;.&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0.1&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_port = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;21733&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_handler = dbgp&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_mode = req&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.remote_autostart = &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;0&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;xdebug.idekey = &lt;/code&gt;&lt;code class=&quot;java string&quot;&gt;&quot;bughole&quot;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# 重启PHP-FPM&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;service php-fpm-&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;7&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;restart&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;3）agent持久运行&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_666068&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;python /tmp/tiny-scripts/bughole/agent.py &amp;gt; /tmp/bughole-agent.log &lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;2&lt;/code&gt;&lt;code class=&quot;java plain&quot;&gt;&amp;gt;&amp;amp;&lt;/code&gt;&lt;code class=&quot;java value&quot;&gt;1&lt;/code&gt; &lt;code class=&quot;java plain&quot;&gt;&amp;amp;&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p class=&quot;p1&quot;&gt;4）部署已完成。确认agent已运行&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_831199&quot; class=&quot;syntaxhighlighter nogutter  java&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;# agent会返回OK&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;java plain&quot;&gt;curl http:&lt;/code&gt;&lt;code class=&quot;java comments&quot;&gt;//127.0.0.1:21734&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-Bughole原理&quot;&gt;Bughole原理&lt;/h2&gt;&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-工程结构图&quot;&gt;工程结构图&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;900&quot; src=&quot;http://wx4.sinaimg.cn/large/6480dca9gy1fr2oyic41bj211m0mqq5k.jpg&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-时序图&quot;&gt;时序图&lt;/h3&gt;&lt;p&gt;以最常用的StepOver(下一行)命令的执行时序作为示例&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;900&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fr2ozus21pj21bu0tc783.jpg&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-安全考虑&quot;&gt;安全考虑&lt;/h2&gt;&lt;p&gt;Bughole未提供&lt;strong&gt;eval接口&lt;/strong&gt;，所有操作都为“读”操作，不会对线上业务数据造成污染&lt;/p&gt;&lt;p&gt;待本周发布上线试用几天后会及时更新使用和部署(Agent)文档&lt;/p&gt;

&lt;h2 id=&quot;Bughole虫洞工具：预发断点调试PHP利器-项目源码&quot;&gt;项目源码&lt;/h2&gt;
暂不对外开放，如有需要请电邮我
&lt;/div&gt;</content><author><name></name></author><summary type="html">1 效果图 2 试用 2.1 debug: 获取评价列表API -&amp;nbsp;BeibeiItemRateGet 2.2 debug: ProductTestTask任务(product-module)&amp;nbsp; 3 实战 3.1 实战1：debug任意URL 3.2 实战2：debug PHP任务（同上方debug ProductTestTask） 3.3 遇到问题要反馈？ 4 预发布如何部署 5 Bughole原理 5.1 工程结构图 5.2 时序图 6 安全考虑 7 项目源码 效果图Bughole工具实现了PHPStorm中95%以上的debug功能。借助该工具在预发布调试：PHP的业务代码、API甚至任务脚本，都将变得极为方便！</summary></entry><entry><title type="html">PHP任务的多进程处理</title><link href="http://localhost:4000/2018/03/20/PHP%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86.html" rel="alternate" type="text/html" title="PHP任务的多进程处理" /><published>2018-03-20T00:00:00+08:00</published><updated>2018-03-20T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/20/PHP%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86</id><content type="html" xml:base="http://localhost:4000/2018/03/20/PHP%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%A4%84%E7%90%86.html">&lt;div class=&quot;wiki-content&quot;&gt;
                           &lt;p&gt;&lt;/p&gt;&lt;div&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;1&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-概述&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-PHP的多进程管理（PCNTL扩展）&quot;&gt;PHP的多进程管理（PCNTL扩展）&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.1&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-示例1：简易demo&quot;&gt;示例1：简易demo&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;2.2&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-示例2：实际应用场景初探&quot;&gt;示例2：实际应用场景初探&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-PCNTL扩展进阶使用&quot;&gt;PCNTL扩展进阶使用&lt;/a&gt;&lt;/li&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.1&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-子进程的管理（监控终止子进程）&quot;&gt;子进程的管理（监控/终止子进程）&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.2&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-父子进程的信号处理&quot;&gt;父/子进程的信号处理&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;3.3&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-任务（进程）的后台执行&quot;&gt;任务（进程）的后台执行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    &lt;li&gt;&lt;span class=&quot;TOCOutline&quot;&gt;4&lt;/span&gt; &lt;a href=&quot;#PHP任务的多进程处理-附录：通用PHP任务框架流程图&quot;&gt;附录：通用PHP任务框架流程图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 id=&quot;PHP任务的多进程处理-概述&quot;&gt;概述&lt;/h2&gt;&lt;p&gt;很多以PHP为编程语言的Web项目，在需要做异步业务、数据的处理时，仍然会选择使用PHP语言来编写任务脚本。&lt;span&gt;这么做的优点不言而喻，通用的底层model、业务service、熟悉的公共类及方法，让熟悉Web业务开发的工程师可以花最快的时间以及最小的学习成本快速编写出特定场景的业务脚本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然而PHP是为Web网页制作而生的单进程处理语言，当他遇到大数据场景下的业务数据的处理需求时，如果仍然依靠单进程的方式进行，不仅耗费更多时间、浪费服务器资源，而且可能很快就会遇到性能瓶颈。在这样一种场景需求下，PHP语言的多进行/线程处理能力就显得尤为需要了。&lt;br /&gt;&lt;br /&gt;PHP对多进程处理的支持虽然已经到来了(&lt;a href=&quot;https://github.com/krakjoe/pthreads&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://github.com/krakjoe/pthreads&lt;/a&gt;&amp;nbsp;)，然而它却只能在PHP7.2+以上的版本中运行，而且需要&lt;span style=&quot;color: rgb(34,34,34);&quot;&gt;Thread Safety特性的支持。在这样一种现状下，使PHP支持多进程处理似乎是唯一（但不是最坏）的选择了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 id=&quot;PHP任务的多进程处理-PHP的多进程管理（PCNTL扩展）&quot;&gt;PHP的多进程管理（PCNTL扩展）&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://php.net/manual/zh/intro.pcntl.php&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;PCNTL扩展&lt;/a&gt;&amp;nbsp;实现了类Unix系统中的进程创建、执行、信号处理以及最终的进程终止，更具体的实现方式可以参考类Unix系统提供的&lt;a href=&quot;http://man7.org/linux/man-pages/man2/fork.2.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;fork(2)&lt;/a&gt;、waitpid(2)和signal(2)函数接口。&lt;/p&gt;&lt;p&gt;贝贝PHP的开发环境默认配置了PCNTL扩展，如果你的环境需要安装或配置该扩展，还请自行查找方法，此处略过。&lt;/p&gt;&lt;p&gt;对PCNTL扩展有了初步的认识后，我们先来编写一个多进程的demo任务练练手，熟悉一下该扩展中核心函数pcntl_fork的使用场景及方法&lt;/p&gt;&lt;h4 id=&quot;PHP任务的多进程处理-示例1：简易demo&quot;&gt;示例1：简易demo&lt;/h4&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_269057&quot; class=&quot;syntaxhighlighter nogutter  php&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;&amp;lt;?php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;I'm in the Main process!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;&amp;nbsp;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;php comments&quot;&gt;// 当前进程：主进程&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= pcntl_fork();&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;php comments&quot;&gt;// pcntl_fork()被执行后，系统会立即创建子进程，而且子进程的执行入口为紧跟在pcntl_fork()之后的代码，与主进程即将执行的代码一致&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Who am I ?\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;php comments&quot;&gt;// 此时需要一种机制或约定来让编程人员判断当前代码执行的环境为主进程中or子进程中&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== -1) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Fork child process faield, exit!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(1);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;I'm in the child process!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Child process exit.\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(0);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;&amp;gt; 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;I'm still in the main process!\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php string&quot;&gt;&quot;Main process exit.\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(0);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;上面那段代码的输出会是什么样子呢？&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;运行结果&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_525915&quot; class=&quot;syntaxhighlighter collapsed nogutter  bash&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_expandSource expandSource&quot;&gt;expand source&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;[root@1d42e4522359 tmp]&lt;/code&gt;&lt;code class=&quot;bash comments&quot;&gt;# php test.php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;I'm &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;the Main process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Who am I ?&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;I'm still &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;the main process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Main process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Who am I ?&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;I'm &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;in&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;the child process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Child process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;从上面的示例代码中可以看出：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不同于多线程中只会被新线程执行的特定代码块，多进程代码在被执行时，父进程与子进程几乎共用同一份代码，即&lt;span&gt;pcntl_fork()之后的代码&lt;/span&gt;&lt;/li&gt;&lt;li&gt;由于子进程被创建之后，父进程与子进程就相当于两个独立的进程，二者共用pcntl_fork()之后的代码，而且执行顺序没有保证，所以需要通过pcntl_fork()函数的返回值来判断当前进程所属父/子进程，以便通过if-else判断为父/子进程预设置不同的执行代码。pcntl_fork()函数的返回值$pid有三种情况：&lt;br /&gt;&lt;ul&gt;&lt;li&gt;$pid = -1: 子进程创建失败，通常情况下子进程创建失败，程序都会记录原因后主动退出&lt;/li&gt;&lt;li&gt;$pid &amp;gt; 0: 子进程创建成功。当前进程为父进程，其中$pid的值即为刚创建成功的子进程的进程id&lt;/li&gt;&lt;li&gt;$pid = 0: 子进程创建成功。当前进程为子进程&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;PHP任务的多进程处理-示例2：实际应用场景初探&quot;&gt;示例2：实际应用场景初探&lt;/h4&gt;&lt;p&gt;下面我们来编写一例有实际应用场景的例子：父&lt;span&gt;进程创建2个子进程，每个子进程的工作内容相同：从主进程分配给自己的网址中抓取网页的标题字段并打印出来，然后退出程序。父进程在sleep几秒（其实是在等待子程序执行完并主动退出）后也退出程序。&lt;/span&gt;&lt;/p&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_440581&quot; class=&quot;syntaxhighlighter  php&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line number22 index21 alt1&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line number23 index22 alt2&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line number24 index23 alt1&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line number25 index24 alt2&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line number26 index25 alt1&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line number27 index26 alt2&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line number28 index27 alt1&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line number29 index28 alt2&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line number30 index29 alt1&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line number31 index30 alt2&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line number32 index31 alt1&quot;&gt;32&lt;/div&gt;&lt;div class=&quot;line number33 index32 alt2&quot;&gt;33&lt;/div&gt;&lt;div class=&quot;line number34 index33 alt1&quot;&gt;34&lt;/div&gt;&lt;div class=&quot;line number35 index34 alt2&quot;&gt;35&lt;/div&gt;&lt;div class=&quot;line number36 index35 alt1&quot;&gt;36&lt;/div&gt;&lt;div class=&quot;line number37 index36 alt2&quot;&gt;37&lt;/div&gt;&lt;div class=&quot;line number38 index37 alt1&quot;&gt;38&lt;/div&gt;&lt;div class=&quot;line number39 index38 alt2&quot;&gt;39&lt;/div&gt;&lt;div class=&quot;line number40 index39 alt1&quot;&gt;40&lt;/div&gt;&lt;div class=&quot;line number41 index40 alt2&quot;&gt;41&lt;/div&gt;&lt;div class=&quot;line number42 index41 alt1&quot;&gt;42&lt;/div&gt;&lt;div class=&quot;line number43 index42 alt2&quot;&gt;43&lt;/div&gt;&lt;div class=&quot;line number44 index43 alt1&quot;&gt;44&lt;/div&gt;&lt;div class=&quot;line number45 index44 alt2&quot;&gt;45&lt;/div&gt;&lt;div class=&quot;line number46 index45 alt1&quot;&gt;46&lt;/div&gt;&lt;div class=&quot;line number47 index46 alt2&quot;&gt;47&lt;/div&gt;&lt;div class=&quot;line number48 index47 alt1&quot;&gt;48&lt;/div&gt;&lt;div class=&quot;line number49 index48 alt2&quot;&gt;49&lt;/div&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;&amp;lt;?php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$msg&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;print&lt;/code&gt; &lt;code class=&quot;php variable&quot;&gt;$msg&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;. &lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;\n&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;function&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;get_url_title(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$content&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= &lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;file_get_contents&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= NULL;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$content&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;preg_match(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'/&amp;lt;title&amp;gt;(.+?)&amp;lt;\/title&amp;gt;/'&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$content&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;, &lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number12 index11 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number13 index12 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number14 index13 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;&amp;amp;&amp;amp; &lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;count&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) === 2) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number15 index14 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;php variable&quot;&gt;$match_arr&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;[1];&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number16 index15 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number17 index16 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;return&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;NULL;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number18 index17 alt1&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number19 index18 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number20 index19 alt1&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'Task begin.'&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number21 index20 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number22 index21 alt1&quot;&gt;&lt;code class=&quot;php variable&quot;&gt;$site_urls&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;array&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number23 index22 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'&lt;a href=&quot;https://www.beibei.com'&quot;&gt;https://www.beibei.com'&lt;/a&gt;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;,&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number24 index23 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;'&lt;a href=&quot;https://www.jd.com'&quot;&gt;https://www.jd.com'&lt;/a&gt;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;,&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number25 index24 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number26 index25 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number27 index26 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number28 index27 alt1&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;foreach&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$site_urls&lt;/code&gt; &lt;code class=&quot;php keyword&quot;&gt;as&lt;/code&gt; &lt;code class=&quot;php variable&quot;&gt;$_url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number29 index28 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number30 index29 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= pcntl_fork();&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number31 index30 alt2&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number32 index31 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;if&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== -1) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number33 index32 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;Fork child process faield, exit!&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number34 index33 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(1);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number35 index34 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;=== 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number36 index35 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;In the child process!&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number37 index36 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$_url&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;. &lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;' title =&amp;gt; '&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;. get_url_title(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$_url&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;));&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number38 index37 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;Child process exit.&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number39 index38 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;(0);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number40 index39 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;} &lt;/code&gt;&lt;code class=&quot;php keyword&quot;&gt;elseif&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$pid&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;&amp;gt; 0) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number41 index40 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;In the parent process, do nothing.&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number42 index41 alt1&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number43 index42 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number44 index43 alt1&quot;&gt;&amp;nbsp;&lt;/div&gt;&lt;div class=&quot;line number45 index44 alt2&quot;&gt;&lt;code class=&quot;php variable&quot;&gt;$i&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;= 7;&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number46 index45 alt1&quot;&gt;&lt;code class=&quot;php keyword&quot;&gt;while&lt;/code&gt; &lt;code class=&quot;php plain&quot;&gt;(&lt;/code&gt;&lt;code class=&quot;php variable&quot;&gt;$i&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;--) {&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number47 index46 alt2&quot;&gt;&lt;code class=&quot;php spaces&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;sleep(1);&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number48 index47 alt1&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;}&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number49 index48 alt2&quot;&gt;&lt;code class=&quot;php plain&quot;&gt;printLine(&lt;/code&gt;&lt;code class=&quot;php string&quot;&gt;&quot;Task end.&quot;&lt;/code&gt;&lt;code class=&quot;php plain&quot;&gt;);&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeHeader panelHeader&quot; style=&quot;border-bottom-width: 1px;&quot;&gt;&lt;b&gt;运行结果&lt;/b&gt;&lt;/div&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;div&gt;&lt;div id=&quot;highlighter_609586&quot; class=&quot;syntaxhighlighter collapsed nogutter  bash&quot;&gt;&lt;div class=&quot;toolbar&quot;&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_expandSource expandSource&quot;&gt;expand source&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;a href=&quot;#&quot; class=&quot;toolbar_item command_help help&quot;&gt;?&lt;/a&gt;&lt;/span&gt;&lt;/div&gt;&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;div class=&quot;container&quot; title=&quot;Hint: double-click to select code&quot;&gt;&lt;div class=&quot;line number1 index0 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;[root@1d42e4522359 beibei]&lt;/code&gt;&lt;code class=&quot;bash comments&quot;&gt;# php testpcntl.php&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Task begin.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number3 index2 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the parent process, &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;do&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;nothing.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number4 index3 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the child process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number5 index4 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the parent process, &lt;/code&gt;&lt;code class=&quot;bash keyword&quot;&gt;do&lt;/code&gt; &lt;code class=&quot;bash plain&quot;&gt;nothing.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number6 index5 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;In the child process!&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number7 index6 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;https:&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;//www&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.beibei.com title =&amp;gt; 贝贝网-买母婴上贝贝！1亿妈妈信赖的母婴正品特卖商城&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number8 index7 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Child process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number9 index8 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;https:&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;//www&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.jd.com title =&amp;gt; 京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number10 index9 alt1&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Child process &lt;/code&gt;&lt;code class=&quot;bash functions&quot;&gt;exit&lt;/code&gt;&lt;code class=&quot;bash plain&quot;&gt;.&lt;/code&gt;&lt;/div&gt;&lt;div class=&quot;line number11 index10 alt2&quot;&gt;&lt;code class=&quot;bash plain&quot;&gt;Task end.&lt;/code&gt;&lt;/div&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;p&gt;从上面的执行结果中我们又可以总结出PCNTL扩展函数的几个特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;1）子进程可以使用（继承了）父进程Context中的变量（如$_url）以及函数（如get_url_title()方法）&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;2）如果移除父进程最后的sleep代码你会发现，子进程在父进程退出后依然可以正常运行，并不会随主进程的退出而退出&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;PHP任务的多进程处理-PCNTL扩展进阶使用&quot;&gt;PCNTL扩展进阶使用&lt;/h2&gt;&lt;h4 id=&quot;PHP任务的多进程处理-子进程的管理（监控终止子进程）&quot;&gt;子进程的管理（监控/终止子进程）&lt;/h4&gt;&lt;p&gt;在实际的任务框架编写中，开发者通常会首先创建一个master进程，然后再由master进程创建N个子进程。其中每个子进程作为工作进程（worker process）进行实际的业务处理，master进程作为管理者，主要负责工作进程的调度、监管、维护、回收等内容。&lt;span&gt;到了某个具体业务处理的场景下，对应业务的开发者仅需要完成自己业务逻辑部分，并将其作为工作进程的一部分，即可快速嵌入到整体的任务框架中去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在这种任务框架模式下，master进程对子进程的监控及控制能力就显得尤为重要了。那么如何借用PCNTL扩展的函数接口对子进程进行监管与控制呢？&lt;/p&gt;&lt;p&gt;对子进程的监控，主要分两个方面：1）需要记录每个子进程的进程ID；2）可以通过子进程的进程ID获取子进程的运行状态（是否已结束、是否为僵尸进程）&lt;/p&gt;&lt;p&gt;对子进程的控制，主要是指：可以通过子进程的进程ID获取其运行状态，并可以停止或中断其运行。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;获取子进程运行状态，需要用到函数&lt;strong&gt;pcntl_waitpid&lt;/strong&gt;(int $pid, int &amp;amp;$status, int $options = 0)。本函数依赖于Linux系统的waitpid(2)函数的实现，作用为：阻断当前进程直到给定$pid的子进程退出（当遇到系统信号需要终止运行或调用信号处理函数时会转去进行信号处理）。注意该函数默认是阻塞型函数（除非$options设置为&lt;em&gt;WNOHANG&lt;/em&gt;），其会根据入参的不同，做出多种可能的处理和返回（不过由于当前进程通常都为管理子进程的父进程，并非worker进程，所以即便阻塞也没关系）。参数解释：&lt;/span&gt;&lt;ul&gt;&lt;li&gt;$pid：根据$pid值的范围进行不同的处理：&lt;br /&gt;&lt;ul&gt;&lt;li&gt;$pid &amp;lt; -1: 等待指定进程组ID下所有子进程的退出。其中进程组ID = abs($pid)，即$pid的绝对值&lt;/li&gt;&lt;li&gt;$pid = -1: 等待任意子进程（这里不太清楚，任意是指：用户空间的所有fork出的子进程？）的退出&lt;/li&gt;&lt;li&gt;$pid =&amp;nbsp; 0: 等待指定进程组ID下所有子进程的退出。其中进程组ID = 当前进程的进程组ID&lt;/li&gt;&lt;li&gt;$pid &amp;gt;&amp;nbsp; 0: 等待进程ID为$pid的&lt;span&gt;子进程退出&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;$status会在调用结束后被赋予子进程的状态信息，对$status结果的判断可以使用以下函数：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;pcntl_wifexited($status): 判断子进程是否正常退出&amp;nbsp;&lt;/li&gt;&lt;li&gt;pcntl_wifstopped($status): 判断子进程是否已停止&lt;/li&gt;&lt;li&gt;pcntl_wstopsig($status): 获取导致子进程停止（stop）的信号(signal)，当pcntl_wifstopped返回TRUE时使用&lt;/li&gt;&lt;li&gt;pcntl_wifsignaled($status): 判断子进程是否由于某信号而退出&lt;/li&gt;&lt;li&gt;pcntl_wtermsig($status): 获取导致子进程终止运行（terminate）的信号（signal），当pcntl_wifsignaled返回TRUE时使用&lt;/li&gt;&lt;li&gt;pcntl_wexitstatus($status): 获取已终止子进程的退出值（exit_code）&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;$options: 默认无需设置。但想要使用下面两种值需要&lt;span&gt;系统&lt;/span&gt;底层支持。参数&lt;span&gt;使用背景：&lt;/span&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;子进程退出时，内核会保存子进程的退出状态信息，直到父进程来消费这个状态信息，内核保存的状态信息即可释放&lt;/span&gt;&lt;br /&gt;&lt;ul&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;WNOHANG 作用：如果父进程不想阻塞式获取子进程状态可传入该值，则如果没有子进程退出，本次函数调用会立即return 0&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;WUNTRACED 作用：返回：进程已经stop了，但状态信息未被消费（取走）的子进程$pid&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;@return: 本次函数调用有3中返回结果，他们分别是：&lt;br /&gt;&lt;ul&gt;&lt;li&gt;result &amp;gt; 0: 返回值为：已退出的子进程的进程ID&lt;/li&gt;&lt;li&gt;result = -1: 函数调用出错&lt;/li&gt;&lt;li&gt;result = 0: 当使用&lt;span style=&quot;color: rgb(36,39,41);&quot;&gt;WNOHANG选项，并且无子进程退出时会返回0&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;PHP任务的多进程处理-父子进程的信号处理&quot;&gt;父/子进程的信号处理&lt;/h4&gt;&lt;h4 id=&quot;PHP任务的多进程处理-任务（进程）的后台执行&quot;&gt;任务（进程）的后台执行&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未完待续...&lt;/span&gt;&lt;/p&gt;&lt;h2 id=&quot;PHP任务的多进程处理-附录：通用PHP任务框架流程图&quot;&gt;附录：通用PHP任务框架流程图&lt;/h2&gt;&lt;p&gt;通用PHP任务框架流程图：&lt;a href=&quot;http://7b1gf6.com1.z0.glb.clouddn.com/PHP%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.svg&quot;&gt;PHP多进程任务流程图.svg&lt;/a&gt;&lt;/p&gt;
    
        &lt;/div&gt;</content><author><name></name></author><summary type="html">1 概述 2 PHP的多进程管理（PCNTL扩展） 2.1 示例1：简易demo 2.2 示例2：实际应用场景初探 3 PCNTL扩展进阶使用 3.1 子进程的管理（监控/终止子进程） 3.2 父/子进程的信号处理 3.3 任务（进程）的后台执行 4 附录：通用PHP任务框架流程图 概述很多以PHP为编程语言的Web项目，在需要做异步业务、数据的处理时，仍然会选择使用PHP语言来编写任务脚本。这么做的优点不言而喻，通用的底层model、业务service、熟悉的公共类及方法，让熟悉Web业务开发的工程师可以花最快的时间以及最小的学习成本快速编写出特定场景的业务脚本。然而PHP是为Web网页制作而生的单进程处理语言，当他遇到大数据场景下的业务数据的处理需求时，如果仍然依靠单进程的方式进行，不仅耗费更多时间、浪费服务器资源，而且可能很快就会遇到性能瓶颈。在这样一种场景需求下，PHP语言的多进行/线程处理能力就显得尤为需要了。PHP对多进程处理的支持虽然已经到来了(https://github.com/krakjoe/pthreads&amp;nbsp;)，然而它却只能在PHP7.2+以上的版本中运行，而且需要Thread Safety特性的支持。在这样一种现状下，使PHP支持多进程处理似乎是唯一（但不是最坏）的选择了。PHP的多进程管理（PCNTL扩展）PCNTL扩展&amp;nbsp;实现了类Unix系统中的进程创建、执行、信号处理以及最终的进程终止，更具体的实现方式可以参考类Unix系统提供的fork(2)、waitpid(2)和signal(2)函数接口。贝贝PHP的开发环境默认配置了PCNTL扩展，如果你的环境需要安装或配置该扩展，还请自行查找方法，此处略过。对PCNTL扩展有了初步的认识后，我们先来编写一个多进程的demo任务练练手，熟悉一下该扩展中核心函数pcntl_fork的使用场景及方法示例1：简易demo ?&amp;lt;?phpprint &quot;I'm in the Main process!\n&quot;;&amp;nbsp;// 当前进程：主进程$pid = pcntl_fork();// pcntl_fork()被执行后，系统会立即创建子进程，而且子进程的执行入口为紧跟在pcntl_fork()之后的代码，与主进程即将执行的代码一致print &quot;Who am I ?\n&quot;;&amp;nbsp;// 此时需要一种机制或约定来让编程人员判断当前代码执行的环境为主进程中or子进程中if ($pid === -1) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;Fork child process faield, exit!\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(1);} elseif ($pid === 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;I'm in the child process!\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;Child process exit.\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(0);} elseif ($pid &amp;gt; 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;I'm still in the main process!\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print &quot;Main process exit.\n&quot;;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(0);} 上面那段代码的输出会是什么样子呢？运行结果 expand source?[root@1d42e4522359 tmp]# php test.phpI'm in the Main process!Who am I ?I'm still in the main process!Main process exit.Who am I ?I'm in the child process!Child process exit. 从上面的示例代码中可以看出：不同于多线程中只会被新线程执行的特定代码块，多进程代码在被执行时，父进程与子进程几乎共用同一份代码，即pcntl_fork()之后的代码由于子进程被创建之后，父进程与子进程就相当于两个独立的进程，二者共用pcntl_fork()之后的代码，而且执行顺序没有保证，所以需要通过pcntl_fork()函数的返回值来判断当前进程所属父/子进程，以便通过if-else判断为父/子进程预设置不同的执行代码。pcntl_fork()函数的返回值$pid有三种情况：$pid = -1: 子进程创建失败，通常情况下子进程创建失败，程序都会记录原因后主动退出$pid &amp;gt; 0: 子进程创建成功。当前进程为父进程，其中$pid的值即为刚创建成功的子进程的进程id$pid = 0: 子进程创建成功。当前进程为子进程示例2：实际应用场景初探下面我们来编写一例有实际应用场景的例子：父进程创建2个子进程，每个子进程的工作内容相同：从主进程分配给自己的网址中抓取网页的标题字段并打印出来，然后退出程序。父进程在sleep几秒（其实是在等待子程序执行完并主动退出）后也退出程序。 ?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&amp;lt;?php&amp;nbsp;function printLine($msg) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;print $msg . &quot;\n&quot;;}&amp;nbsp;function get_url_title($url) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$content = file_get_contents($url);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$match_arr = NULL;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ($content) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;preg_match('/&amp;lt;title&amp;gt;(.+?)&amp;lt;\/title&amp;gt;/', $content, $match_arr);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ($match_arr &amp;amp;&amp;amp; count($match_arr) === 2) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return $match_arr[1];&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return NULL;}&amp;nbsp;printLine('Task begin.');&amp;nbsp;$site_urls = array(&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'https://www.beibei.com',&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;'https://www.jd.com',);&amp;nbsp;&amp;nbsp;foreach($site_urls as $_url) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;$pid = pcntl_fork();&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if ($pid === -1) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;Fork child process faield, exit!&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(1);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} elseif ($pid === 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;In the child process!&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine($_url . ' title =&amp;gt; ' . get_url_title($_url));&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;Child process exit.&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;exit(0);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;} elseif ($pid &amp;gt; 0) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;printLine(&quot;In the parent process, do nothing.&quot;);&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;}}&amp;nbsp;$i = 7;while ($i--) {&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sleep(1);}printLine(&quot;Task end.&quot;); 运行结果 expand source?[root@1d42e4522359 beibei]# php testpcntl.phpTask begin.In the parent process, do nothing.In the child process!In the parent process, do nothing.In the child process!https://www.beibei.com title =&amp;gt; 贝贝网-买母婴上贝贝！1亿妈妈信赖的母婴正品特卖商城Child process exit.https://www.jd.com title =&amp;gt; 京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！Child process exit.Task end. 从上面的执行结果中我们又可以总结出PCNTL扩展函数的几个特点：1）子进程可以使用（继承了）父进程Context中的变量（如$_url）以及函数（如get_url_title()方法）2）如果移除父进程最后的sleep代码你会发现，子进程在父进程退出后依然可以正常运行，并不会随主进程的退出而退出PCNTL扩展进阶使用子进程的管理（监控/终止子进程）在实际的任务框架编写中，开发者通常会首先创建一个master进程，然后再由master进程创建N个子进程。其中每个子进程作为工作进程（worker process）进行实际的业务处理，master进程作为管理者，主要负责工作进程的调度、监管、维护、回收等内容。到了某个具体业务处理的场景下，对应业务的开发者仅需要完成自己业务逻辑部分，并将其作为工作进程的一部分，即可快速嵌入到整体的任务框架中去。在这种任务框架模式下，master进程对子进程的监控及控制能力就显得尤为重要了。那么如何借用PCNTL扩展的函数接口对子进程进行监管与控制呢？对子进程的监控，主要分两个方面：1）需要记录每个子进程的进程ID；2）可以通过子进程的进程ID获取子进程的运行状态（是否已结束、是否为僵尸进程）对子进程的控制，主要是指：可以通过子进程的进程ID获取其运行状态，并可以停止或中断其运行。获取子进程运行状态，需要用到函数pcntl_waitpid(int $pid, int &amp;amp;$status, int $options = 0)。本函数依赖于Linux系统的waitpid(2)函数的实现，作用为：阻断当前进程直到给定$pid的子进程退出（当遇到系统信号需要终止运行或调用信号处理函数时会转去进行信号处理）。注意该函数默认是阻塞型函数（除非$options设置为WNOHANG），其会根据入参的不同，做出多种可能的处理和返回（不过由于当前进程通常都为管理子进程的父进程，并非worker进程，所以即便阻塞也没关系）。参数解释：$pid：根据$pid值的范围进行不同的处理：$pid &amp;lt; -1: 等待指定进程组ID下所有子进程的退出。其中进程组ID = abs($pid)，即$pid的绝对值$pid = -1: 等待任意子进程（这里不太清楚，任意是指：用户空间的所有fork出的子进程？）的退出$pid =&amp;nbsp; 0: 等待指定进程组ID下所有子进程的退出。其中进程组ID = 当前进程的进程组ID$pid &amp;gt;&amp;nbsp; 0: 等待进程ID为$pid的子进程退出$status会在调用结束后被赋予子进程的状态信息，对$status结果的判断可以使用以下函数：pcntl_wifexited($status): 判断子进程是否正常退出&amp;nbsp;pcntl_wifstopped($status): 判断子进程是否已停止pcntl_wstopsig($status): 获取导致子进程停止（stop）的信号(signal)，当pcntl_wifstopped返回TRUE时使用pcntl_wifsignaled($status): 判断子进程是否由于某信号而退出pcntl_wtermsig($status): 获取导致子进程终止运行（terminate）的信号（signal），当pcntl_wifsignaled返回TRUE时使用pcntl_wexitstatus($status): 获取已终止子进程的退出值（exit_code）$options: 默认无需设置。但想要使用下面两种值需要系统底层支持。参数使用背景：子进程退出时，内核会保存子进程的退出状态信息，直到父进程来消费这个状态信息，内核保存的状态信息即可释放WNOHANG 作用：如果父进程不想阻塞式获取子进程状态可传入该值，则如果没有子进程退出，本次函数调用会立即return 0WUNTRACED 作用：返回：进程已经stop了，但状态信息未被消费（取走）的子进程$pid@return: 本次函数调用有3中返回结果，他们分别是：result &amp;gt; 0: 返回值为：已退出的子进程的进程IDresult = -1: 函数调用出错result = 0: 当使用WNOHANG选项，并且无子进程退出时会返回0父/子进程的信号处理任务（进程）的后台执行未完待续...附录：通用PHP任务框架流程图通用PHP任务框架流程图：PHP多进程任务流程图.svg</summary></entry><entry><title type="html">跨域请求那些事</title><link href="http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B.html" rel="alternate" type="text/html" title="跨域请求那些事" /><published>2018-03-15T00:00:00+08:00</published><updated>2018-03-15T00:00:00+08:00</updated><id>http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B</id><content type="html" xml:base="http://localhost:4000/2018/03/15/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E9%82%A3%E4%BA%9B%E4%BA%8B.html">&lt;div class=&quot;wiki-content&quot;&gt;
    &lt;h2 id=&quot;id-跨域请求那些事-何为跨域请求Cross-originresourcesharing&quot;&gt;何为跨域请求(Cross-origin resource sharing)&lt;/h2&gt;
    &lt;p&gt;在网页浏览器中，当属于站点A的网页试图访问位于站点B上的某一资源&lt;span&gt;时&lt;/span&gt;（如图片、CSS、JS文件、指定URL的接口数据），这个请求就属于&lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-origin_resource_sharing&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;跨域请求&lt;/a&gt;了。&lt;/p&gt;
    &lt;p&gt;通常情况下，站点A上的网页可以访问位于站点B上的图片、视频、CSS、JS等资源，但当站点A的网页向位于站点B的HTTP接口发送Ajax请求时，浏览器默认会检查该请求是否合法，意即：只有当站点B主动返回允许站点A访问该HTTP接口的许可信息时，站点A本次的Ajax请求才会被实际发送。从这一点可以看出，跨域请求的安全限制，实际是由浏览器保证并执行的。&lt;/p&gt;
    &lt;p&gt;浏览器对跨域的Ajax请求的处理流程图如下（资源来自维基百科&amp;nbsp;&lt;a href=&quot;/download/attachments/95368284/Flowchart_showing_Simple_and_Preflight_XHR.svg?version=1&amp;amp;modificationDate=1522826629000&quot;&gt;Flowchart_showing_Simple_and_Preflight_XHR.svg&lt;/a&gt;&amp;nbsp;）&lt;br /&gt;&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-content-image-border&quot; width=&quot;800&quot; src=&quot;http://wx3.sinaimg.cn/large/6480dca9gy1fqc75j79ddj21kw0tqq95.jpg&quot; data-image-src=&quot;/download/attachments/95368284/image2018-4-4+14%3A16%3A14.png?version=1&amp;amp;modificationDate=1522826629000&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;从上图中可以看出，一个Ajax请求无论是GET形式还是POST形式，只要包含了特定的内容数据，都会触发浏览器的安全校验，所谓的安全校验是指：浏览器在发起本次请求之前，会对同一URL优先发起一次OPTIONS请求，通过OPTION请求返回的Header信息判定本次的&lt;span&gt;跨域&lt;/span&gt;Ajax请求是否合法，如果合法则请求被发出；否则请求被中止。&lt;/p&gt;
    &lt;p&gt;下方信息是从 hx.test.com 向 www.test.com/&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;api/upload_img.html&amp;nbsp;&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;发起Ajax POST请求时抓取到的、浏览器优先发起OPTIONS请求的关键信息&lt;/span&gt;&lt;/p&gt;
    &lt;div class=&quot;table-wrap&quot;&gt;
        &lt;table class=&quot;confluenceTable&quot;&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;th colspan=&quot;2&quot; class=&quot;confluenceTh&quot;&gt;OPTIONS请求Header关键信息&lt;/th&gt;
                    &lt;th class=&quot;confluenceTh&quot;&gt;说明&lt;/th&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;状态行&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;OPTIONS /api/upload_img.html HTTP/1.1&amp;nbsp;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Host&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;www.test.com&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点B的域名&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Origin&amp;nbsp;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span class=&quot;nolink&quot;&gt;http://hx.test.com/&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点A的网址，跨域请求需携带&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Request-Method&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span&gt;POST&lt;/span&gt;&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;跨域请求需携带的Header&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Request-Headers&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;
                        &lt;p&gt;&lt;span&gt;X-&lt;/span&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;Requested-With&lt;/span&gt;&lt;/p&gt;
                    &lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span&gt;跨域请求需携带的Header&lt;/span&gt;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;highlight confluenceTd&quot; colspan=&quot;2&quot;&gt;&lt;span style=&quot;color: rgb(0,0,0);&quot;&gt;OPTIONS响应Header关键信息&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;highlight confluenceTd&quot; colspan=&quot;1&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;状态行&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;HTTP/1.1 200 OK&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&amp;nbsp;&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Origin&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;&lt;span class=&quot;nolink&quot;&gt;http://hx.test.com/&lt;/span&gt;&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点B允许站点A访问本资源&lt;br /&gt;若站点B设置该Header为 * ，则表示允许任意站点访问该资源&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Headers&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;Origin, X-Requested-With, Content-Type&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点A请求站点B时可携带的Headers&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;Access-Control-Allow-Methods&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;POST, OPTIONS&lt;/span&gt;&lt;/td&gt;
                    &lt;td class=&quot;confluenceTd&quot;&gt;站点A请求站点B时可使用的Methods&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;
                        &lt;p&gt;Access-Control-Allow-Credentials&lt;/p&gt;
                    &lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;true&lt;/td&gt;
                    &lt;td colspan=&quot;1&quot; class=&quot;confluenceTd&quot;&gt;站点A请求站点B时，可携带站点B的Cookies&lt;br /&gt;若站点B未返回该Header，或将其设置为false，则站点A请求站点B不会携带站点B的Cookies）&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/div&gt;
    &lt;p&gt;综上可知，浏览器实现了W3C定义的安全约定，在站点跨域请求资源时，如果是Ajax请求并且请求的Header或Body中包含了触发安全校验的内容，则浏览器会优先发起（pre-flight）OPTIONS请求向目标站点询问：是否接受站点A的Ajax请求，以及可接受的请求内容（包括限定的Methods、Headers等）。最后再由浏览器检查核对后决定，允许并发起请求，或者，中止本次请求。&lt;/p&gt;
    &lt;p&gt;关于触发浏览器&lt;span&gt;安全校验（pre-flight）的条件详情，请参考火狐开发者文档：&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;h2 id=&quot;id-跨域请求那些事-如何界定请求跨域了&quot;&gt;如何界定请求跨域了&lt;/h2&gt;
        &lt;p&gt;假如站点A的网页为：http://www.test.com ，请看下方界定请求跨域的例子&lt;/p&gt;
        &lt;div class=&quot;table-wrap&quot;&gt;
            &lt;table class=&quot;confluenceTable&quot;&gt;
                &lt;colgroup&gt;
                    &lt;col /&gt;
                    &lt;col /&gt;
                    &lt;col /&gt; &lt;/colgroup&gt;
                &lt;tbody&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;站点B列表&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;是否跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;原因&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com/dir/page2.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com/dir/page2.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;未跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com/dir2/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;未跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://username:password@www.test.com/dir2/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://username:password@www.test.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;未跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol, host and port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com:81/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com:81/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;已跨域&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Same protocol and host but different port&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;https://www.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;https://www.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different protocol&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://en.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://en.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host (exact match required)&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://v2.www.test.com/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://v2.www.test.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;span&gt;已跨域&lt;/span&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Different host (exact match required)&lt;/td&gt;
                    &lt;/tr&gt;
                    &lt;tr&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;&lt;a href=&quot;http://www.test.com:80/dir/other.html&quot; class=&quot;external-link&quot; rel=&quot;nofollow&quot;&gt;http://www.test.com:80/dir/other.html&lt;/a&gt;&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;看浏览器实现&lt;/td&gt;
                        &lt;td class=&quot;confluenceTd&quot;&gt;Port explicit. Depends on implementation in browser&lt;/td&gt;
                    &lt;/tr&gt;
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
        &lt;h2 id=&quot;id-跨域请求那些事-PHP CodeIgniter框架对于跨域请求的注意点&quot;&gt;PHP CodeIgniter框架对于跨域请求的注意点&lt;/h2&gt;
        &lt;p&gt;随着业务线日益壮大，我也在日常的开发中遇到过几次跨域、跨站点请求（实则都为公司的子业务系统）失败、被阻的情况。&lt;/p&gt;
        &lt;p&gt;当遇到跨域请求失败的情况时，只需在后端代码中添加跨域允许的相关Header键值，即可通过浏览器的检查。&lt;/p&gt;
        &lt;p&gt;除此之外，&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;PHP的CodeIgniter框架还对跨站请求伪造（CSRF）进行了防御，下面针对这种情况做一下说明。&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&lt;span&gt;CSRF的实现逻辑是：&lt;/span&gt;&lt;/p&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;span&gt;1）可信用户A登录了test.com；&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;2）可信用户A访问危险网页或危险邮件，网页或邮件中隐藏着向test.com提交的表单内容（表单内容为普通form，由攻击发起者预先写死格式和内容）；&lt;/span&gt;&lt;/li&gt;
            &lt;li&gt;&lt;span&gt;3）可信用户A被诱导点击了危险网页或邮件中的隐藏的form表单，导致表单内容被用户A提交至test.com，并且表单提交时携带的是可信用户A的可信Cookies&lt;/span&gt;&lt;/li&gt;
        &lt;/ul&gt;
        &lt;div&gt;CodeIgniter对此做出的防御逻辑是：
            &lt;ul&gt;
                &lt;li&gt;1）每一次POST请求之前，客户端应首先发起GET请求拉取可信签名(csrf_defence_sign)并将签名放入Cookie中返回给客户端&lt;/li&gt;
                &lt;li&gt;2）POST数据时，需将可信签名作为表单的一部分同时提交，并由后端校验表单中的可信签名是否有效（具体的校验逻辑为：检查请求Cookie中的可信签名与POST中的可信签名一致，且可信签名有效）&lt;/li&gt;
            &lt;/ul&gt;
            &lt;p&gt;在公司做新的站点业务（testB.com)的时候，它共用了test.com的几乎所有代码，二者只是在域名上有区分，后端代码处理逻辑一模一样。由于需要从testB.com向test.com提交表单信息，此时CodeIgniter后端服务便误以为这些提交是CSRF攻击，因此直接中止了请求。&lt;/p&gt;
        &lt;/div&gt;

        &lt;p&gt;那么&lt;strong style=&quot;&quot;&gt;疑问来了&lt;/strong&gt;&lt;span style=&quot;&quot;&gt;：如果想从testB.com向test.com发送ajax跨域提交，是否可行？看下方流程图可知：由于CodeIgniter框架的CrossSiteRequestForgery检测和拦截在前，应用层设置跨域允许在后，所以结论是不可行。&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&lt;span style=&quot;font-size: 10.0pt;&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; width=&quot;660&quot; src=&quot;http://wx3.sinaimg.cn/large/6480dca9gy1fqc72ghlhuj20ww0lctbc.jpg&quot; /&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;/div&gt;</content><author><name></name></author><summary type="html">何为跨域请求(Cross-origin resource sharing) 在网页浏览器中，当属于站点A的网页试图访问位于站点B上的某一资源时（如图片、CSS、JS文件、指定URL的接口数据），这个请求就属于跨域请求了。 通常情况下，站点A上的网页可以访问位于站点B上的图片、视频、CSS、JS等资源，但当站点A的网页向位于站点B的HTTP接口发送Ajax请求时，浏览器默认会检查该请求是否合法，意即：只有当站点B主动返回允许站点A访问该HTTP接口的许可信息时，站点A本次的Ajax请求才会被实际发送。从这一点可以看出，跨域请求的安全限制，实际是由浏览器保证并执行的。 浏览器对跨域的Ajax请求的处理流程图如下（资源来自维基百科&amp;nbsp;Flowchart_showing_Simple_and_Preflight_XHR.svg&amp;nbsp;） 从上图中可以看出，一个Ajax请求无论是GET形式还是POST形式，只要包含了特定的内容数据，都会触发浏览器的安全校验，所谓的安全校验是指：浏览器在发起本次请求之前，会对同一URL优先发起一次OPTIONS请求，通过OPTION请求返回的Header信息判定本次的跨域Ajax请求是否合法，如果合法则请求被发出；否则请求被中止。 下方信息是从 hx.test.com 向 www.test.com/api/upload_img.html&amp;nbsp;发起Ajax POST请求时抓取到的、浏览器优先发起OPTIONS请求的关键信息 OPTIONS请求Header关键信息 说明 状态行 OPTIONS /api/upload_img.html HTTP/1.1&amp;nbsp; &amp;nbsp; Host www.test.com 站点B的域名 Origin&amp;nbsp; http://hx.test.com/ 站点A的网址，跨域请求需携带 Access-Control-Request-Method POST 跨域请求需携带的Header Access-Control-Request-Headers X-Requested-With 跨域请求需携带的Header OPTIONS响应Header关键信息 &amp;nbsp; 状态行 HTTP/1.1 200 OK &amp;nbsp; Access-Control-Allow-Origin http://hx.test.com/ 站点B允许站点A访问本资源若站点B设置该Header为 * ，则表示允许任意站点访问该资源 Access-Control-Allow-Headers Origin, X-Requested-With, Content-Type 站点A请求站点B时可携带的Headers Access-Control-Allow-Methods POST, OPTIONS 站点A请求站点B时可使用的Methods Access-Control-Allow-Credentials true 站点A请求站点B时，可携带站点B的Cookies若站点B未返回该Header，或将其设置为false，则站点A请求站点B不会携带站点B的Cookies） 综上可知，浏览器实现了W3C定义的安全约定，在站点跨域请求资源时，如果是Ajax请求并且请求的Header或Body中包含了触发安全校验的内容，则浏览器会优先发起（pre-flight）OPTIONS请求向目标站点询问：是否接受站点A的Ajax请求，以及可接受的请求内容（包括限定的Methods、Headers等）。最后再由浏览器检查核对后决定，允许并发起请求，或者，中止本次请求。 关于触发浏览器安全校验（pre-flight）的条件详情，请参考火狐开发者文档：https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests 如何界定请求跨域了 假如站点A的网页为：http://www.test.com ，请看下方界定请求跨域的例子 站点B列表 是否跨域 原因 http://www.test.com/dir/page2.html 未跨域 Same protocol, host and port http://www.test.com/dir2/other.html 未跨域 Same protocol, host and port http://username:password@www.test.com/dir2/other.html 未跨域 Same protocol, host and port http://www.test.com:81/dir/other.html 已跨域 Same protocol and host but different port https://www.test.com/dir/other.html 已跨域 Different protocol http://en.test.com/dir/other.html 已跨域 Different host http://test.com/dir/other.html 已跨域 Different host (exact match required) http://v2.www.test.com/dir/other.html 已跨域 Different host (exact match required) http://www.test.com:80/dir/other.html 看浏览器实现 Port explicit. Depends on implementation in browser PHP CodeIgniter框架对于跨域请求的注意点 随着业务线日益壮大，我也在日常的开发中遇到过几次跨域、跨站点请求（实则都为公司的子业务系统）失败、被阻的情况。 当遇到跨域请求失败的情况时，只需在后端代码中添加跨域允许的相关Header键值，即可通过浏览器的检查。 除此之外，PHP的CodeIgniter框架还对跨站请求伪造（CSRF）进行了防御，下面针对这种情况做一下说明。 CSRF的实现逻辑是： 1）可信用户A登录了test.com； 2）可信用户A访问危险网页或危险邮件，网页或邮件中隐藏着向test.com提交的表单内容（表单内容为普通form，由攻击发起者预先写死格式和内容）； 3）可信用户A被诱导点击了危险网页或邮件中的隐藏的form表单，导致表单内容被用户A提交至test.com，并且表单提交时携带的是可信用户A的可信Cookies CodeIgniter对此做出的防御逻辑是： 1）每一次POST请求之前，客户端应首先发起GET请求拉取可信签名(csrf_defence_sign)并将签名放入Cookie中返回给客户端 2）POST数据时，需将可信签名作为表单的一部分同时提交，并由后端校验表单中的可信签名是否有效（具体的校验逻辑为：检查请求Cookie中的可信签名与POST中的可信签名一致，且可信签名有效） 在公司做新的站点业务（testB.com)的时候，它共用了test.com的几乎所有代码，二者只是在域名上有区分，后端代码处理逻辑一模一样。由于需要从testB.com向test.com提交表单信息，此时CodeIgniter后端服务便误以为这些提交是CSRF攻击，因此直接中止了请求。</summary></entry><entry><title type="html">PHP对象stdClass如何判断是否为空</title><link href="http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html" rel="alternate" type="text/html" title="PHP对象stdClass如何判断是否为空" /><published>2018-02-01T00:00:00+08:00</published><updated>2018-02-01T00:00:00+08:00</updated><id>http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA</id><content type="html" xml:base="http://localhost:4000/2018/02/01/PHP%E5%AF%B9%E8%B1%A1stdClass%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA.html">&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;先来看下普通的为空判断，应用于stdClass类是什么表现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

if (!$obj) {
    echo '!(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo '!(obj) = FALSE' . &quot;\n&quot;;
}

if (empty($obj)) {
    echo 'empty(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo 'empty(obj) = FALSE' . &quot;\n&quot;;
}

if (is_null($obj)) {
    echo 'is_null(obj) = TRUE' . &quot;\n&quot;;
} else {
    echo 'is_null(obj) = FALSE' . &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出结果（请先自己预测下？）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;!(obj) = FALSE

empty(obj) = FALSE

is_null(obj) = FALSE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;不过在我接触过的各个语言中（Java、Python、Javascript），所有常规对象在进行布尔判断时都不为空，也算是符合业界通用的规则标准了&lt;/p&gt;

&lt;p&gt;那么想要判断一个stdClass是否为空时，应该使用什么方法呢？
业界通用的做法是：将stcClass转换（cast）为数组，再对数组进行判空操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

$obj_arr = (array) $obj;

if (!$obj_arr) { 
    echo 'bool judge false' . &quot;\n&quot;;
} else {
    echo 'bool judge true' . &quot;\n&quot;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当然还有人提出这样的想法：使用get_object_vars方法获取这个对象的类属性，通过判断其返回值来间接进行判空的操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

$obj_attr_arr = get_object_vars($obj);

if (!$obj_attr_arr) {
    echo 'bool judge false' . &quot;\n&quot;;
} else {
    echo 'bool judge true' . &quot;\n&quot;;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那么这两种判空方式孰优孰劣呢？我对这两种方法分别执行500万次后发现&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法一（转为array）执行500万次耗时仅为0.8s左右；&lt;/li&gt;
  &lt;li&gt;方法二在执行同样次数后，耗时达到了惊人的17.8s左右&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此我们发现，通过将对象转为array以便间接判断stdClass是否为空是更高效的做法&lt;/p&gt;

&lt;h2 id=&quot;进阶&quot;&gt;进阶&lt;/h2&gt;
&lt;p&gt;当然，上面两种判断方法都是在：stdClass确实为空对象这一前提下进行的，那么如果stdClass是一个具有200个类属性的方法时，二者执行效率孰优孰劣？&lt;/p&gt;

&lt;p&gt;我们先来创建一个有200个类属性的对象&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$obj = new stdClass();

for ($i = 0; $i &amp;lt; 200; $i++) {
    $attr = &quot;{$i}rand{$i}&quot;;
    $obj-&amp;gt;$attr = $i;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;再分别使用方式一和方式二对这个对象进行判空操作，对这两种方法分别执行500万次后发现：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;方法一（转为array）执行500万次耗时仍然维持在0.8s左右；&lt;/li&gt;
  &lt;li&gt;方法二在执行同样次数后，耗时比之前增加了5s，达到了23.45s&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;通过将对象转为array以间接判断stdClass是否为空，是更高效的做法&lt;/p&gt;</content><author><name></name></author><category term="Tech" /><summary type="html">背景 先来看下普通的为空判断，应用于stdClass类是什么表现：</summary></entry><entry><title type="html">xdebug远程调试原理与实践</title><link href="http://localhost:4000/2018/01/10/xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5.html" rel="alternate" type="text/html" title="xdebug远程调试原理与实践" /><published>2018-01-10T00:00:00+08:00</published><updated>2018-01-10T00:00:00+08:00</updated><id>http://localhost:4000/2018/01/10/xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5</id><content type="html" xml:base="http://localhost:4000/2018/01/10/xdebug%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5.html">&lt;div class=&quot;wiki-content&quot;&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-1前言&quot;&gt;1. 前言&lt;/h2&gt;
    &lt;p&gt;&lt;span&gt;世界上有两种人：一种了解debug工具的好处，另一种则反之。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;那么debug工具到底有哪些优点呢？&lt;/span&gt;&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;1）在日常开发中洞悉大型架构的流程及设计；&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;2）在日常开发中快速debug，省时省力，&lt;span&gt;更能在debug过程中掌握程序运行流程及上下文&lt;/span&gt;；&lt;/p&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;p class=&quot;p1&quot;&gt;3）&lt;strong&gt;debug驱动型开发习惯的养成&lt;/strong&gt;&lt;/p&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;span&gt;在PHP语言中有个叫&lt;/span&gt;&lt;code&gt;xdebug&lt;/code&gt;&lt;span&gt;的扩展，是业界最常用的PHP debug工具之一。xdebug有很多实用的特性，但本文只着重介绍&lt;/span&gt;&lt;em&gt;远程调试&lt;/em&gt;&lt;span&gt;这一特性的使用。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;注意：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;本文提到的IDE，意即：集成开发环境，例如PHPStrom、Eclipse就是很常见的IDE&lt;/li&gt;
        &lt;li&gt;PHPStrom和IDE在本文中可能会被混用，但他们都代表PHPStrom&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-2xdebug特性&quot;&gt;2. xdebug特性&lt;/h2&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;var_dump展示优化&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fdisplay&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;PHP输出notice、error等信息时，调用栈可定制化展示&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fstack_trace&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;函数调用报告&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fexecution_trace&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;代码覆盖率报告&amp;nbsp;&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fcode_coverage&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;程序分析报告（profiler）&lt;a href=&quot;https://link.jianshu.com/?t=https%3A%2F%2Fxdebug.org%2Fdocs%2Fprofiler&quot; rel=&quot;nofollow&quot; class=&quot;external-link&quot;&gt;&amp;gt;link&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;远程调试。&lt;/strong&gt;本篇内容将着重介绍这一功能。如果你想获取有关如何配置可多人同时调试一台Web服务器的DBGp代理信息的话，也推荐你读完本文，这将对你后续的代理配置有一定帮助。&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2 id=&quot;xdebug调试原理与实践-3远程调试&quot;&gt;3. 远程调试&lt;/h2&gt;
    &lt;p&gt;xdebug的远程调试默认的通信协议为&lt;span&gt;&lt;strong&gt;DBGp协议&lt;/strong&gt;，它是基于XML文本传输的应用层协议，用于程序语言与IDE间的调试通信。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;DBGP协议规定：IDE向程序的调试器发送的内容为ascii命令，调试器向IDE发送的内容为XML数据&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;600&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fqc818gm2ij20rc09m74y.jpg&quot; /&gt;&lt;/span&gt;&lt;/p&gt;

    &lt;p&gt;以下为基于DBGp协议进行debug的通信伪内容的示例。其中&quot;DBG&quot;是指程序调试器(比如xdebug)；&quot;IDE:&quot;是指IDE向DBG(xdebug)发送消息&quot;；&quot;DBG:&quot;是指DBG(xdebug)向IDE响应消息&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;IDE:  feature_get supports_async
DBG:  yes
IDE:  breakpoint_set file_path,file_line_no
DBG:  ok
IDE:  stdin redirect
DBG:  ok
IDE:  stderr redirect
DBG:  ok
IDE:  run
DBG:  stdin data...
DBG:  stdin data...
DBG:  reached breakpoint, pause running
IDE:  get context variables
DBG:  ok, here they are
IDE:  evaluate this expression
DBG:  stderr data...
DBG:  ok, done
IDE:  stop
DBG:  good bye&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;&lt;span&gt;由于DBGp协议是明文传输的，所以只需监听IDE的9000端口（IDE用于调试通信的端口）上的TCP通信，你便能一窥它的详细通信内容。如下方所示为局部通信内容截图。&lt;/span&gt;其中：172.17.0.2为Web服务器的IP，192.168.65.2是IDE所在开发机上的IP。&lt;/p&gt;

    &lt;p&gt;&lt;span&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;900&quot; src=&quot;http://wx2.sinaimg.cn/large/6480dca9gy1fqc9m6lht5j21i60zgk9b.jpg&quot; /&gt;&lt;/span&gt;&lt;/p&gt;
    
    &lt;p&gt;&lt;span style=&quot;color: rgb(0,0,0);font-size: 1.4em;font-weight: bold;&quot;&gt;3.1 xdebug调试(session)的生命周期&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;断点调试是有生命周期的。断点调试始于：手动或自动开启调试session，终止于：手动终止程序或程序自动运行退出。下方为xdebug的session状态流转图：&lt;/p&gt;
    &lt;p&gt;&lt;img class=&quot;confluence-embedded-image&quot; width=&quot;555&quot; src=&quot;http://wx4.sinaimg.cn/large/6480dca9gy1fqc9thzsg4j20ho0m60u3.jpg&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;span&gt;xdebug调试的开始有以下两种方式&lt;/span&gt;&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-311外部触发xdebug启动调试&quot;&gt;3.1.1 外部触发xdebug启动调试&lt;/h4&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;请求的GET、POST的query中包含&lt;code&gt;XDEBUG_SESSION_START=sessName&lt;/code&gt;参数即可启动xdebug调试&lt;/li&gt;
        &lt;li&gt;Cookie中包含&lt;code&gt;XDEBUG_SESSION=sessName&lt;/code&gt;即可启动xdebug调试&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-312xdebug始终自启动调试（推荐使用）&quot;&gt;3.1.2 xdebug始终自启动调试（推荐使用）&lt;/h4&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;配置文件中设置&lt;code&gt;xdebug.remote_autostart=1&lt;/code&gt;，则PHP每次执行脚本都会启动xdebug调试（&lt;b&gt;没错，在命令行直接运行任务脚本也会启动调试&lt;/b&gt;）&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3 id=&quot;xdebug调试原理与实践-32xdebug主动连接IDE的两种方式&quot;&gt;3.2 xdebug主动连接IDE的两种方式&lt;/h3&gt;
    &lt;p&gt;xdebug的DBGp协议的第一步，是自xdebug启动调试session后，根据给定配置，主动连接IDE。在网上的相关教程中，我们往往会看到各式各样的xdebug.remote_host相关的配置，&lt;br /&gt;那么这些配置到底是起了什么作用呢？&lt;/p&gt;
    &lt;p&gt;这里就要讲到xdebug主动连接IDE的两种不同方式了，因为xdebug.remote_host相关的配置就是为了让xdebug可以连接到IDE的9000端口上。&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-321方式一：根据客户端请求IP连接IDE设置xdebugremoteconnectback1&quot;&gt;3.2.1 方式一：根据客户端请求IP连接IDE(设置&lt;code&gt;xdebug.remote_connect_back=1&lt;/code&gt;)&lt;/h4&gt;
    &lt;p&gt;xdebug连接IDE的方式一的时序图如下：&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-fafc337cf5d14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-fafc337cf5d14ecc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;说明：&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;开发者发起URL请求后，xdebug通过解析&lt;code&gt;$_SERVER&lt;/code&gt;map中的&lt;code&gt;HTTP_X_FORWARDED_FOR&lt;/code&gt;和&lt;code&gt;REMOTE_ADDR&lt;/code&gt;字段获取开发者所在的IP地址&lt;/li&gt;
        &lt;li&gt;xdebug获取到开发者IP地址后，通过IP及IDE暴露的9000接口，与IDE建立连接，并进行后续通信&lt;/li&gt;
        &lt;li&gt;发起URL请求的机器与IDE必须属于同一IP(即同一台机器)&lt;/li&gt;
        &lt;li&gt;本方式适合IP变化频繁，或多个开发者共享同一台Web服务器等情况的使用&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-322方式二：根据指定IP连接IDE设置xdebugremotehostxxxx&quot;&gt;3.2.2方式二：根据指定IP连接IDE(设置&lt;code&gt;xdebug.remote_host=x.x.x.x&lt;/code&gt;)&lt;/h4&gt;
    &lt;p&gt;xdebug连接IDE的方式二的时序图如下：&lt;br /&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-f961516c23507d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-f961516c23507d6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;说明：&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;以上两种连接方式，方式一优先级高于方式二。如下方配置所示，第二行配置将被忽略：&lt;br /&gt;xdebug.remote_connect_back = 1 &lt;br /&gt;xdebug.remote_host = x.x.x.x&amp;nbsp;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;如需使用方式二（固定IP），需将&lt;code&gt;xdebug.remote_connect_back&lt;/code&gt;置为0&lt;/li&gt;
        &lt;li&gt;第二种连接方式，适合开发机IP基本不变的开发者使用&lt;/li&gt;
    &lt;/ul&gt;
    &lt;h3 id=&quot;xdebug调试原理与实践-33PHPStrom配置xdebug调试&quot;&gt;3.3 PHPStrom配置xdebug调试&lt;/h3&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-331方式一（xdebugremoteconnectback1）的配置&quot;&gt;3.3.1 方式一（xdebug.remote_connect_back = 1）的配置&lt;/h4&gt;
    &lt;p&gt;xdebug.ini中的设置：&lt;/p&gt;
    &lt;pre class=&quot;hljs bash&quot;&gt;&lt;code class=&quot;bash&quot;&gt;zend_extension = xdebug.so &lt;br /&gt;&lt;/code&gt;xdebug.remote_enable = 1 ;开启远程调试 &lt;br /&gt;xdebug.remote_autostart = 1 ;自动启动调试 &lt;br /&gt;xdebug.remote_mode = req ;通过请求触发调试，另一种方式jit：遇到错误时触发 &lt;br /&gt;xdebug.remote_connect_back = 1 ;使用方式一连接 &lt;br /&gt;xdebug.remote_port = 9000 &lt;br /&gt;xdebug.remote_handler = dbgp ;xdebug与PHPStorm的debug协议 &lt;br /&gt;xdebug.idekey = &lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(42,161,152);&quot;&gt;&quot;PHPSTORM&quot;&lt;/span&gt;&lt;span style=&quot;font-family: Arial , Helvetica , FreeSans , sans-serif;;&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;/pre&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-332方式二（xdebugremotehostxxxx）的配置&quot;&gt;3.3.2 方式二（xdebug.remote_host = x.x.x.x）的配置&lt;/h4&gt;
    &lt;p&gt;xdebug.ini中的设置：&lt;/p&gt;
    &lt;pre class=&quot;hljs bash&quot;&gt;&lt;code class=&quot;bash&quot;&gt;zend_extension=xdebug.so &lt;br /&gt;xdebug.remote_enable = 1 &lt;br /&gt;xdebug.remote_autostart = 1 &lt;br /&gt;xdebug.remote_mode = req &lt;br /&gt;xdebug.remote_connect_back = 0 ;关闭方式一连接 &lt;br /&gt;xdebug.remote_host = 192.168.35.103 ;使用方式二连接 &lt;br /&gt;xdebug.remote_port = 9000 &lt;br /&gt;xdebug.remote_handler = dbgp &lt;br /&gt;xdebug.idekey = &lt;span class=&quot;hljs-string&quot; style=&quot;color: rgb(42,161,152);&quot;&gt;&quot;PHPSTORM&quot;&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;
    
    &lt;h4&gt;3.3.3 设置未生效？问题排查&lt;/h4&gt;
    
    &lt;p&gt;有时我们已经按照教程设置好了一切，但打开IDE的断点调试，仍然没有任何效果。&lt;/p&gt;
    &lt;p&gt;我们会疑惑，程序为什么没有在运行到断点后暂停下来？&lt;span&gt;除了检查各种配置是否正确，开发者还有哪些工具、信息可以拿来推断到底是哪一部分出了问题？&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;其实知道了上述连接原理后，我们可以通过TCP工具监听9000端口上的网络通信，通过通信的内容，我们可以把问题细化到由于以下原因，导致的xdebug调试未生效，进而逐个解决问题：&lt;/p&gt;
    &lt;ul&gt;
        &lt;li&gt;9000端口的网络连接并未发起，则推断是xdebug端的配置有问题，有可能是：1）xdebug设置有误；2）xdebug扩展未加载；3）PHP-fpm未启动；4）Nginx未启动&lt;/li&gt;
        &lt;li&gt;9000端口上发生了网络连接，但很快断掉了。有可能是：1）IDE的debug工具并未开启导致IDE的&lt;span&gt;9000&lt;/span&gt;端口不可用；2）IDE的端口设置不是9000；3）Web服务器并不能与IDE所在网络的指定端口通信&lt;/li&gt;
        &lt;li&gt;9000端口上发生了密密麻麻的网络通信。。。额，这个应该是IDE没有打断点吧？&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;&lt;span&gt;在这之前，我们需要打开IDE的debug开关，在代码入口第一行打上断点，然后&lt;/span&gt;&lt;span&gt;SSH进入Web服务器所在机器（通常是虚拟机，或docker容器），通过&lt;/span&gt;&lt;code&gt;tcpdump&lt;/code&gt;&lt;span&gt;工具进行问题排查。&lt;br /&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;tcpdump是TCP层通信的监听工具，由于DBGp协议是建立在TCP之上的应用层协议，所以可以通过更底层的工具监听DBGp协议的通信，上方截图中的DBGp协议局部通信内容，就是用tcpdump工具抓取的。&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;&lt;span&gt;由于tcpdump一次只能监听一个网卡上的网络通信，所以需要通过&lt;/span&gt;&lt;code&gt;ifconfig&lt;/code&gt;&lt;span&gt;命令获取Web服务器的IP经由的网卡&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;通过&lt;code&gt;ifconfig&lt;/code&gt;命令可以确定Web服务器的IP经由的网卡为&lt;code&gt;eth1&lt;/code&gt;。下面开始debug环节&lt;/p&gt;
    &lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
        &lt;div class=&quot;image-container&quot;&gt;
            &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-403848534eb9bb18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-403848534eb9bb18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;p&gt;&amp;nbsp;&lt;/p&gt;
    &lt;h4 id=&quot;xdebug调试原理与实践-333深度自检：在PHPStrom中入口代码第一行打断点，为什么代码未在断点处暂停&quot;&gt;3.3.4 深度自检：在PHPStrom中入口代码第一行打断点，为什么代码未在断点处暂停&lt;/h4&gt;
    &lt;p&gt;这种情况是大部分新手和新安装xdebu后的开发者会遇到的问题。遇到这种问题，该如何排查呢？&lt;/p&gt;
    &lt;p&gt;1）确定xdebug是否向PHPStrom发起网络连接。如果没有，则需要依次检查xdebug的设置是否正确。&lt;/p&gt;
    &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
        &lt;li&gt;在Web服务器命令行输入如下命令（注意网卡名称eth1应情况而异），开始监听xdebug在9000端口上的通信：&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;&lt;/li&gt;
        &lt;li&gt;输入上述命令后，在开发机中访问URL，然后回到Web服务器命令行，查看是否有网络请求发起。如果命令行没有任何输出，则说明xdebug配置有误。请开始&lt;b&gt;步骤A自检&lt;/b&gt;：&lt;br /&gt;
            &lt;ul style=&quot;margin-left: 22.0px;&quot;&gt;
                &lt;li&gt;xdebug扩展是否加载？在&lt;code&gt;phpinfo()&lt;/code&gt;中查看即可确定&lt;/li&gt;
                &lt;li&gt;xdebug设置是否按上方给出的两份设置正确填写？在&lt;code&gt;phpinfo()&lt;/code&gt;中也可以看到这些信息，请查看每项设置是否有多余字符出现？&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;2）在完成&lt;b&gt;步骤A自检&lt;/b&gt;后，重复1的操作，继续监听&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;。命令行输出结果如下图所示。其中&lt;span&gt;192.168.33.10&lt;/span&gt;的机器为Web服务器，&lt;span&gt;192.168.33.1&lt;/span&gt;的机器为IDE所在开发机，从图中信息可以看出Web服务器主动向开发机上的9000端口发起连接请求，但开发机拒绝了该连接请求（&lt;code&gt;Flags [R.]&lt;/code&gt;)&lt;/p&gt;
    &lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
        &lt;div class=&quot;image-container&quot;&gt;
            &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-5893f92aae47e33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-5893f92aae47e33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;遇到这种情况，请开始&lt;/span&gt;&lt;b&gt;步骤B自检&lt;/b&gt;：&lt;/p&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;&amp;nbsp;&lt;/span&gt;&lt;code&gt;curl -v &lt;a rel=&quot;nofollow&quot;&gt;telnet://192.168.33.1:9000&lt;/a&gt;&lt;/code&gt;&lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;。如果返回结果有&lt;/span&gt;&lt;em&gt;couldn't connect to host&lt;/em&gt;
        &lt;span style=&quot;color: rgb(47,47,47);&quot;&gt;，则说明xdebug并不能使用给定IP端口与IDE通信。&lt;br /&gt;造成这的原因可能有：网络不可达（是否能ping通，如无法ping通，请换用其他可ping通的开发机IP，毕竟一个开发机可能有多个IP，最后使用方式二固定IP设置即可）；&lt;br /&gt;IDE端口设置并不是9000；&lt;br /&gt;或者IDE并未打开调试模式，如何打开请看下图&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-72da0495368975aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-72da0495368975aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/488&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;3）步骤B自检查完成后，再次在Web服务器命令行监听9000端口的通信：&lt;code&gt;tcpdump -i eth1 -nn -A -tttt port 9000&lt;/code&gt;。这一次，大量的连接信息开始输出，恭喜你，xdebug已经设置好了&lt;/p&gt;
&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-f57169afc6c70fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; data-image-src=&quot;https://upload-images.jianshu.io/upload_images/4111-f57169afc6c70fb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&amp;nbsp;&lt;/p&gt;
&lt;p&gt;4）PHPStrom中接收到xdebug的网络连接后，如何设置与WebServer上代码的一一匹配&lt;/p&gt;

&lt;div class=&quot;image-package&quot; style=&quot;text-align: center;&quot;&gt;
    &lt;div class=&quot;image-container&quot;&gt;
        &lt;div class=&quot;image-view&quot;&gt;&lt;img class=&quot;confluence-embedded-image confluence-external-resource&quot; src=&quot;https://upload-images.jianshu.io/upload_images/4111-0c8d5d9828b0fca8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700&quot; /&gt;&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;总结：&lt;/b&gt;遇到xdebug设置相关的问题，最重要的是了解debug底层通信协议和原理，再通过TCP/IP抓包工具(比如tcpdump）进行问题排查及定位。通过上述步骤的排查，应该可以定位无法debug原因，并最终成功使用xdebug调试代码了。祝顺利~&lt;/p&gt;

&lt;/div&gt;</content><author><name></name></author><summary type="html">1. 前言 世界上有两种人：一种了解debug工具的好处，另一种则反之。 那么debug工具到底有哪些优点呢？ 1）在日常开发中洞悉大型架构的流程及设计； 2）在日常开发中快速debug，省时省力，更能在debug过程中掌握程序运行流程及上下文； 3）debug驱动型开发习惯的养成 在PHP语言中有个叫xdebug的扩展，是业界最常用的PHP debug工具之一。xdebug有很多实用的特性，但本文只着重介绍远程调试这一特性的使用。 注意： 本文提到的IDE，意即：集成开发环境，例如PHPStrom、Eclipse就是很常见的IDE PHPStrom和IDE在本文中可能会被混用，但他们都代表PHPStrom 2. xdebug特性 var_dump展示优化&amp;nbsp;&amp;gt;link PHP输出notice、error等信息时，调用栈可定制化展示&amp;nbsp;&amp;gt;link 函数调用报告&amp;nbsp;&amp;gt;link 代码覆盖率报告&amp;nbsp;&amp;gt;link 程序分析报告（profiler）&amp;gt;link 远程调试。本篇内容将着重介绍这一功能。如果你想获取有关如何配置可多人同时调试一台Web服务器的DBGp代理信息的话，也推荐你读完本文，这将对你后续的代理配置有一定帮助。 3. 远程调试 xdebug的远程调试默认的通信协议为DBGp协议，它是基于XML文本传输的应用层协议，用于程序语言与IDE间的调试通信。 DBGP协议规定：IDE向程序的调试器发送的内容为ascii命令，调试器向IDE发送的内容为XML数据</summary></entry><entry><title type="html">轻文本编辑器 vs 重型IDE</title><link href="http://localhost:4000/2017/10/10/%E8%BD%BB%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8_vs_%E9%87%8D%E5%9E%8BIDE.html" rel="alternate" type="text/html" title="轻文本编辑器 vs 重型IDE" /><published>2017-10-10T00:00:00+08:00</published><updated>2017-10-10T00:00:00+08:00</updated><id>http://localhost:4000/2017/10/10/%E8%BD%BB%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8_vs_%E9%87%8D%E5%9E%8BIDE</id><content type="html" xml:base="http://localhost:4000/2017/10/10/%E8%BD%BB%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8_vs_%E9%87%8D%E5%9E%8BIDE.html">&lt;blockquote&gt;
  &lt;p&gt;注：本文所说的重型IDE，例如开发PHP用到的PHPStorm、开发Java用到的Eclipse等IDE，有别于类似Sublime Text这样的轻型文本编辑器&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在刚开始学习和使用PHP，乃至在学习和使用python、js的时候，我都在使用Sublime Text(以下简称SbText)进行编码工作。相较于每次打开重型IDE时”漫长”的等待时间，SbText一类编辑器却可以做到秒开！
于是新手便会有一个错觉，以为同样的工作量，使用重型IDE会花费更多时间。&lt;/p&gt;

&lt;p&gt;可是后来我自己实践下来的经验是：重型IDE的协同开发效率更高。注意这里提到的一个关键词：协同开发，它指的是团队间的共同开发，有别于独自开发一个项目。&lt;/p&gt;

&lt;p&gt;为什么在协同开发时，重型IDE的效率更高呢？你可能会开始思考：下列的功能明明轻型IDE也是可以支持的啊&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;代码提示及自动补全&lt;/li&gt;
  &lt;li&gt;语法高亮&lt;/li&gt;
  &lt;li&gt;拼写检查&lt;/li&gt;
  &lt;li&gt;代码格式化工具&lt;/li&gt;
  &lt;li&gt;断点调试&lt;/li&gt;
  &lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在一个独立开发者进行项目开发时，上面这些功能貌似已经够用了。但是在协同开发的场景下，重型IDE许多特性是轻型IDE所不具备的：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接口文档自动解析及提示。轻型IDE往往不具备这样的特性，例如：
    &lt;ul&gt;
      &lt;li&gt;想要查看一个接口参数的定义，后者往往要进入到这个文件中的接口位置处才能看到。&lt;/li&gt;
      &lt;li&gt;再者，如果这个接口已经被声明为已废弃或已删除，说明接口开发者不希望外界继续使用本接口了。但轻型IDE是不会提示到的，如果此时开发者恰好是复制的其他部分的代码，就很有可能继续用到这些已经废弃的接口，从而让团队协作的效率变得低下&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;接口调用的动态提示及检测。轻型IDE一般只提供程序语言无关的文本编辑功能，但是涉及到程序语言相关的内容检测时，它的短板便显现出来。你在调用某个对象的某个接口时，下面这些检查会大幅提升你的编码效率：
    &lt;ul&gt;
      &lt;li&gt;这个接口是否存在&lt;/li&gt;
      &lt;li&gt;你调用接口传入的参数类型、参数个数是否正确&lt;/li&gt;
      &lt;li&gt;你所定义的参数的返回值类型是否和接口声明的一致&lt;/li&gt;
      &lt;li&gt;阅读代码时，之前老代码相关的调用是否正确&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;强大且丰富的断点调试功能。我之前在一个技术分享上曾听到这样一种观点：开发项目时如果你连断点调试工具都没有配置好，那么基本可以判断：1) 你的debug效率将会极其低下；2) 你对项目的整体架构的了解将不会有很大增长（大牛请忽略这样一种论断）。轻型IDE的debug功能一般都很精简，此处推荐重型IDE的debug功能&lt;/li&gt;
  &lt;li&gt;阅读代码时的展示一致性。你能看到的IDE为你做出的通用提示、警告，其他开发者也会看到。这一方面会敦促你编写不会让IDE出现烦人提示的代码(一定意义上更规范的代码)，另一方面也督促你，要求其他开发者不要写类似的代码。&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="Tech" /><summary type="html">注：本文所说的重型IDE，例如开发PHP用到的PHPStorm、开发Java用到的Eclipse等IDE，有别于类似Sublime Text这样的轻型文本编辑器</summary></entry><entry><title type="html">写在离职季，记录我的第一份编程工作</title><link href="http://localhost:4000/2015/06/28/what-i-have-learned-from-this-job-now.html" rel="alternate" type="text/html" title="写在离职季，记录我的第一份编程工作" /><published>2015-06-28T00:00:00+08:00</published><updated>2015-06-28T00:00:00+08:00</updated><id>http://localhost:4000/2015/06/28/what-i-have-learned-from-this-job-now</id><content type="html" xml:base="http://localhost:4000/2015/06/28/what-i-have-learned-from-this-job-now.html">&lt;h2 id=&quot;一只编程菜鸟只为找一份编程的工作&quot;&gt;一只编程菜鸟，只为找一份编程的工作&lt;/h2&gt;
&lt;p&gt;13年7月份毕业，听从家里人的安排，去了本省的一家国企工作，直接被派去到东北的项目基地实习。因为会和技术老外讲英语，还和第三方外包人员一起合作调试好了他们承接的电气化自动排水项目的程序，基地领导青睐有加，想把我留在那里。我考虑了一下拒绝了。等工作到12月份的时候，基本已经确定，这份工作不是我想要的。遂瞒着家里人和领导请了一个月的病假，从东北坐了33个小时的火车来到江南，杭州。当时已是冬季，但下火车后仍然觉得“春风拂面”，比起东北让人冻得骨头疼的冷，杭州的天气温和到简直像是春天。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;投靠到朋友那里，开始了投简历、找工作的经历。因为大三才开始自学编程，基础不牢，项目经验少得可怜。找了快一个月的时间，却只有零星的几次线上交流、笔试的机会，offer始终无果。眼看着一个月的假就要耗完，马上就要春节了，工作依然没有着落，心里开始灰心。直到在准备离开杭州的前两天，才终于有了一次面试的机会，这就是目前的这份工作的起点。这是一家小公司，做海外代购的，同时也在做商品聚合平台。聊了一个多小时，人家觉得还不错，遂口头答应了offer。于是终于在离开杭州的那天，收到了这家公司的正式offer。这个offer就像一根救命稻草一般，没有经历过之前的绝望，就根本体会不到这个offer带来的激动和心安：如果找不到工作，就只能回原来的单位上班了，而当初是做了死也要死外边的打算的。&lt;/p&gt;

&lt;p&gt;因为这是收到的唯一一个offer，所以在回去后的第三天就接受了这份工作。所幸可以安安心心地过一个年，年后去上班。&lt;/p&gt;

&lt;h2 id=&quot;初入职场菜鸟快快长大&quot;&gt;初入职场，菜鸟快快长大&lt;/h2&gt;
&lt;p&gt;年后2月份来上班。最开始的工作只是很基础的用PHP索取数据渲染至HTML并输出的过程，还要经常使用Javascript完成前端动态交互。PHP和Javascript之前都没怎么接触过，所以需要一步步学习。&lt;/p&gt;

&lt;p&gt;其实只要使用过函数式编程的语言（如C）便不难发现，PHP语言其实很好入门和进阶。但是Javascript则完全是不一样的逻辑，因为是EventDriven模式的，有着层层的回调和scope，而且代码执行流程也不是从上到下式的。所以在刚开始接触、使用JS的时候一定会遇到奇怪无比的坑。不过当你最终从坑里爬出来的时候，整个世界便又是另一番景象了。在这个过程中花时间学习和阅读Javascript相关的内容和资料的时间比正牌的后端PHP语言还要多，其实刚开始会有疑问，PHP毕竟是热门的后端语言，而JS只是很小众的前端交互助手而已，值得这样投入时间吗？在后来的工作中，以及nodejs火热起来之后我发现这些投入还是非常值得的，因为JS真的是我接触的第一个可以利用客户端的计算资源的语言，因为你用JS写好一个应用之后，剩余的运算执行是在客户端完成的，它使用的完全是客户端的计算资源！&lt;/p&gt;

&lt;p&gt;现在回想一下，在编程工作起步的时候，最对的，也最受益无穷的选择便是坚持使用、查看英文资料。这真的是一个一本万利的事情。当时访问最多的编程问答网站就是Stackoverflow了。也许对一个有一定积累的人来说SO并没有多少更高的价值，但对于像我这样的菜鸟来说，SO简直就是高纯度的知识海洋。很多东西是对比着才能体会到其间的巨大差别的，当我总是查看英文的技术内容时，再回过头来偶尔看一下中文的问答或博客，简直如啖甘蔗：虽然看着内容很多，其实真正“香甜的甘蔗汁”只有那么一丁点，其余大部分全是废渣。&lt;/p&gt;

&lt;p&gt;因为工作压力并不是很大，所以还利用晚上的时间参加了一门&lt;a href=&quot;http://blog.lyfing.co/2014/07/06/using-js-to-build-a-spaceship-floating-in-the-outer-space.html&quot;&gt;Python公开课&lt;/a&gt;的学习，一来可以练习英语（全英语视、听、作业），二来可以在学习编写小游戏的同时练习Python语言。就这样在持续学习了几个月后，自己在Python方面的实践经验也开始多起来。事实证明，很多看似无用、却由兴趣驱使着去做的事情，往往在后来可以大有所用，此事待后面详述。&lt;/p&gt;

&lt;p&gt;日子就这样平淡着过去，转眼已是立夏。这时候公司开始想要做一款浏览器插件(Extension)，主要用来快速采集用户HTML中的产品信息，具体内容为跟用户所见的HTML交互并在用户人工识别页面信息后，友好地提取其中的产品信息，最后以表单的形式提交至我方服务器。这个&lt;a href=&quot;https://chrome.google.com/webstore/detail/%E6%B5%B7%E6%B7%98%E5%AE%9D-v2%E9%9D%9E%E7%9D%BF%E8%8E%AB%E6%80%9D/obnbgneldjmmpgkbnnbiiinijmiclpaa?hl=zh-CN&quot;&gt;扩展&lt;/a&gt;在立项的时候是由另外一个同事负责开发的，但当时我意识到：1) 这是一个极好的了解浏览器API和练习用Javascript做App的机会；2) 那个同事的技术在我看来不足以做出我认为足够酷炫、友好的交互。我便先跟那位同事交流了我想独担这个任务的想法，取得他的同意后我向Boss主动请缨，Boss也欣然答应了。于是我接下了这个任务，开始了为期一个月的JSApp的编写工作。&lt;/p&gt;

&lt;p&gt;JSApp的实现过程中最大的收获之一是接触到设计合理、博大精深的Chrome API。一直以来都以为Chrome只是快、好用而已，从未想到它竟然有如此多分层合理、设计合理的对外接口，简直就像是一个小型的操作系统。俗话说得好，经常使用设计良好的API，人生逼格也会静默升级呢(kidding)。也开始因为开发需要而接触到很多安全方面的issues，例如iFrame和它的父窗口之间只能发消息，但不能访问父窗口内的资源(window scope variables，like window.document)，例如&lt;a href=&quot;/2014/06/28/upload-browser-side-resources-by-using-xhr.html&quot;&gt;跨域访问&lt;/a&gt;限制（虽然ChromeExtension运行空间直接允许跨域访问），例如&lt;a href=&quot;https://developer.chrome.com/apps/contentSecurityPolicy&quot;&gt;content security policy&lt;/a&gt;等。有时候会被这些看似太过苛刻的限制弄得f&lt;strong&gt;&lt;em&gt;这f&lt;/em&gt;&lt;/strong&gt;那的，这时候便会去试着了解一下他们这么做的原因或者好处。一来有助于缓解心中的”仇恨”(kidding)，二来也可以多学些东西。&lt;/p&gt;

&lt;p&gt;JSApp实现过程中另一大收获便是Javascript的应用水平大大提高，开始逐渐喜欢上这门语言（有时候甚至会选择用它来练习算法）。在慢慢熟悉了JS的scope和回调之后，开始将一个个业务逻辑封装到独立的scope中，然后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Publish/Subscribe&lt;/code&gt; Event&amp;amp;Msg-Driven的方式来连通各个scope，并驱动程序执行。这样做的好处有：1) 每个scope变得像是面向对象的类，封装了细节和实现; 2)因为使用消息驱动，所以代码解耦实现起来相对轻松。当然也是有坏处的，消息多了容易串，所以专门建立了一个manifest文件来快速查找、管理、记录这些消息/事件。&lt;/p&gt;

&lt;p&gt;JSApp在完成发布后，Boss大加赞赏。对于一个刚开始只是做后端PHP开发的人员来说，出色地完成前端JSApp的实现也算是超出Boss的预期了。&lt;/p&gt;

&lt;p&gt;Chrome扩展完成后，除了定期的维护升级外，基本就是日常的PHP端的HTML实现的工作分担一些，这样下来算是又闲下来了。我这人一旦闲下来就又开始不安分了。因为我们网站每天也有一万左右的访问量，所以有机会收集用户的请求信息。&lt;/p&gt;

&lt;p&gt;网站后台当时有一个用户实时在线页面，可以查看哪些用户是最近登录的（实时在线只是个噱头，是根据session时间模拟的，毕竟HTTP无状态），也可以看到来自世界各地的用户请求。当时我突然想，要是能把我们客户在世界各地的分步情况实时地在一张平面的世界地图上展示出来，那该有多酷呀。说干就干，我利用业余时间开始做技术积累：用websocket实现服务器与客户端的实时通信，用python搭建websocket服务器，客户端直接使用JS(客户端需要支持websocket功能)；地图使用谷歌的，客户的访问IP转地理位置使用新浪的IPService接口，最后虽然做出来的样子不是很美观、也只能搭着梯子访问，但也算是达成目标了。&lt;/p&gt;

&lt;p&gt;接下来就是公司技术博客的搭建了。因为公司运行的项目也有四年之久了，但却从没有一个比较系统的地方来介绍、讨论公司各个项目的架构、细节，以及服务器运维方面的东西，所以我就利用业余时间在我们公司的内网服务器上搭建了这个博客平台(&lt;a href=&quot;http://ww1.sinaimg.cn/large/6480dca9gw1etmhyd79i8j20k40l6jvv.jpg&quot;&gt;截图&lt;/a&gt;，并邀请同事在上面分享日常的开发维护心得。&lt;/p&gt;

&lt;h2 id=&quot;人事遽变承担半边天&quot;&gt;人事遽变，承担半边天&lt;/h2&gt;

&lt;p&gt;就在我过着按部就班毫无压力的日子的时候，公司却突然发生了三个月内的第二次人事遽变。第一次人事遽变，因为还有有过多年开发经验的同事扛着，也平稳度过了，然而第二次人事变动的主角就是这位同事。他要一走，说真的公司剩下的人里再没有一个能扛起这么多事情了：开发服务器的运维，生产环境十几台服务器的运维，网络爬虫系统的运维，网络搜索系统的运维，Python后端数据接口服务器的运维。当时一下子感觉天都要塌下来了！事实上后来和老板聊天时他说道，当时他已经开始考虑要使用外包了，他也根本没想到不起眼的我可以力顶压力，在把这些东西都一一搞定了。当然这是后话。&lt;/p&gt;

&lt;p&gt;这位同事在半个月后就要离职，他当时也考虑过谁来接手项目的问题。当时公司其他搞开发的同事有用Python搞数据接口的，有用PHP搞前端页面实现和交互的。虽然他们有的有两年开发经验，但都是专注于自己的领域，在其他方向并没怎么拓展。而我恰恰在刚来的时候搞PHP页面实现和交互，在之后上Python公开课做过小项目(业余锻炼派上用场了)，再加上我为公司内网Linux服务器升级PHP及其扩展、搭建TODO App以及博客平台的经验，这位同事便推荐由我这个入职5个月的新人来接手这个项目，老板也是无可奈何地答应了（毕竟我们剩下的人中再无全能型技术人才了）。&lt;/p&gt;

&lt;p&gt;而真正的压力、挑战和技术成长也是从这里开始。&lt;/p&gt;

&lt;p&gt;首先是接手Python端数据接口项目。项目概述：组织内部自由业务，并为PHP提供Restful JSONFormat API。这个项目最大的挑战倒不是技术层面的，而是在内部业务方面既要知晓细节又要把控全局，那就没什么好说的，花大量时间阅读项目源码，理清脉络，在脑海中不断描述和完善整体结构。这个挑战持续了大概有两个月（和其他挑战并行），等到终于把大部分代码读过，又对项目使用的HTTP框架Flask有了进一步了解之后，就再无压力了。&lt;/p&gt;

&lt;p&gt;接着是网络爬虫这块。项目概述：用Python脚本+Phantomjs解析HTML中的产品信息，用Redis做缓存，用HTTP在业务服务器和下载伺服器之间交换抓取任务和抓取到的产品信息。这里边最痛苦的莫过于一个个独立的任务队列了。队列任务流程：业务触发新的抓取请求，请求被投入抓取请求队列(业务服务器)；上步队列消费者索取下载请求，将其提交给下载伺服器接口；下载伺服器接收下载请求，将其放入待抓取队列；上步队列消费者索取请求，解析请求对应HTML中的产品信息，将解析所得产品信息投入信息回传队列；上步队列消费者索取产品信息，将其回传(提交)至业务服务器接口（流程完）。这里边的挑战有很多，1是队列很多，容易挂掉，所以用&lt;code class=&quot;highlighter-rouge&quot;&gt;supervisor&lt;/code&gt;来保证队列生产消费者持续运行；2是由于队列过多带来的接口、流程复杂度的提高，因为项目一直也没有写测试代码，所以一个改动导致的bug很容易影响全盘的稳定运行。也是慢慢体会到没有测试代码所带来的代码改动时心里的没底以及随着改动带来的高额的人工debug的成本。不过好在各个环节都出几遍问题，自己再给调试好之后，整个项目的流程就彻底了然于胸了。在这个过程中稍微改动了一下用Redis做的队列的实现逻辑，为我们开发者提供了一些HTML内容索取接口和缓存服务，后期就只剩维护了。&lt;/p&gt;

&lt;h2 id=&quot;力顶压力独揽全局&quot;&gt;力顶压力，独揽全局&lt;/h2&gt;
&lt;p&gt;接下来就是跟ElasticSearch（ES）相关的最后一个让人大头的项目，ES是一个可以高效率全文检索的搜索引擎。我在接手这个项目的时候使用的是v0.92版，对ES的接口用的PHP的第三方客户端。这个搜索引擎布置在生产环境，由两个物理节点组成了Cluster。但因为数据量大（800万+条信息）所以占用系统内存很多（为它分配了一半的物理内存）；而且每条信息排序的时候需要即时计算score，所以一有搜索请求过来，CPU的压力就会上来一点；再加上这个版本本身的bug导致它运行不够稳定，通常隔几天就会崩溃。当时我最怕的就是它崩溃了，本身手头上的开发任务就多，其他项目又都需要接手维护或管理，所以基本无心再顾忌这个搜索引擎了，只求使用上任负责人交给的死办法重启维护就行了。然而经过几个回合的崩溃、重启之后，我终于受不了了，开始慢慢安排，计划用当时最新的v1.4.1&lt;strong&gt;无缝替换&lt;/strong&gt;掉线上运行的不稳定版本。接下来就是：用工作之余的时间不厌其烦地阅读有点不清晰的官方文档，在测试环境中下载、配置、安装和运行新版本，换用Python语言来使用ES更底层且灵活的API，为PHP写新的应用接口（Python提供），重建每条document在ES中的的检索/存储逻辑，把score的运算由即时分散到平时…所有这些准备工作花去了我一个月左右的业余时间，终于，最后成功地按照我的预期，在线上无缝地替换掉了旧版的ES。&lt;/p&gt;

&lt;p&gt;从此时起，我便成为了公司里第一个也是唯一一个对当时所有项目都了然于胸的人！那种刚开始在大森林里只是负责种树苗，最后却得以爬上高山去俯瞰整个森林的感觉，真的太妙了，所谓“一览众山小”说的就是这种感觉。&lt;/p&gt;

&lt;p&gt;也是从这时候起，Boss对我更加器重了（后来他还把他两室一厅的房子给我住，我住一间，另一件房间则允许我租出去，租金归我），自己做起其中的每个项目来，包括做出各种决策，也都更有方向感和把握了。&lt;/p&gt;

&lt;h2 id=&quot;人事萧条无心再战&quot;&gt;人事萧条，无心再战&lt;/h2&gt;
&lt;p&gt;然而从今年年初开始，随着公司开发人员的人才流失，到最后，基本就只剩我一个光杆司令了。Boss当时有些着急，直接允诺了不少的公司期权给我。然而我继续呆在这里，在可预见的未来，已经没有任何技术成长空间了。其实我最初来大城市的目的就是像牛人学习，结果到最后总是自己在推着自己向高处走，我觉得这样很不好，怕自己越来越狭隘。所以于最近（2015.06.28）向老板提交了辞职信，老板看我去意已决，再加上之前交流的时候有透露过这方面的想法，他也就没有再留我。当然公司这么多项目还是需要有人来接手的，所以我会再待一个月等人来接手。&lt;/p&gt;

&lt;h2 id=&quot;心怀感恩重新上路&quot;&gt;心怀感恩，重新上路&lt;/h2&gt;
&lt;p&gt;其实如果没有这份工作提供给我一个进入编程领域的入口，我是不可能有今天的。我记得刚开始就是这种态度，老板在我刚开始进公司的时候就握着我的手说，谢谢你，加入我们！我当时的回答，也是现在的回答，是：也谢谢你，给我提供这样一个平台和机会。&lt;/p&gt;</content><author><name></name></author><category term="Tech" /><category term="总结" /><summary type="html">一只编程菜鸟，只为找一份编程的工作 13年7月份毕业，听从家里人的安排，去了本省的一家国企工作，直接被派去到东北的项目基地实习。因为会和技术老外讲英语，还和第三方外包人员一起合作调试好了他们承接的电气化自动排水项目的程序，基地领导青睐有加，想把我留在那里。我考虑了一下拒绝了。等工作到12月份的时候，基本已经确定，这份工作不是我想要的。遂瞒着家里人和领导请了一个月的病假，从东北坐了33个小时的火车来到江南，杭州。当时已是冬季，但下火车后仍然觉得“春风拂面”，比起东北让人冻得骨头疼的冷，杭州的天气温和到简直像是春天。</summary></entry><entry><title type="html">我在2015年读过的编程相关的资料</title><link href="http://localhost:4000/2015/03/18/the-programming-related-materials-i-have-read-in-2015.html" rel="alternate" type="text/html" title="我在2015年读过的编程相关的资料" /><published>2015-03-18T00:00:00+08:00</published><updated>2015-03-18T00:00:00+08:00</updated><id>http://localhost:4000/2015/03/18/the-programming-related-materials-i-have-read-in-2015</id><content type="html" xml:base="http://localhost:4000/2015/03/18/the-programming-related-materials-i-have-read-in-2015.html">&lt;p&gt;平时会读一些技术博客什么的，但都是零零星星不成体统的。所以在此新建一篇博客来专门记录这些自己读过的编程相关的资料。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;时间：02.07&lt;br /&gt;
资料：《iptables防火墙原理详解》 | by seanlook | http://segmentfault.com/blog/seanlook/1190000002540601&lt;br /&gt;
评论:对数据包通过一个节点时的处理流程有了全面的了解，里面的图片很不错。再配合着看完网上的《2小时玩转iptables企业版.ppt》，终于有了俯瞰整个数据包走向流程的视野。&lt;/p&gt;

&lt;p&gt;时间：02.08 ~ 02.09 &lt;br /&gt;
资料：《What Every Programmer Should Know about Memory?》 | by Ulrich Drepper | http://www.akkadia.org/drepper/cpumemory.pdf&lt;br /&gt;
评论：论文篇幅太长，再者涉及内容偏重硬件设计，所以暂时搁置，有时间再读。&lt;/p&gt;

&lt;p&gt;时间：03.03&lt;br /&gt;
资料：《白话经典算法系列之六 快速排序 快速搞定》 | by MoreWindows | http://blog.csdn.net/morewindows/article/details/6684558&lt;br /&gt;
评论：精简地把快速排序的一种思路用精妙的“挖坑待种”的比喻表达了出来，看完并实验后发现这种思路下的快速排序的实现是如此简单！&lt;/p&gt;

&lt;p&gt;时间：03.10&lt;br /&gt;
资料：《白话经典算法系列之七 堆与堆排序》 | by MoreWindows | http://blog.csdn.net/morewindows/article/details/6709644/&lt;br /&gt;
评论：其实作为非科班出身的编程者，在做了很多表层的编程语言层面和公司业务层面的编程工作后，最基础的内功却几乎是空的。数据结构这一块一直是只对编程语言中的常见数据结构有接触，像更底层却很有意思的比如”堆”却几乎没接触过，所幸接触后发现至少堆结构还是很简单的。&lt;/p&gt;

&lt;p&gt;时间：03.17&lt;br /&gt;
资料：《What every web developer must know about URL encoding》 | by Stéphane Épardaud | http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding&lt;br /&gt;
评论：这是”编程人员应该知道的xxx”系列中的一篇，主要讲URL-Encoding的种种。其实看的时候更多的是共鸣（相比于其他资料带来的透彻感），因为这样的问题在自己搞开发的时候都已经考虑、验证过了。不过作者讲得更系统、全面一些，看完后至少开阔了眼界（看似乱码实则符合RFC规范的URL，url encode/decode在不同层级的服务上的处理情况如web-server层、编程语言层）&lt;/p&gt;

&lt;p&gt;时间：03.17&lt;br /&gt;
资料：《What Every Programmer Should know about Time》 | by EmilMikulic | https://unix4lyfe.org/time/?v=1 &lt;br /&gt;
评论：文章挺短的，还趁机看了一下其中提到的”leap seconds”和”Daylight saving”，还顺带回顾了一下两种用来计量时间的装置：石英钟和原子钟的原理。很喜欢文章中提到的一个观点：时间总是应该以Unix Timestamp的形式被保存起来，而不是”Y-m-D H:M:S”这种人类可读的方式，因为后者是表现层的事儿。&lt;/p&gt;

&lt;p&gt;时间：03.27&lt;br /&gt;
资料：《An Introduction To DOM Events》| by Wilson Page | http://www.smashingmagazine.com/2013/11/12/an-introduction-to-dom-events/&lt;br /&gt;
评论：最大收获是终于对着w3c的&lt;a href=&quot;http://www.w3.org/TR/DOM-Level-3-Events/eventflow.svg&quot;&gt;这张图&lt;/a&gt;把一个DOM Event的生命周期看懂了（之前尝试看了一次，模棱两可）。其次是琐碎的事了：了解了&lt;code class=&quot;highlighter-rouge&quot;&gt;func.bind()&lt;/code&gt;方法&lt;/p&gt;

&lt;p&gt;时间：06.12&lt;br /&gt;
资料：《Inside NGINX: How We Designed for Performance &amp;amp; Scale》| by OWEN GARRETT | http://nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/  &lt;br /&gt;
评论：很多架构解读型的文章，最生动和令人难忘的，大概都属随文展示出来的架构图了。这篇文章里列出了好几张非常不错的架构、流程图。它在拿自己的non-blocking设计和其他相对blocking的设计作对比时，举了个非常形象的例子：Web服务器和Web客户端的通信就像下棋一样，只不过Web服务器通常是一对多负责和很多客户端下棋。服务器可以为每个客户端分配一个棋手（blocking，每个线程/进程负责一个客户端），也可以只用一个棋手来同时跟若干个客户端轮询着下棋（non-blocking，现实中有真人1 vs 360同时进行的棋局哦http://t.cn/R2joHP0 ）。&lt;/p&gt;

&lt;p&gt;时间：06.25  &lt;br /&gt;
资料：《Thread Pools in NGINX Boost Performance 9x!》 | by VALENTIN BARTENEV | http://nginx.com/blog/thread-pools-boost-performance-9x/  &lt;br /&gt;
评论：整篇文章其实只是一个结果报告，Event-Driven-Handling，但是handle某些event时操作确实又是blocking的，怎么办？引入线程池。线程池一直都是用的各类语言自带的(java, python)，具体实现并不是很清楚，计划有时间了看一些线程池的实现的资料。&lt;/p&gt;

&lt;p&gt;时间：10.23&lt;br /&gt;
资料：《Visual Representation of SQL Joins》 | by C.L. Moffatt | http://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins&lt;br /&gt;
评论：关系型数据库Join表的方式有哪些，每种join的使用结果如何？在对Mysql有了一定的业务层的使用经验后，再看这篇文章，觉得人家写的真是简洁而全面。&lt;/p&gt;</content><author><name></name></author><category term="资料" /><summary type="html">平时会读一些技术博客什么的，但都是零零星星不成体统的。所以在此新建一篇博客来专门记录这些自己读过的编程相关的资料。</summary></entry></feed>