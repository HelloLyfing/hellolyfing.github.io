---
layout: post
title: 外部服务的连接参数合理设置问题
---

## 一、背景描述
现在的公司使用的阿里云的机器及服务，由于阿里云的Redis不可用导致我们整站的服务出现不可用。本文讨论的重点不是这个，而是，当阿里云的Redis服务恢复之后，我司整站的服务都开始快速恢复了，但我负责的基础平台的一个交易核心服务却仍然RT很高，没法快速恢复。当时情况紧急，优先选择了重启服务，而服务重启之后这个核心服务的RT也就降下来了。很奇怪的现象，所以这里复盘记录一下。

## 二、第一个疑惑：交易下单的HTTP服务RT居高不下
#### 现象
交易C端Session服务连接Redis严重超时问题（18秒+），从我司的全链路调用监控看到的问题现场如下：
![](/images/2021-10/参数合理设置-C端Session耗时监控.png)

当时略有疑惑：为啥Redis耗时会达到18s+？在Redis连接里，明明设置了超时时间了，证据如下：
```
@Bean(name = Constants.SPRING_BEAN_PREFIX + "AuthCacheClient")
public AuthCacheClient authCacheClient() {
    JedisConfig jedisConfig = new JedisConfig();
    jedisConfig.setHost(confReader.get("user-session.host"));
    jedisConfig.setPort(Integer.valueOf(confReader.get("user-session.port")));
    jedisConfig.setPassword(confReader.get("user-session.password"));
    jedisConfig.setMaxIdle(30);
    jedisConfig.setMaxTotal(50);
    // 下面这一行已经设置了超时时间
    jedisConfig.setTimeout(1000);
    return new AuthCacheClientImpl(jedisConfig);
}
```

接着去看了下Jedis的源码，发现Jedis配置中的超时时间有两类，需要特别注意：
 - timeout: 用于端到端连接的超时时间设定
 - maxWaitMillis：由于Jedis也是使用的线程池化方案（使用了apache的池化代码），该参数用于设置：从线程池中获取一个空闲线程时的等待时间。默认值-1，也就是阻塞式等待，直到有可用线程。当然该参数生效也是有前提开关的，代码详见`org.apache.commons.pool2.impl.GenericObjectPool#borrowObject(long)`

![](/images/2021-10/参数合理设置-Jedis超时配置.png)

#### 原因解释
所以上面代码示例的超时配置并不完整，而且有较大的安全隐患，最好主动设置下`maxWaitMillis`参数    
```
jedisConfig.setMaxWaitMillis(1000);
```

#### 测试验证
通过编写测试用例，验证了上述描述是正确的
```
@Test
public void testTimeoutParam() {
    JedisConfig jedisConfig = new JedisConfig();
    jedisConfig.setHost(redisXconfReader.get("user-session.host"));
    jedisConfig.setPort(Integer.valueOf(redisXconfReader.get("user-session.port")));
    jedisConfig.setPassword(redisXconfReader.get("user-session.password"));
    jedisConfig.setMaxIdle(1);
    jedisConfig.setMaxTotal(1); // 线程池中只放入1个工作线程
    jedisConfig.setTimeout(1000);
    jedisConfig.setMaxWaitMillis(5000); // 不加这一行代码时，最后一行代码会一直等待，直到唯一的工作线程从sleep中返回
    AuthCacheClientImpl authCacheClient = new AuthCacheClientImpl(jedisConfig);
 
    ExecutorService executorService = Executors.newSingleThreadExecutor();
    executorService.submit(() -> {
        authCacheClient.tryWithResource((jedis) -> {
            // 啥也不做，占用唯一一个Jedis线程
            safeSleep(600 * 1000);
            return null;
        });
    });
 
    safeSleep(100); // 保证上一步代码先开始执行
 
    // 不设置maxWaitMillis参数，则本行代码将一直等待可用Jedis线程。设置后则会等待给定时间(5000ms)后抛出超时异常
    authCacheClient.getFromCache("AnyKey".getBytes());
}
```
