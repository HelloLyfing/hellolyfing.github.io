---
layout: post
title: Java并发编程之：Java内存模型
---


The Java memory model specifies how the Java virtual machine works with the computer's memory (RAM). The Java virtual machine is a model of a whole computer so this model naturally includes a memory model - AKA the Java memory model.

It is very important to understand the Java memory model if you want to design correctly behaving concurrent programs. The Java memory model specifies how and when different threads can see values written to shared variables by other threads, and how to synchronize access to shared variables when necessary.

The original Java memory model was insufficient, so the Java memory model was revised in Java 1.5. This version of the Java memory model is still in use in Java 8.

前言：Java内存模型详细说明了Java虚拟机(以下将使用JVM这个术语)是如何与计算机的内存(RAM)进行交互的。JVM是一个完整计算机的模型，所以该模型也包含了内存模块，也就是我们熟知的Java内存模型。

想要设计出符合预期的并发程序，了解Java的内存模型是非常重要的。Java内存模型详细描述了不同的线程如何以及何时可以看见被其他线程写入的共享变量，以及在需要时如何同步使用共享变量。

Java内存模型在一开始是不够完善的，不过它在Java 1.5中被改进了。Java8依然在使用这一改进版本的内存模型。

# 一、一窥Java内存模型的内部

The Java memory model used internally in the JVM divides memory between thread stacks and the heap. This diagram illustrates the Java memory model from a logic perspective:

JVM中的Java内存模型将内存分为线程栈(thread stacks)和堆(heap)。下图从逻辑角度演示了Java的内存模型：

![](/images/java_concurrency/java-memory-model-1.png)

Each thread running in the Java virtual machine has its own thread stack. The thread stack contains information about what methods the thread has called to reach the current point of execution. I will refer to this as the "call stack". As the thread executes its code, the call stack changes.

The thread stack also contains all local variables for each method being executed (all methods on the call stack). A thread can only access it's own thread stack. Local variables created by a thread are invisible to all other threads than the thread who created it. Even if two threads are executing the exact same code, the two threads will still create the local variables of that code in each their own thread stack. Thus, each thread has its own version of each local variable.

All local variables of primitive types ( boolean, byte, short, char, int, long, float, double) are fully stored on the thread stack and are thus not visible to other threads. One thread may pass a copy of a pritimive variable to another thread, but it cannot share the primitive local variable itself.

The heap contains all objects created in your Java application, regardless of what thread created the object. This includes the object versions of the primitive types (e.g. Byte, Integer, Long etc.). It does not matter if an object was created and assigned to a local variable, or created as a member variable of another object, the object is still stored on the heap.

Here is a diagram illustrating the call stack and local variables stored on the thread stacks, and objects stored on the heap:

在JVM中运行的每个线程都有自己的线程栈。线程栈包含的信息为：当前方法执行到的点。我将称这个栈为“调用栈”，当线程执行代码时，调用栈也会随之变化。

线程栈还包含了每个被执行的方法（所有位于调用栈的方法）内部的所有局部变量(local variables)。一个线程只能访问自己的线程栈。被一个线程创建的内部变量，对其他线程是不可见的。即便两个线程在执行一模一样的代码，他们仍然会在自己的线程栈中创建局部变量。也就是说，每个线程都有自己的局部变量的版本。

所有原始类型( boolean, byte, short, char, int, long, float, double)的局部变量全部都存储在线程栈中，所以它们对其他线程是不可见的。一个线程可以向其他线程传递原始类型变量的拷贝，但无法共享内部的原始类型变量。

堆则包含了所有Java对象(objects)，无论它们是由哪个线程创建的，这些对象包括对原始类型封装而成的包装类(Integer、Long等)。无论对象是在局部被创建并复制给局部变量，还是作为其他对象的成员被创建的。这些对象始终都位于堆中。

下图展示了线程栈中存储的调用栈和局部变量，以及堆中存储的对象：

![](/images/java_concurrency/java-memory-model-2.png)

A local variable may be of a primitive type, in which case it is totally kept on the thread stack.

A local variable may also be a reference to an object. In that case the reference (the local variable) is stored on the thread stack, but the object itself if stored on the heap.

An object may contain methods and these methods may contain local variables. These local variables are also stored on the thread stack, even if the object the method belongs to is stored on the heap.

An object's member variables are stored on the heap along with the object itself. That is true both when the member variable is of a primitive type, and if it is a reference to an object.

Static class variables are also stored on the heap along with the class definition.

Objects on the heap can be accessed by all threads that have a reference to the object. When a thread has access to an object, it can also get access to that object's member variables. If two threads call a method on the same object at the same time, they will both have access to the object's member variables, but each thread will have its own copy of the local variables.

Here is a diagram illustrating the points above:

一个局部变量如果是原始类型的，则它会存储在线程栈中。

一个局部变量如果是对一个对象的引用，则这个变量的引用会存储在线程栈中，但引用的对象则会存储在堆中。

一个对象的方法以及方法内的局部变量，也是存储在线程栈中，即便这个对象本身存储在堆中。

一个对象的成员变量和对象一样存储在堆中，无论这个成员变量是原始类型还是对对象的引用。此外，静态类变量也是存储在堆中111。

处于堆中的对象，可以被任何拥有其引用的线程访问到。当一个线程访问一个对象时，它也可以访问到对象的成员变量和方法111。如果两个线程在同一时间访问同一个对象的方法，他们可以同时调用该对象的该方法，不过每个线程都会拥有一份方法内的局部变量的拷贝。

下图演示了上面提到的那些点：

![](/images/java_concurrency/java-memory-model-3.png)

Two threads have a set of local variables. One of the local variables (Local Variable 2) point to a shared object on the heap (Object 3). The two threads each have a different reference to the same object. Their references are local variables and are thus stored in each thread's thread stack (on each). The two different references point to the same object on the heap, though.

Notice how the shared object (Object 3) has a reference to Object 2 and Object 4 as member variables (illustrated by the arrows from Object 3 to Object 2 and Object 4). Via these member variable references in Object 3 the two threads can access Object 2 and Object 4.

The diagram also shows a local variable which point to two different objects on the heap. In this case the references point to two different objects (Object 1 and Object 5), not the same object. In theory both threads could access both Object 1 and Object 5, if both threads had references to both objects. But in the diagram above each thread only has a reference to one of the two objects.

So, what kind of Java code could lead to the above memory graph? Well, code as simple as the code below:

两个线程有一组局部变量。其中一个局部变量Local Variable 2指向了位于堆中的对象Object 3。这两个线程的局部变量和引用是不一样的，它们存储在各自的线程栈中，虽然二者指向的同一个对象存储在堆中。

注意对象Object 3的成员变量，分别引用了对象Object 2和对象Object 4（注意图中Object 3指向Object 2和Object 4的箭头），藉由对象Object 3中的成员变量，两个线程也可以访问到对象Object 2和Object 4.

图中也展示了线程栈中的methodTwo()中的局部变量Local Variable 1指向位于堆中的两个不同对象的情况。此时这个引用指向了两个不同的对象（Object 1和Object 5），而不是同一对象。理论上每个线程都可以访问到这两个对象Object 1和Object 5，如果每个线程都有指向这两个对象的引用。但在上图中，每个线程只有一个指向两个对象之一的引用。

那么，用什么样的Java代码可以反推出上面的内存图呢？其实，图例对应的Java代码也很简单：

```
public class MyRunnable implements Runnable() {

    public void run() {
        methodOne();
    }

    public void methodOne() {
        int localVariable1 = 45;

        MySharedObject localVariable2 =
            MySharedObject.sharedInstance;

        //... do more with local variables.

        methodTwo();
    }

    public void methodTwo() {
        Integer localVariable1 = new Integer(99);

        //... do more with local variable.
    }
}
```

```
public class MySharedObject {

    //static variable pointing to instance of MySharedObject

    public static final MySharedObject sharedInstance =
        new MySharedObject();


    //member variables pointing to two objects on the heap

    public Integer object2 = new Integer(22);
    public Integer object4 = new Integer(44);

    public long member1 = 12345;
    public long member1 = 67890;
}
```

If two threads were executing the run() method then the diagram shown earlier would be the outcome. The run() method calls methodOne() and methodOne() calls methodTwo().

methodOne() declares a primitive local variable (localVariable1 of type int) and an local variable which is an object reference (localVariable2).


如果启动两个线程同时执行run()方法，就能得出上图中的那些关系图。run()方法调用了methodOne()，methodOne()又调用了methodTwo().

methodOne()定义了一个原始int型的局部变量localVariable1，以及一个对对象引用的局部变量localVariable2。

Each thread executing methodOne() will create its own copy of localVariable1 and localVariable2 on their respective thread stacks. The localVariable1 variables will be completely separated from each other, only living on each thread's thread stack. One thread cannot see what changes another thread makes to its copy of localVariable1.

每个执行methodOne()的线程都会在自己的线程栈中创建localVariable1和localVariable2的拷贝。各线程之间的localVariable1是完全隔离的，只存在于各自的线程栈中。线程A无法看到其他线程对拷贝来的localVariable1做出的改变。

Each thread executing methodOne() will also create their own copy of localVariable2. However, the two different copies of localVariable2 both end up pointing to the same object on the heap. The code sets localVariable2 to point to an object referenced by a static variable. There is only one copy of a static variable and this copy is stored on the heap. Thus, both of the two copies of localVariable2 end up pointing to the same instance of MySharedObject which the static variable points to. The MySharedObject instance is also stored on the heap. It corresponds to Object 3 in the diagram above.

每个执行methodOne()的方法，也都会创建属于自己的localVariable2的拷贝。然而，这两份独立的互不相干的localVariable2拷贝，其引用都指向了位于堆中的同一对象Object 3。从代码中可以看出，localVariable2的引用指向了另外一个对象MySharedObject中的静态成员变量sharedInstance。我们知道对象的静态成员变量只有一份，而且是存储在堆中的。这样一来，两份独立的localVariable2的拷贝最终都指向了MySharedObject对象中的同一个静态成员变量所指向的对象：MySharedObject的实例，也就是上图中的Object 3。

Notice how the MySharedObject class contains two member variables too. The member variables themselves are stored on the heap along with the object. The two member variables point to two other Integer objects. These Integer objects correspond to Object 2 and Object 4 in the diagram above.

注意观察MySharedObject也包含了两个Integer类型的成员变量。这两个成员变量和对象本身都存储在堆中。二者分别指向了两个即时创建的Integer对象Object 2和Object 4，如上图所示。

Notice also how methodTwo() creates a local variable named localVariable1. This local variable is an object reference to an Integer object. The method sets the localVariable1 reference to point to a new Integer instance. The localVariable1 reference will be stored in one copy per thread executing methodTwo(). The two Integer objects instantiated will be stored on the heap, but since the method creates a new Integer object every time the method is executed, two threads executing this method will create separate Integer instances. The Integer objects created inside methodTwo() correspond to Object 1 and Object 5 in the diagram above.

注意观察methodTwo()创建了一个局部变量localVariable1。这个局部变量是对一个Integer对象的引用。该方法将localVariable1的引用指向了一个新的Integer对象实例。局部变量localVariable1储存在每个执行methodTwo()的线程的线程栈中。由于每个线程每次执行methodTwo()时都会创建新的Integer对象，所以当两个线程执行该方法时会创建两个独立的Integer对象，即上图中的Object 1和Object 5。

Notice also the two member variables in the class MySharedObject of type long which is a primitive type. Since these variables are member variables, they are still stored on the heap along with the object. Only local variables are stored on the thread stack.

注意MySharedObject对象中的两个原始long类型的成员变量。由于这些变量是原始类型的成员变量，所以他们和对象本身都会存储在堆中。只有方法中的局部变量会存储在线程栈中。

# 二、物理内存的结构

Modern hardware memory architecture is somewhat different from the internal Java memory model. It is important to understand the hardware memory architecture too, to understand how the Java memory model works with it. This section describes the common hardware memory architecture, and a later section will describe how the Java memory model works with it.

Here is a simplified diagram of modern computer hardware architecture:

现代的物理内存架构和JVM中的Java内存模型有些不同。为了更好地理解Java内存模型是如何与硬件内存相关协作的，我们也同样需要了解下物理内存的结构。本节会描述一个常见的物理内存架构，后续章节则会介绍Java内存模型是如何与之协作的。

下面是一个简化版的现代计算机硬件结构图：

![](/images/java_concurrency/java-memory-model-4.png)


A modern computer often has 2 or more CPUs in it. Some of these CPUs may have multiple cores too. The point is, that on a modern computer with 2 or more CPUs it is possible to have more than one thread running simultaneously. Each CPU is capable of running one thread at any given time. That means that if your Java application is multithreaded, one thread per CPU may be running simultaneously (concurrently) inside your Java application.

一个现代计算机通常会有2个或更多的CPU，有些CPU还会有多个核心。关键在于，一个拥有两个及更多CPU的现代计算机，同步执行多个线程任务是完全可能的。每个CPU在任何时间都可以执行一个线程。也就是说，如果你的Java应用时多线程的，那么为每个线程分配一个CPU，同步(并行)地进行的Java任务也是有可能的。

Each CPU contains a set of registers which are essentially in-CPU memory. The CPU can perform operations much faster on these registers than it can perform on variables in main memory. That is because the CPU can access these registers much faster than it can access main memory.

每个CPU都包含了一组寄存器，这些寄存器本质上其实是更靠近CPU的内存(in-CPU memory). CPU在寄存器上执行的操作比在主内存(main memory)上执行操作要快得多。这是因为CPU访问寄存器的速度比访问主内存要快得多。

Each CPU may also have a CPU cache memory layer. In fact, most modern CPUs have a cache memory layer of some size. The CPU can access its cache memory much faster than main memory, but typically not as fast as it can access its internal registers. So, the CPU cache memory is somewhere in between the speed of the internal registers and main memory. Some CPUs may have multiple cache layers (Level 1 and Level 2), but this is not so important to know to understand how the Java memory model interacts with memory. What matters is to know that CPUs can have a cache memory layer of some sort.

每个CPU可能也会有一个CPU缓存层。事实上，大多数现代CPU都有一个大小不一的缓存层。CPU访问缓存的速度虽然没有访问内部寄存器快，都却比访问主内存要快的多。所以CPU访问缓存的速度是介于访问内部寄存器和访问主内存之间的。有些CPU可能会有多层级的缓存（Level 1 and Level 2等），但这跟理解Java内存模型的原理关系不大，重要的是了解到CPU有一个缓存层。

A computer also contains a main memory area (RAM). All CPUs can access the main memory. The main memory area is typically much bigger than the cache memories of the CPUs.

计算机还有一个主内存(main memory area，即RAM)。所有CPU都可以访问主内存。主内存的大小通常也比CPU的缓存更大一些。

Typically, when a CPU needs to access main memory it will read part of main memory into its CPU cache. It may even read part of the cache into its internal registers and then perform operations on it. When the CPU needs to write the result back to main memory it will flush the value from its internal register to the cache memory, and at some point flush the value back to main memory.

通常情况下，当CPU需要访问主内存时，它会读取部分主内存中的信息放入CPU缓存。它也可能会读取部分缓存中的信息放入内部寄存器，然后在其之上进行操作。当CPU需要把计算结果写回主内存时，它会把内部寄存器的值flush(拷贝后清空)至缓存，然后在某个时间点再把缓存中值flush至主内存。

The values stored in the cache memory is typically flushed back to main memory when the CPU needs to store something else in the cache memory. The CPU cache can have data written to part of its memory at a time, and flush part of its memory at a time. It does not have to read / write the full cache each time it is updated. Typically the cache is updated in smaller memory blocks called "cache lines". One or more cache lines may be read into the cache memory, and one or mor cache lines may be flushed back to main memory again.

CPU缓存中的值flush至主内存，通常发生在CPU需要在缓存中存储其他值时。在某个时间点，CPU缓存中写入的数据只占了缓存空间的一部分，同样在某个时间点，它会flush back部分数据至主内存。当数据更新时，它并不需要读取或写入整个缓存。通常情况下，缓存以一个更小的内存块来更新，这个内存块就叫做"缓存行"(cache lines)。一条或多条缓存行会被读入缓存中，另外一条或多条缓存行又会被flush back至主内存中。

# 三、打通Java内存模型与物理内存结构
As already mentioned, the Java memory model and the hardware memory architecture are different. The hardware memory architecture does not distinguish between thread stacks and heap. On the hardware, both the thread stack and the heap are located in main memory. Parts of the thread stacks and heap may sometimes be present in CPU caches and in internal CPU registers. This is illustrated in this diagram:

上面已经说过Java内存模型和物理内存结构是不同的。物理内存结构不会区分线程栈和堆。在硬件层面，线程栈和堆都是存储在主内存中的。部分线程栈或堆的信息会出现在CPU缓存及内部寄存器中。线程栈和堆在CPU寄存器、缓存以及主内存中的存储关系如下图所示：

![](/images/java_concurrency/java-memory-model-5.png)

When objects and variables can be stored in various different memory areas in the computer, certain problems may occur. The two main problems are:

Visibility of thread updates (writes) to shared variables.
Race conditions when reading, checking and writing shared variables.
Both of these problems will be explained in the following sections.

当对象和变量存储在计算机中不同的存储区域（如CPU缓存和主内存中）时，某些问题便会出现。两个主要的问题有：
 1. 线程更新共享变量时的可见性
 1. 共同读、检查以及写共享变量时引发的竞争情形(Race conditions)

下面章节会讨论这两个问题。

## 3.1 共享对象的可见性问题
If two or more threads are sharing an object, without the proper use of either volatile declarations or synchronization, updates to the shared object made by one thread may not be visible to other threads.

如果两个或更多的线程在同时访问一个对象，又没有恰当地使用volatile声明或synchronization声明，那么当线程A更新共享对象的信息时，其他线程可能看不到。

Imagine that the shared object is initially stored in main memory. A thread running on CPU one then reads the shared object into its CPU cache. There it makes a change to the shared object. As long as the CPU cache has not been flushed back to main memory, the changed version of the shared object is not visible to threads running on other CPUs. This way each thread may end up with its own copy of the shared object, each copy sitting in a different CPU cache.

想象一下，共享的对象一开始存储在主内存中。运行在CPU-1中的线程A将共享对象读入CPU缓存中，接着对共享对象做了一个更新操作。只要CPU-1中的缓存没有被flush back至主内存，那么共享对象变更后的版本对运行在其他CPU上的线程便是不可见的。这样一来，运行在不同CPU中的线程，在自己CPU的缓存中对共享的对象会有一份各自的临时拷贝。

The following diagram illustrates the sketched situation. One thread running on the left CPU copies the shared object into its CPU cache, and changes its count variable to 2. This change is not visible to other threads running on the right CPU, because the update to count has not been flushed back to main memory yet.

下面的图例演示了这种情况：运行在左侧CPU中的线程将共享对象拷贝至CPU缓存中，然后将该对象的count变量更新为2. 但这个变更对运行在右侧CPU中的线程是不可见的，因为此时更新后的count值还没有被flush back至主内存中。

![](/images/java_concurrency/java-memory-model-6.png)

To solve this problem you can use Java's volatile keyword. The volatile keyword can make sure that a given variable is read directly from main memory, and always written back to main memory when updated.

你可以使用Java中的`volatile`关键字来避免这种情况。`volatile`关键字可以保证在读取给定变量时直接从主内存中读取，当变量值更新时又会被写回主内存中。

## 3.2 竞争情形（Race conditions）

If two or more threads share an object, and more than one thread updates variables in that shared object, race conditions may occur.

Imagine if thread A reads the variable count of a shared object into its CPU cache. Imagine too, that thread B does the same, but into a different CPU cache. Now thread A adds one to count, and thread B does the same. Now var1 has been incremented two times, once in each CPU cache.

If these increments had been carried out sequentially, the variable count would be been incremented twice and had the original value + 2 written back to main memory.

However, the two increments have been carried out concurrently without proper synchronization. Regardless of which of thread A and B that writes its updated version of count back to main memory, the updated value will only be 1 higher than the original value, despite the two increments.

This diagram illustrates an occurrence of the problem with race conditions as described above:

![](/images/java_concurrency/java-memory-model-5.png)

To solve this problem you can use a Java synchronized block. A synchronized block guarantees that only one thread can enter a given critical section of the code at any given time. Synchronized blocks also guarantee that all variables accessed inside the synchronized block will be read in from main memory, and when the thread exits the synchronized block, all updated variables will be flushed back to main memory again, regardless of whether the variable is declared volatile or not.

本篇文章翻译自：http://tutorials.jenkov.com/java-concurrency/java-memory-model.html

后记：前段时间看《Java并发编程的艺术》这本书，发现书中对`volatile`关键字的介绍有些深入不浅出(概念抽象不太到位，要么具体到无关紧要的细节，要么太笼统一带而过)。后来在网上找相关资料时发现了这个并发编程系列的博客，一读之后豁然开朗，于是便有了翻译过来与各位共享的想法。后续还会继续翻译几篇这个系列的博客。

